function _get(e, t, n) {
  return (_get =
    "undefined" != typeof Reflect && Reflect.get
      ? Reflect.get
      : function (e, t, n) {
          var r = _superPropBase(e, t);
          if (r) {
            var i = Object.getOwnPropertyDescriptor(r, t);
            return i.get ? i.get.call(n) : i.value;
          }
        })(e, t, n || e);
}
function _superPropBase(e, t) {
  for (
    ;
    !Object.prototype.hasOwnProperty.call(e, t) &&
    null !== (e = _getPrototypeOf(e));

  );
  return e;
}
function _defineProperties(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, r.key, r);
  }
}
function _createClass(e, t, n) {
  return (
    t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), e
  );
}
function _defineProperty(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (e[t] = n),
    e
  );
}
function _classCallCheck(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _inherits(e, t) {
  if ("function" != typeof t && null !== t)
    throw new TypeError("Super expression must either be null or a function");
  (e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 },
  })),
    t && _setPrototypeOf(e, t);
}
function _setPrototypeOf(e, t) {
  return (_setPrototypeOf =
    Object.setPrototypeOf ||
    function (e, t) {
      return (e.__proto__ = t), e;
    })(e, t);
}
function _createSuper(e) {
  var t = _isNativeReflectConstruct();
  return function () {
    var n,
      r = _getPrototypeOf(e);
    if (t) {
      var i = _getPrototypeOf(this).constructor;
      n = Reflect.construct(r, arguments, i);
    } else n = r.apply(this, arguments);
    return _possibleConstructorReturn(this, n);
  };
}
function _possibleConstructorReturn(e, t) {
  return !t || ("object" != typeof t && "function" != typeof t)
    ? _assertThisInitialized(e)
    : t;
}
function _assertThisInitialized(e) {
  if (void 0 === e)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return e;
}
function _isNativeReflectConstruct() {
  if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
  if (Reflect.construct.sham) return !1;
  if ("function" == typeof Proxy) return !0;
  try {
    return (
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {})),
      !0
    );
  } catch (e) {
    return !1;
  }
}
function _getPrototypeOf(e) {
  return (_getPrototypeOf = Object.setPrototypeOf
    ? Object.getPrototypeOf
    : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
}
(window.webpackJsonp = window.webpackJsonp || []).push([
  [5],
  {
    VH6B: function (e, t, n) {
      (function () {
        "use strict";
        var r,
          i,
          a,
          o = this.THREE || n("Womt");
        if (!o) throw new Error("MeshLine requires three.js");
        function s() {
          (this.positions = []),
            (this.previous = []),
            (this.next = []),
            (this.side = []),
            (this.width = []),
            (this.indices_array = []),
            (this.uvs = []),
            (this.counters = []),
            (this.geometry = new o.BufferGeometry()),
            (this.widthCallback = null),
            (this.matrixWorld = new o.Matrix4());
        }
        function c(e, t, n, r, i) {
          var a;
          if (
            ((e = e.subarray || e.slice ? e : e.buffer),
            (n = n.subarray || n.slice ? n : n.buffer),
            (e = t
              ? e.subarray
                ? e.subarray(t, i && t + i)
                : e.slice(t, i && t + i)
              : e),
            n.set)
          )
            n.set(e, r);
          else for (a = 0; a < e.length; a++) n[a + r] = e[a];
          return n;
        }
        function u(e) {
          o.ShaderMaterial.call(this, {
            uniforms: Object.assign({}, o.UniformsLib.fog, {
              lineWidth: { value: 1 },
              map: { value: null },
              useMap: { value: 0 },
              alphaMap: { value: null },
              useAlphaMap: { value: 0 },
              color: { value: new o.Color(16777215) },
              opacity: { value: 1 },
              resolution: { value: new o.Vector2(1, 1) },
              sizeAttenuation: { value: 1 },
              near: { value: 1 },
              far: { value: 1 },
              dashArray: { value: 0 },
              dashOffset: { value: 0 },
              dashRatio: { value: 0.5 },
              useDash: { value: 0 },
              visibility: { value: 1 },
              alphaTest: { value: 0 },
              repeat: { value: new o.Vector2(1, 1) },
            }),
            vertexShader: o.ShaderChunk.meshline_vert,
            fragmentShader: o.ShaderChunk.meshline_frag,
          }),
            (this.type = "MeshLineMaterial"),
            Object.defineProperties(this, {
              lineWidth: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.lineWidth.value;
                },
                set: function (e) {
                  this.uniforms.lineWidth.value = e;
                },
              },
              map: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.map.value;
                },
                set: function (e) {
                  this.uniforms.map.value = e;
                },
              },
              useMap: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.useMap.value;
                },
                set: function (e) {
                  this.uniforms.useMap.value = e;
                },
              },
              alphaMap: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.alphaMap.value;
                },
                set: function (e) {
                  this.uniforms.alphaMap.value = e;
                },
              },
              useAlphaMap: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.useAlphaMap.value;
                },
                set: function (e) {
                  this.uniforms.useAlphaMap.value = e;
                },
              },
              color: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.color.value;
                },
                set: function (e) {
                  this.uniforms.color.value = e;
                },
              },
              opacity: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.opacity.value;
                },
                set: function (e) {
                  this.uniforms.opacity.value = e;
                },
              },
              resolution: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.resolution.value;
                },
                set: function (e) {
                  this.uniforms.resolution.value.copy(e);
                },
              },
              sizeAttenuation: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.sizeAttenuation.value;
                },
                set: function (e) {
                  this.uniforms.sizeAttenuation.value = e;
                },
              },
              near: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.near.value;
                },
                set: function (e) {
                  this.uniforms.near.value = e;
                },
              },
              far: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.far.value;
                },
                set: function (e) {
                  this.uniforms.far.value = e;
                },
              },
              dashArray: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.dashArray.value;
                },
                set: function (e) {
                  (this.uniforms.dashArray.value = e),
                    (this.useDash = 0 !== e ? 1 : 0);
                },
              },
              dashOffset: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.dashOffset.value;
                },
                set: function (e) {
                  this.uniforms.dashOffset.value = e;
                },
              },
              dashRatio: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.dashRatio.value;
                },
                set: function (e) {
                  this.uniforms.dashRatio.value = e;
                },
              },
              useDash: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.useDash.value;
                },
                set: function (e) {
                  this.uniforms.useDash.value = e;
                },
              },
              visibility: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.visibility.value;
                },
                set: function (e) {
                  this.uniforms.visibility.value = e;
                },
              },
              alphaTest: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.alphaTest.value;
                },
                set: function (e) {
                  this.uniforms.alphaTest.value = e;
                },
              },
              repeat: {
                enumerable: !0,
                get: function () {
                  return this.uniforms.repeat.value;
                },
                set: function (e) {
                  this.uniforms.repeat.value.copy(e);
                },
              },
            }),
            this.setValues(e);
        }
        (s.prototype.setMatrixWorld = function (e) {
          this.matrixWorld = e;
        }),
          (s.prototype.setGeometry = function (e, t) {
            if (
              ((this.widthCallback = t),
              (this.positions = []),
              (this.counters = []),
              e instanceof o.Geometry)
            )
              for (var n = 0; n < e.vertices.length; n++) {
                var r = e.vertices[n];
                (t = n / e.vertices.length),
                  this.positions.push(r.x, r.y, r.z),
                  this.positions.push(r.x, r.y, r.z),
                  this.counters.push(t),
                  this.counters.push(t);
              }
            if (e instanceof Float32Array || e instanceof Array)
              for (n = 0; n < e.length; n += 3)
                (t = n / e.length),
                  this.positions.push(e[n], e[n + 1], e[n + 2]),
                  this.positions.push(e[n], e[n + 1], e[n + 2]),
                  this.counters.push(t),
                  this.counters.push(t);
            this.process();
          }),
          (s.prototype.raycast =
            ((r = new o.Matrix4()),
            (i = new o.Ray()),
            (a = new o.Sphere()),
            function (e, t) {
              var n = e.linePrecision,
                s = n * n,
                c = this.geometry;
              if (
                (null === c.boundingSphere && c.computeBoundingSphere(),
                a.copy(c.boundingSphere),
                a.applyMatrix4(this.matrixWorld),
                !1 !== e.ray.intersectSphere(a))
              ) {
                r.getInverse(this.matrixWorld), i.copy(e.ray).applyMatrix4(r);
                var u = new o.Vector3(),
                  l = new o.Vector3(),
                  h = new o.Vector3(),
                  d = new o.Vector3(),
                  p = this instanceof o.LineSegments ? 2 : 1;
                if (c instanceof o.BufferGeometry) {
                  var f = c.index,
                    m = c.attributes;
                  if (null !== f)
                    for (
                      var v = f.array,
                        g = m.position.array,
                        y = 0,
                        x = v.length - 1;
                      y < x;
                      y += p
                    ) {
                      var b = v[y + 1];
                      u.fromArray(g, 3 * v[y]),
                        l.fromArray(g, 3 * b),
                        i.distanceSqToSegment(u, l, d, h) > s ||
                          (d.applyMatrix4(this.matrixWorld),
                          (M = e.ray.origin.distanceTo(d)) < e.near ||
                            M > e.far ||
                            t.push({
                              distance: M,
                              point: h.clone().applyMatrix4(this.matrixWorld),
                              index: y,
                              face: null,
                              faceIndex: null,
                              object: this,
                            }));
                    }
                  else
                    for (
                      y = 0, x = (g = m.position.array).length / 3 - 1;
                      y < x;
                      y += p
                    )
                      u.fromArray(g, 3 * y),
                        l.fromArray(g, 3 * y + 3),
                        i.distanceSqToSegment(u, l, d, h) > s ||
                          (d.applyMatrix4(this.matrixWorld),
                          (M = e.ray.origin.distanceTo(d)) < e.near ||
                            M > e.far ||
                            t.push({
                              distance: M,
                              point: h.clone().applyMatrix4(this.matrixWorld),
                              index: y,
                              face: null,
                              faceIndex: null,
                              object: this,
                            }));
                } else if (c instanceof o.Geometry) {
                  var _ = c.vertices,
                    w = _.length;
                  for (y = 0; y < w - 1; y += p) {
                    var M;
                    i.distanceSqToSegment(_[y], _[y + 1], d, h) > s ||
                      (d.applyMatrix4(this.matrixWorld),
                      (M = e.ray.origin.distanceTo(d)) < e.near ||
                        M > e.far ||
                        t.push({
                          distance: M,
                          point: h.clone().applyMatrix4(this.matrixWorld),
                          index: y,
                          face: null,
                          faceIndex: null,
                          object: this,
                        }));
                  }
                }
              }
            })),
          (s.prototype.compareV3 = function (e, t) {
            var n = 6 * e,
              r = 6 * t;
            return (
              this.positions[n] === this.positions[r] &&
              this.positions[n + 1] === this.positions[r + 1] &&
              this.positions[n + 2] === this.positions[r + 2]
            );
          }),
          (s.prototype.copyV3 = function (e) {
            var t = 6 * e;
            return [
              this.positions[t],
              this.positions[t + 1],
              this.positions[t + 2],
            ];
          }),
          (s.prototype.process = function () {
            var e,
              t,
              n = this.positions.length / 6;
            (this.previous = []),
              (this.next = []),
              (this.side = []),
              (this.width = []),
              (this.indices_array = []),
              (this.uvs = []);
            for (var r = 0; r < n; r++) this.side.push(1), this.side.push(-1);
            for (r = 0; r < n; r++)
              (e = this.widthCallback ? this.widthCallback(r / (n - 1)) : 1),
                this.width.push(e),
                this.width.push(e);
            for (r = 0; r < n; r++)
              this.uvs.push(r / (n - 1), 0), this.uvs.push(r / (n - 1), 1);
            for (
              t = this.compareV3(0, n - 1)
                ? this.copyV3(n - 2)
                : this.copyV3(0),
                this.previous.push(t[0], t[1], t[2]),
                this.previous.push(t[0], t[1], t[2]),
                r = 0;
              r < n - 1;
              r++
            )
              (t = this.copyV3(r)),
                this.previous.push(t[0], t[1], t[2]),
                this.previous.push(t[0], t[1], t[2]);
            for (r = 1; r < n; r++)
              (t = this.copyV3(r)),
                this.next.push(t[0], t[1], t[2]),
                this.next.push(t[0], t[1], t[2]);
            for (
              t = this.compareV3(n - 1, 0)
                ? this.copyV3(1)
                : this.copyV3(n - 1),
                this.next.push(t[0], t[1], t[2]),
                this.next.push(t[0], t[1], t[2]),
                r = 0;
              r < n - 1;
              r++
            ) {
              var i = 2 * r;
              this.indices_array.push(i, i + 1, i + 2),
                this.indices_array.push(i + 2, i + 1, i + 3);
            }
            this.attributes
              ? (this.attributes.position.copyArray(
                  new Float32Array(this.positions)
                ),
                (this.attributes.position.needsUpdate = !0),
                this.attributes.previous.copyArray(
                  new Float32Array(this.previous)
                ),
                (this.attributes.previous.needsUpdate = !0),
                this.attributes.next.copyArray(new Float32Array(this.next)),
                (this.attributes.next.needsUpdate = !0),
                this.attributes.side.copyArray(new Float32Array(this.side)),
                (this.attributes.side.needsUpdate = !0),
                this.attributes.width.copyArray(new Float32Array(this.width)),
                (this.attributes.width.needsUpdate = !0),
                this.attributes.uv.copyArray(new Float32Array(this.uvs)),
                (this.attributes.uv.needsUpdate = !0),
                this.attributes.index.copyArray(
                  new Uint16Array(this.indices_array)
                ),
                (this.attributes.index.needsUpdate = !0))
              : (this.attributes = {
                  position: new o.BufferAttribute(
                    new Float32Array(this.positions),
                    3
                  ),
                  previous: new o.BufferAttribute(
                    new Float32Array(this.previous),
                    3
                  ),
                  next: new o.BufferAttribute(new Float32Array(this.next), 3),
                  side: new o.BufferAttribute(new Float32Array(this.side), 1),
                  width: new o.BufferAttribute(new Float32Array(this.width), 1),
                  uv: new o.BufferAttribute(new Float32Array(this.uvs), 2),
                  index: new o.BufferAttribute(
                    new Uint16Array(this.indices_array),
                    1
                  ),
                  counters: new o.BufferAttribute(
                    new Float32Array(this.counters),
                    1
                  ),
                }),
              this.geometry.addAttribute("position", this.attributes.position),
              this.geometry.addAttribute("previous", this.attributes.previous),
              this.geometry.addAttribute("next", this.attributes.next),
              this.geometry.addAttribute("side", this.attributes.side),
              this.geometry.addAttribute("width", this.attributes.width),
              this.geometry.addAttribute("uv", this.attributes.uv),
              this.geometry.addAttribute("counters", this.attributes.counters),
              this.geometry.setIndex(this.attributes.index);
          }),
          (s.prototype.advance = function (e) {
            var t = this.attributes.position.array,
              n = this.attributes.next.array,
              r = t.length;
            c(t, 0, this.attributes.previous.array, 0, r),
              c(t, 6, t, 0, r - 6),
              (t[r - 6] = e.x),
              (t[r - 5] = e.y),
              (t[r - 4] = e.z),
              (t[r - 3] = e.x),
              (t[r - 2] = e.y),
              (t[r - 1] = e.z),
              c(t, 6, n, 0, r - 6),
              (n[r - 6] = e.x),
              (n[r - 5] = e.y),
              (n[r - 4] = e.z),
              (n[r - 3] = e.x),
              (n[r - 2] = e.y),
              (n[r - 1] = e.z),
              (this.attributes.position.needsUpdate = !0),
              (this.attributes.previous.needsUpdate = !0),
              (this.attributes.next.needsUpdate = !0);
          }),
          (o.ShaderChunk.meshline_vert = [
            "",
            o.ShaderChunk.logdepthbuf_pars_vertex,
            o.ShaderChunk.fog_pars_vertex,
            "",
            "attribute vec3 previous;",
            "attribute vec3 next;",
            "attribute float side;",
            "attribute float width;",
            "attribute float counters;",
            "",
            "uniform vec2 resolution;",
            "uniform float lineWidth;",
            "uniform vec3 color;",
            "uniform float opacity;",
            "uniform float near;",
            "uniform float far;",
            "uniform float sizeAttenuation;",
            "",
            "varying vec2 vUV;",
            "varying vec4 vColor;",
            "varying float vCounters;",
            "",
            "vec2 fix( vec4 i, float aspect ) {",
            "",
            "    vec2 res = i.xy / i.w;",
            "    res.x *= aspect;",
            "\t vCounters = counters;",
            "    return res;",
            "",
            "}",
            "",
            "void main() {",
            "",
            "    float aspect = resolution.x / resolution.y;",
            "    float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);",
            "",
            "    vColor = vec4( color, opacity );",
            "    vUV = uv;",
            "",
            "    mat4 m = projectionMatrix * modelViewMatrix;",
            "    vec4 finalPosition = m * vec4( position, 1.0 );",
            "    vec4 prevPos = m * vec4( previous, 1.0 );",
            "    vec4 nextPos = m * vec4( next, 1.0 );",
            "",
            "    vec2 currentP = fix( finalPosition, aspect );",
            "    vec2 prevP = fix( prevPos, aspect );",
            "    vec2 nextP = fix( nextPos, aspect );",
            "",
            "    float pixelWidth = finalPosition.w * pixelWidthRatio;",
            "    float w = 1.8 * pixelWidth * lineWidth * width;",
            "",
            "    if( sizeAttenuation == 1. ) {",
            "        w = 1.8 * lineWidth * width;",
            "    }",
            "",
            "    vec2 dir;",
            "    if( nextP == currentP ) dir = normalize( currentP - prevP );",
            "    else if( prevP == currentP ) dir = normalize( nextP - currentP );",
            "    else {",
            "        vec2 dir1 = normalize( currentP - prevP );",
            "        vec2 dir2 = normalize( nextP - currentP );",
            "        dir = normalize( dir1 + dir2 );",
            "",
            "        vec2 perp = vec2( -dir1.y, dir1.x );",
            "        vec2 miter = vec2( -dir.y, dir.x );",
            "        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );",
            "",
            "    }",
            "",
            "    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;",
            "    vec2 normal = vec2( -dir.y, dir.x );",
            "    normal.x /= aspect;",
            "    normal *= .5 * w;",
            "",
            "    vec4 offset = vec4( normal * side, 0.0, 1.0 );",
            "    finalPosition.xy += offset.xy;",
            "",
            "    gl_Position = finalPosition;",
            "",
            o.ShaderChunk.logdepthbuf_vertex,
            o.ShaderChunk.fog_vertex &&
              "    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            o.ShaderChunk.fog_vertex,
            "}",
          ].join("\r\n")),
          (o.ShaderChunk.meshline_frag = [
            "",
            o.ShaderChunk.fog_pars_fragment,
            o.ShaderChunk.logdepthbuf_pars_fragment,
            "",
            "uniform sampler2D map;",
            "uniform sampler2D alphaMap;",
            "uniform float useMap;",
            "uniform float useAlphaMap;",
            "uniform float useDash;",
            "uniform float dashArray;",
            "uniform float dashOffset;",
            "uniform float dashRatio;",
            "uniform float visibility;",
            "uniform float alphaTest;",
            "uniform vec2 repeat;",
            "",
            "varying vec2 vUV;",
            "varying vec4 vColor;",
            "varying float vCounters;",
            "",
            "void main() {",
            "",
            o.ShaderChunk.logdepthbuf_fragment,
            "",
            "    vec4 c = vColor;",
            "    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );",
            "    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;",
            "    if( c.a < alphaTest ) discard;",
            "    if( useDash == 1. ){",
            "        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));",
            "    }",
            "    gl_FragColor = c;",
            "    gl_FragColor.a *= step(vCounters, visibility);",
            "",
            o.ShaderChunk.fog_fragment,
            "}",
          ].join("\r\n")),
          ((u.prototype = Object.create(
            o.ShaderMaterial.prototype
          )).constructor = u),
          (u.prototype.isMeshLineMaterial = !0),
          (u.prototype.copy = function (e) {
            return (
              o.ShaderMaterial.prototype.copy.call(this, e),
              (this.lineWidth = e.lineWidth),
              (this.map = e.map),
              (this.useMap = e.useMap),
              (this.alphaMap = e.alphaMap),
              (this.useAlphaMap = e.useAlphaMap),
              this.color.copy(e.color),
              (this.opacity = e.opacity),
              this.resolution.copy(e.resolution),
              (this.sizeAttenuation = e.sizeAttenuation),
              (this.near = e.near),
              (this.far = e.far),
              this.dashArray.copy(e.dashArray),
              this.dashOffset.copy(e.dashOffset),
              this.dashRatio.copy(e.dashRatio),
              (this.useDash = e.useDash),
              (this.visibility = e.visibility),
              (this.alphaTest = e.alphaTest),
              this.repeat.copy(e.repeat),
              this
            );
          }),
          e.exports && (t = e.exports = { MeshLine: s, MeshLineMaterial: u }),
          (t.MeshLine = s),
          (t.MeshLineMaterial = u);
      }.call(this));
    },
    Womt: function (e, t, n) {
      "use strict";
      var r;
      n.r(t),
        n.d(t, "ACESFilmicToneMapping", function () {
          return ae;
        }),
        n.d(t, "AddEquation", function () {
          return L;
        }),
        n.d(t, "AddOperation", function () {
          return ee;
        }),
        n.d(t, "AdditiveAnimationBlendMode", function () {
          return Zt;
        }),
        n.d(t, "AdditiveBlending", function () {
          return S;
        }),
        n.d(t, "AlphaFormat", function () {
          return Ue;
        }),
        n.d(t, "AlwaysDepth", function () {
          return W;
        }),
        n.d(t, "AlwaysStencilFunc", function () {
          return An;
        }),
        n.d(t, "AmbientLight", function () {
          return Th;
        }),
        n.d(t, "AmbientLightProbe", function () {
          return Yh;
        }),
        n.d(t, "AnimationClip", function () {
          return Ol;
        }),
        n.d(t, "AnimationLoader", function () {
          return Gl;
        }),
        n.d(t, "AnimationMixer", function () {
          return Sd;
        }),
        n.d(t, "AnimationObjectGroup", function () {
          return wd;
        }),
        n.d(t, "AnimationUtils", function () {
          return xl;
        }),
        n.d(t, "ArcCurve", function () {
          return Yl;
        }),
        n.d(t, "ArrayCamera", function () {
          return Ds;
        }),
        n.d(t, "ArrowHelper", function () {
          return dp;
        }),
        n.d(t, "Audio", function () {
          return id;
        }),
        n.d(t, "AudioAnalyser", function () {
          return ld;
        }),
        n.d(t, "AudioContext", function () {
          return Wh;
        }),
        n.d(t, "AudioListener", function () {
          return rd;
        }),
        n.d(t, "AudioLoader", function () {
          return qh;
        }),
        n.d(t, "AxesHelper", function () {
          return pp;
        }),
        n.d(t, "AxisHelper", function () {
          return cf;
        }),
        n.d(t, "BackSide", function () {
          return y;
        }),
        n.d(t, "BasicDepthPacking", function () {
          return cn;
        }),
        n.d(t, "BasicShadowMap", function () {
          return p;
        }),
        n.d(t, "BinaryTextureLoader", function () {
          return pf;
        }),
        n.d(t, "Bone", function () {
          return xc;
        }),
        n.d(t, "BooleanKeyframeTrack", function () {
          return Tl;
        }),
        n.d(t, "BoundingBoxHelper", function () {
          return uf;
        }),
        n.d(t, "Box2", function () {
          return Dd;
        }),
        n.d(t, "Box3", function () {
          return Gr;
        }),
        n.d(t, "Box3Helper", function () {
          return sp;
        }),
        n.d(t, "BoxBufferGeometry", function () {
          return ya;
        }),
        n.d(t, "BoxGeometry", function () {
          return ga;
        }),
        n.d(t, "BoxHelper", function () {
          return op;
        }),
        n.d(t, "BufferAttribute", function () {
          return Ei;
        }),
        n.d(t, "BufferGeometry", function () {
          return Wi;
        }),
        n.d(t, "BufferGeometryLoader", function () {
          return Dh;
        }),
        n.d(t, "ByteType", function () {
          return Le;
        }),
        n.d(t, "Cache", function () {
          return Il;
        }),
        n.d(t, "Camera", function () {
          return Ma;
        }),
        n.d(t, "CameraHelper", function () {
          return rp;
        }),
        n.d(t, "CanvasRenderer", function () {
          return vf;
        }),
        n.d(t, "CanvasTexture", function () {
          return Wc;
        }),
        n.d(t, "CatmullRomCurve3", function () {
          return eh;
        }),
        n.d(t, "CineonToneMapping", function () {
          return ie;
        }),
        n.d(t, "CircleBufferGeometry", function () {
          return ol;
        }),
        n.d(t, "CircleGeometry", function () {
          return al;
        }),
        n.d(t, "ClampToEdgeWrapping", function () {
          return me;
        }),
        n.d(t, "Clock", function () {
          return Qh;
        }),
        n.d(t, "ClosedSplineCurve3", function () {
          return af;
        }),
        n.d(t, "Color", function () {
          return vi;
        }),
        n.d(t, "ColorKeyframeTrack", function () {
          return El;
        }),
        n.d(t, "CompressedTexture", function () {
          return Vc;
        }),
        n.d(t, "CompressedTextureLoader", function () {
          return kl;
        }),
        n.d(t, "ConeBufferGeometry", function () {
          return il;
        }),
        n.d(t, "ConeGeometry", function () {
          return rl;
        }),
        n.d(t, "CubeCamera", function () {
          return Ta;
        }),
        n.d(t, "CubeGeometry", function () {
          return ga;
        }),
        n.d(t, "CubeReflectionMapping", function () {
          return ce;
        }),
        n.d(t, "CubeRefractionMapping", function () {
          return ue;
        }),
        n.d(t, "CubeTexture", function () {
          return Ka;
        }),
        n.d(t, "CubeTextureLoader", function () {
          return Vl;
        }),
        n.d(t, "CubeUVReflectionMapping", function () {
          return de;
        }),
        n.d(t, "CubeUVRefractionMapping", function () {
          return pe;
        }),
        n.d(t, "CubicBezierCurve", function () {
          return ih;
        }),
        n.d(t, "CubicBezierCurve3", function () {
          return ah;
        }),
        n.d(t, "CubicInterpolant", function () {
          return _l;
        }),
        n.d(t, "CullFaceBack", function () {
          return c;
        }),
        n.d(t, "CullFaceFront", function () {
          return u;
        }),
        n.d(t, "CullFaceFrontBack", function () {
          return l;
        }),
        n.d(t, "CullFaceNone", function () {
          return s;
        }),
        n.d(t, "Curve", function () {
          return ql;
        }),
        n.d(t, "CurvePath", function () {
          return dh;
        }),
        n.d(t, "CustomBlending", function () {
          return A;
        }),
        n.d(t, "CustomToneMapping", function () {
          return oe;
        }),
        n.d(t, "CylinderBufferGeometry", function () {
          return nl;
        }),
        n.d(t, "CylinderGeometry", function () {
          return tl;
        }),
        n.d(t, "Cylindrical", function () {
          return Pd;
        }),
        n.d(t, "DataTexture", function () {
          return Aa;
        }),
        n.d(t, "DataTexture2DArray", function () {
          return Qa;
        }),
        n.d(t, "DataTexture3D", function () {
          return $a;
        }),
        n.d(t, "DataTextureLoader", function () {
          return Hl;
        }),
        n.d(t, "DecrementStencilOp", function () {
          return vn;
        }),
        n.d(t, "DecrementWrapStencilOp", function () {
          return yn;
        }),
        n.d(t, "DefaultLoadingManager", function () {
          return Bl;
        }),
        n.d(t, "DepthFormat", function () {
          return We;
        }),
        n.d(t, "DepthStencilFormat", function () {
          return qe;
        }),
        n.d(t, "DepthTexture", function () {
          return qc;
        }),
        n.d(t, "DirectionalLight", function () {
          return Sh;
        }),
        n.d(t, "DirectionalLightHelper", function () {
          return ep;
        }),
        n.d(t, "DirectionalLightShadow", function () {
          return Mh;
        }),
        n.d(t, "DiscreteInterpolant", function () {
          return Ml;
        }),
        n.d(t, "DodecahedronBufferGeometry", function () {
          return au;
        }),
        n.d(t, "DodecahedronGeometry", function () {
          return iu;
        }),
        n.d(t, "DoubleSide", function () {
          return x;
        }),
        n.d(t, "DstAlphaFactor", function () {
          return U;
        }),
        n.d(t, "DstColorFactor", function () {
          return k;
        }),
        n.d(t, "DynamicBufferAttribute", function () {
          return Yp;
        }),
        n.d(t, "DynamicCopyUsage", function () {
          return Nn;
        }),
        n.d(t, "DynamicDrawUsage", function () {
          return Cn;
        }),
        n.d(t, "DynamicReadUsage", function () {
          return On;
        }),
        n.d(t, "EdgesGeometry", function () {
          return el;
        }),
        n.d(t, "EdgesHelper", function () {
          return lf;
        }),
        n.d(t, "EllipseCurve", function () {
          return Xl;
        }),
        n.d(t, "EqualDepth", function () {
          return Y;
        }),
        n.d(t, "EqualStencilFunc", function () {
          return wn;
        }),
        n.d(t, "EquirectangularReflectionMapping", function () {
          return le;
        }),
        n.d(t, "EquirectangularRefractionMapping", function () {
          return he;
        }),
        n.d(t, "Euler", function () {
          return lr;
        }),
        n.d(t, "EventDispatcher", function () {
          return zn;
        }),
        n.d(t, "ExtrudeBufferGeometry", function () {
          return Gu;
        }),
        n.d(t, "ExtrudeGeometry", function () {
          return Uu;
        }),
        n.d(t, "Face3", function () {
          return bi;
        }),
        n.d(t, "Face4", function () {
          return Dp;
        }),
        n.d(t, "FaceColors", function () {
          return zp;
        }),
        n.d(t, "FileLoader", function () {
          return Ul;
        }),
        n.d(t, "FlatShading", function () {
          return b;
        }),
        n.d(t, "Float32Attribute", function () {
          return nf;
        }),
        n.d(t, "Float32BufferAttribute", function () {
          return Ii;
        }),
        n.d(t, "Float64Attribute", function () {
          return rf;
        }),
        n.d(t, "Float64BufferAttribute", function () {
          return Ni;
        }),
        n.d(t, "FloatType", function () {
          return De;
        }),
        n.d(t, "Fog", function () {
          return ks;
        }),
        n.d(t, "FogExp2", function () {
          return Gs;
        }),
        n.d(t, "Font", function () {
          return Hh;
        }),
        n.d(t, "FontLoader", function () {
          return Vh;
        }),
        n.d(t, "FrontFaceDirectionCCW", function () {
          return d;
        }),
        n.d(t, "FrontFaceDirectionCW", function () {
          return h;
        }),
        n.d(t, "FrontSide", function () {
          return g;
        }),
        n.d(t, "Frustum", function () {
          return Ra;
        }),
        n.d(t, "GammaEncoding", function () {
          return tn;
        }),
        n.d(t, "Geometry", function () {
          return va;
        }),
        n.d(t, "GeometryUtils", function () {
          return mf;
        }),
        n.d(t, "GreaterDepth", function () {
          return J;
        }),
        n.d(t, "GreaterEqualDepth", function () {
          return Z;
        }),
        n.d(t, "GreaterEqualStencilFunc", function () {
          return En;
        }),
        n.d(t, "GreaterStencilFunc", function () {
          return Sn;
        }),
        n.d(t, "GridHelper", function () {
          return Zd;
        }),
        n.d(t, "Group", function () {
          return Is;
        }),
        n.d(t, "HalfFloatType", function () {
          return Ie;
        }),
        n.d(t, "HemisphereLight", function () {
          return vh;
        }),
        n.d(t, "HemisphereLightHelper", function () {
          return Yd;
        }),
        n.d(t, "HemisphereLightProbe", function () {
          return Xh;
        }),
        n.d(t, "IcosahedronBufferGeometry", function () {
          return ru;
        }),
        n.d(t, "IcosahedronGeometry", function () {
          return nu;
        }),
        n.d(t, "ImageBitmapLoader", function () {
          return Gh;
        }),
        n.d(t, "ImageLoader", function () {
          return jl;
        }),
        n.d(t, "ImageUtils", function () {
          return Vn;
        }),
        n.d(t, "ImmediateRenderObject", function () {
          return zd;
        }),
        n.d(t, "IncrementStencilOp", function () {
          return mn;
        }),
        n.d(t, "IncrementWrapStencilOp", function () {
          return gn;
        }),
        n.d(t, "InstancedBufferAttribute", function () {
          return Oh;
        }),
        n.d(t, "InstancedBufferGeometry", function () {
          return Ph;
        }),
        n.d(t, "InstancedInterleavedBuffer", function () {
          return Ed;
        }),
        n.d(t, "InstancedMesh", function () {
          return Sc;
        }),
        n.d(t, "Int16Attribute", function () {
          return Qp;
        }),
        n.d(t, "Int16BufferAttribute", function () {
          return Ri;
        }),
        n.d(t, "Int32Attribute", function () {
          return ef;
        }),
        n.d(t, "Int32BufferAttribute", function () {
          return Oi;
        }),
        n.d(t, "Int8Attribute", function () {
          return Zp;
        }),
        n.d(t, "Int8BufferAttribute", function () {
          return Ai;
        }),
        n.d(t, "IntType", function () {
          return Pe;
        }),
        n.d(t, "InterleavedBuffer", function () {
          return Hs;
        }),
        n.d(t, "InterleavedBufferAttribute", function () {
          return Ws;
        }),
        n.d(t, "Interpolant", function () {
          return bl;
        }),
        n.d(t, "InterpolateDiscrete", function () {
          return Ht;
        }),
        n.d(t, "InterpolateLinear", function () {
          return jt;
        }),
        n.d(t, "InterpolateSmooth", function () {
          return Vt;
        }),
        n.d(t, "InvertStencilOp", function () {
          return xn;
        }),
        n.d(t, "JSONLoader", function () {
          return gf;
        }),
        n.d(t, "KeepStencilOp", function () {
          return pn;
        }),
        n.d(t, "KeyframeTrack", function () {
          return Sl;
        }),
        n.d(t, "LOD", function () {
          return fc;
        }),
        n.d(t, "LatheBufferGeometry", function () {
          return Ju;
        }),
        n.d(t, "LatheGeometry", function () {
          return Zu;
        }),
        n.d(t, "Layers", function () {
          return hr;
        }),
        n.d(t, "LensFlare", function () {
          return xf;
        }),
        n.d(t, "LessDepth", function () {
          return q;
        }),
        n.d(t, "LessEqualDepth", function () {
          return X;
        }),
        n.d(t, "LessEqualStencilFunc", function () {
          return Mn;
        }),
        n.d(t, "LessStencilFunc", function () {
          return _n;
        }),
        n.d(t, "Light", function () {
          return mh;
        }),
        n.d(t, "LightProbe", function () {
          return Lh;
        }),
        n.d(t, "LightShadow", function () {
          return gh;
        }),
        n.d(t, "Line", function () {
          return Pc;
        }),
        n.d(t, "Line3", function () {
          return Bd;
        }),
        n.d(t, "LineBasicMaterial", function () {
          return Tc;
        }),
        n.d(t, "LineCurve", function () {
          return oh;
        }),
        n.d(t, "LineCurve3", function () {
          return sh;
        }),
        n.d(t, "LineDashedMaterial", function () {
          return gl;
        }),
        n.d(t, "LineLoop", function () {
          return Nc;
        }),
        n.d(t, "LinePieces", function () {
          return Np;
        }),
        n.d(t, "LineSegments", function () {
          return Ic;
        }),
        n.d(t, "LineStrip", function () {
          return Ip;
        }),
        n.d(t, "LinearEncoding", function () {
          return $t;
        }),
        n.d(t, "LinearFilter", function () {
          return we;
        }),
        n.d(t, "LinearInterpolant", function () {
          return wl;
        }),
        n.d(t, "LinearMipMapLinearFilter", function () {
          return Ee;
        }),
        n.d(t, "LinearMipMapNearestFilter", function () {
          return Se;
        }),
        n.d(t, "LinearMipmapLinearFilter", function () {
          return Te;
        }),
        n.d(t, "LinearMipmapNearestFilter", function () {
          return Me;
        }),
        n.d(t, "LinearToneMapping", function () {
          return ne;
        }),
        n.d(t, "Loader", function () {
          return zl;
        }),
        n.d(t, "LoaderUtils", function () {
          return Rh;
        }),
        n.d(t, "LoadingManager", function () {
          return Nl;
        }),
        n.d(t, "LogLuvEncoding", function () {
          return rn;
        }),
        n.d(t, "LoopOnce", function () {
          return Ut;
        }),
        n.d(t, "LoopPingPong", function () {
          return kt;
        }),
        n.d(t, "LoopRepeat", function () {
          return Gt;
        }),
        n.d(t, "LuminanceAlphaFormat", function () {
          return je;
        }),
        n.d(t, "LuminanceFormat", function () {
          return He;
        }),
        n.d(t, "MOUSE", function () {
          return a;
        }),
        n.d(t, "Material", function () {
          return wi;
        }),
        n.d(t, "MaterialLoader", function () {
          return Ch;
        }),
        n.d(t, "Math", function () {
          return kn;
        }),
        n.d(t, "MathUtils", function () {
          return kn;
        }),
        n.d(t, "Matrix3", function () {
          return jn;
        }),
        n.d(t, "Matrix4", function () {
          return sr;
        }),
        n.d(t, "MaxEquation", function () {
          return O;
        }),
        n.d(t, "Mesh", function () {
          return ua;
        }),
        n.d(t, "MeshBasicMaterial", function () {
          return Mi;
        }),
        n.d(t, "MeshDepthMaterial", function () {
          return As;
        }),
        n.d(t, "MeshDistanceMaterial", function () {
          return Ls;
        }),
        n.d(t, "MeshFaceMaterial", function () {
          return Up;
        }),
        n.d(t, "MeshLambertMaterial", function () {
          return ml;
        }),
        n.d(t, "MeshMatcapMaterial", function () {
          return vl;
        }),
        n.d(t, "MeshNormalMaterial", function () {
          return fl;
        }),
        n.d(t, "MeshPhongMaterial", function () {
          return dl;
        }),
        n.d(t, "MeshPhysicalMaterial", function () {
          return hl;
        }),
        n.d(t, "MeshStandardMaterial", function () {
          return ll;
        }),
        n.d(t, "MeshToonMaterial", function () {
          return pl;
        }),
        n.d(t, "MinEquation", function () {
          return P;
        }),
        n.d(t, "MirroredRepeatWrapping", function () {
          return ve;
        }),
        n.d(t, "MixOperation", function () {
          return $;
        }),
        n.d(t, "MultiMaterial", function () {
          return Gp;
        }),
        n.d(t, "MultiplyBlending", function () {
          return E;
        }),
        n.d(t, "MultiplyOperation", function () {
          return Q;
        }),
        n.d(t, "NearestFilter", function () {
          return ge;
        }),
        n.d(t, "NearestMipMapLinearFilter", function () {
          return _e;
        }),
        n.d(t, "NearestMipMapNearestFilter", function () {
          return xe;
        }),
        n.d(t, "NearestMipmapLinearFilter", function () {
          return be;
        }),
        n.d(t, "NearestMipmapNearestFilter", function () {
          return ye;
        }),
        n.d(t, "NeverDepth", function () {
          return V;
        }),
        n.d(t, "NeverStencilFunc", function () {
          return bn;
        }),
        n.d(t, "NoBlending", function () {
          return w;
        }),
        n.d(t, "NoColors", function () {
          return Bp;
        }),
        n.d(t, "NoToneMapping", function () {
          return te;
        }),
        n.d(t, "NormalAnimationBlendMode", function () {
          return Yt;
        }),
        n.d(t, "NormalBlending", function () {
          return M;
        }),
        n.d(t, "NotEqualDepth", function () {
          return K;
        }),
        n.d(t, "NotEqualStencilFunc", function () {
          return Tn;
        }),
        n.d(t, "NumberKeyframeTrack", function () {
          return Al;
        }),
        n.d(t, "Object3D", function () {
          return Tr;
        }),
        n.d(t, "ObjectLoader", function () {
          return Nh;
        }),
        n.d(t, "ObjectSpaceNormalMap", function () {
          return hn;
        }),
        n.d(t, "OctahedronBufferGeometry", function () {
          return tu;
        }),
        n.d(t, "OctahedronGeometry", function () {
          return eu;
        }),
        n.d(t, "OneFactor", function () {
          return I;
        }),
        n.d(t, "OneMinusDstAlphaFactor", function () {
          return G;
        }),
        n.d(t, "OneMinusDstColorFactor", function () {
          return H;
        }),
        n.d(t, "OneMinusSrcAlphaFactor", function () {
          return F;
        }),
        n.d(t, "OneMinusSrcColorFactor", function () {
          return B;
        }),
        n.d(t, "OrthographicCamera", function () {
          return wh;
        }),
        n.d(t, "PCFShadowMap", function () {
          return f;
        }),
        n.d(t, "PCFSoftShadowMap", function () {
          return m;
        }),
        n.d(t, "PMREMGenerator", function () {
          return Ap;
        }),
        n.d(t, "ParametricBufferGeometry", function () {
          return Zc;
        }),
        n.d(t, "ParametricGeometry", function () {
          return Yc;
        }),
        n.d(t, "Particle", function () {
          return Hp;
        }),
        n.d(t, "ParticleBasicMaterial", function () {
          return Wp;
        }),
        n.d(t, "ParticleSystem", function () {
          return jp;
        }),
        n.d(t, "ParticleSystemMaterial", function () {
          return qp;
        }),
        n.d(t, "Path", function () {
          return ph;
        }),
        n.d(t, "PerspectiveCamera", function () {
          return Sa;
        }),
        n.d(t, "Plane", function () {
          return ti;
        }),
        n.d(t, "PlaneBufferGeometry", function () {
          return Na;
        }),
        n.d(t, "PlaneGeometry", function () {
          return Ia;
        }),
        n.d(t, "PlaneHelper", function () {
          return cp;
        }),
        n.d(t, "PointCloud", function () {
          return kp;
        }),
        n.d(t, "PointCloudMaterial", function () {
          return Vp;
        }),
        n.d(t, "PointLight", function () {
          return _h;
        }),
        n.d(t, "PointLightHelper", function () {
          return Vd;
        }),
        n.d(t, "Points", function () {
          return kc;
        }),
        n.d(t, "PointsMaterial", function () {
          return Bc;
        }),
        n.d(t, "PolarGridHelper", function () {
          return Jd;
        }),
        n.d(t, "PolyhedronBufferGeometry", function () {
          return Kc;
        }),
        n.d(t, "PolyhedronGeometry", function () {
          return Jc;
        }),
        n.d(t, "PositionalAudio", function () {
          return ud;
        }),
        n.d(t, "PropertyBinding", function () {
          return _d;
        }),
        n.d(t, "PropertyMixer", function () {
          return hd;
        }),
        n.d(t, "QuadraticBezierCurve", function () {
          return ch;
        }),
        n.d(t, "QuadraticBezierCurve3", function () {
          return uh;
        }),
        n.d(t, "Quaternion", function () {
          return Jn;
        }),
        n.d(t, "QuaternionKeyframeTrack", function () {
          return Cl;
        }),
        n.d(t, "QuaternionLinearInterpolant", function () {
          return Ll;
        }),
        n.d(t, "REVISION", function () {
          return i;
        }),
        n.d(t, "RGBADepthPacking", function () {
          return un;
        }),
        n.d(t, "RGBAFormat", function () {
          return ke;
        }),
        n.d(t, "RGBAIntegerFormat", function () {
          return Qe;
        }),
        n.d(t, "RGBA_ASTC_10x10_Format", function () {
          return _t;
        }),
        n.d(t, "RGBA_ASTC_10x5_Format", function () {
          return yt;
        }),
        n.d(t, "RGBA_ASTC_10x6_Format", function () {
          return xt;
        }),
        n.d(t, "RGBA_ASTC_10x8_Format", function () {
          return bt;
        }),
        n.d(t, "RGBA_ASTC_12x10_Format", function () {
          return wt;
        }),
        n.d(t, "RGBA_ASTC_12x12_Format", function () {
          return Mt;
        }),
        n.d(t, "RGBA_ASTC_4x4_Format", function () {
          return lt;
        }),
        n.d(t, "RGBA_ASTC_5x4_Format", function () {
          return ht;
        }),
        n.d(t, "RGBA_ASTC_5x5_Format", function () {
          return dt;
        }),
        n.d(t, "RGBA_ASTC_6x5_Format", function () {
          return pt;
        }),
        n.d(t, "RGBA_ASTC_6x6_Format", function () {
          return ft;
        }),
        n.d(t, "RGBA_ASTC_8x5_Format", function () {
          return mt;
        }),
        n.d(t, "RGBA_ASTC_8x6_Format", function () {
          return vt;
        }),
        n.d(t, "RGBA_ASTC_8x8_Format", function () {
          return gt;
        }),
        n.d(t, "RGBA_BPTC_Format", function () {
          return St;
        }),
        n.d(t, "RGBA_ETC2_EAC_Format", function () {
          return ut;
        }),
        n.d(t, "RGBA_PVRTC_2BPPV1_Format", function () {
          return ot;
        }),
        n.d(t, "RGBA_PVRTC_4BPPV1_Format", function () {
          return at;
        }),
        n.d(t, "RGBA_S3TC_DXT1_Format", function () {
          return et;
        }),
        n.d(t, "RGBA_S3TC_DXT3_Format", function () {
          return tt;
        }),
        n.d(t, "RGBA_S3TC_DXT5_Format", function () {
          return nt;
        }),
        n.d(t, "RGBDEncoding", function () {
          return sn;
        }),
        n.d(t, "RGBEEncoding", function () {
          return nn;
        }),
        n.d(t, "RGBEFormat", function () {
          return Ve;
        }),
        n.d(t, "RGBFormat", function () {
          return Ge;
        }),
        n.d(t, "RGBIntegerFormat", function () {
          return Ke;
        }),
        n.d(t, "RGBM16Encoding", function () {
          return on;
        }),
        n.d(t, "RGBM7Encoding", function () {
          return an;
        }),
        n.d(t, "RGB_ETC1_Format", function () {
          return st;
        }),
        n.d(t, "RGB_ETC2_Format", function () {
          return ct;
        }),
        n.d(t, "RGB_PVRTC_2BPPV1_Format", function () {
          return it;
        }),
        n.d(t, "RGB_PVRTC_4BPPV1_Format", function () {
          return rt;
        }),
        n.d(t, "RGB_S3TC_DXT1_Format", function () {
          return $e;
        }),
        n.d(t, "RGFormat", function () {
          return Ze;
        }),
        n.d(t, "RGIntegerFormat", function () {
          return Je;
        }),
        n.d(t, "RawShaderMaterial", function () {
          return ul;
        }),
        n.d(t, "Ray", function () {
          return Kr;
        }),
        n.d(t, "Raycaster", function () {
          return Ad;
        }),
        n.d(t, "RectAreaLight", function () {
          return Eh;
        }),
        n.d(t, "RedFormat", function () {
          return Xe;
        }),
        n.d(t, "RedIntegerFormat", function () {
          return Ye;
        }),
        n.d(t, "ReinhardToneMapping", function () {
          return re;
        }),
        n.d(t, "RepeatWrapping", function () {
          return fe;
        }),
        n.d(t, "ReplaceStencilOp", function () {
          return fn;
        }),
        n.d(t, "ReverseSubtractEquation", function () {
          return R;
        }),
        n.d(t, "RingBufferGeometry", function () {
          return Yu;
        }),
        n.d(t, "RingGeometry", function () {
          return Xu;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_10x10_Format", function () {
          return Bt;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_10x5_Format", function () {
          return Dt;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_10x6_Format", function () {
          return It;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_10x8_Format", function () {
          return Nt;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_12x10_Format", function () {
          return zt;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_12x12_Format", function () {
          return Ft;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_4x4_Format", function () {
          return Tt;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_5x4_Format", function () {
          return Et;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_5x5_Format", function () {
          return At;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_6x5_Format", function () {
          return Lt;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_6x6_Format", function () {
          return Ct;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_8x5_Format", function () {
          return Rt;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_8x6_Format", function () {
          return Pt;
        }),
        n.d(t, "SRGB8_ALPHA8_ASTC_8x8_Format", function () {
          return Ot;
        }),
        n.d(t, "Scene", function () {
          return Er;
        }),
        n.d(t, "SceneUtils", function () {
          return yf;
        }),
        n.d(t, "ShaderChunk", function () {
          return Ba;
        }),
        n.d(t, "ShaderLib", function () {
          return za;
        }),
        n.d(t, "ShaderMaterial", function () {
          return wa;
        }),
        n.d(t, "ShadowMaterial", function () {
          return cl;
        }),
        n.d(t, "Shape", function () {
          return fh;
        }),
        n.d(t, "ShapeBufferGeometry", function () {
          return Qu;
        }),
        n.d(t, "ShapeGeometry", function () {
          return Ku;
        }),
        n.d(t, "ShapePath", function () {
          return kh;
        }),
        n.d(t, "ShapeUtils", function () {
          return Bu;
        }),
        n.d(t, "ShortType", function () {
          return Ce;
        }),
        n.d(t, "Skeleton", function () {
          return yc;
        }),
        n.d(t, "SkeletonHelper", function () {
          return jd;
        }),
        n.d(t, "SkinnedMesh", function () {
          return mc;
        }),
        n.d(t, "SmoothShading", function () {
          return _;
        }),
        n.d(t, "Sphere", function () {
          return jr;
        }),
        n.d(t, "SphereBufferGeometry", function () {
          return qu;
        }),
        n.d(t, "SphereGeometry", function () {
          return Wu;
        }),
        n.d(t, "Spherical", function () {
          return Rd;
        }),
        n.d(t, "SphericalHarmonics3", function () {
          return Ah;
        }),
        n.d(t, "Spline", function () {
          return sf;
        }),
        n.d(t, "SplineCurve", function () {
          return lh;
        }),
        n.d(t, "SplineCurve3", function () {
          return of;
        }),
        n.d(t, "SpotLight", function () {
          return xh;
        }),
        n.d(t, "SpotLightHelper", function () {
          return Ud;
        }),
        n.d(t, "SpotLightShadow", function () {
          return yh;
        }),
        n.d(t, "Sprite", function () {
          return ac;
        }),
        n.d(t, "SpriteMaterial", function () {
          return qs;
        }),
        n.d(t, "SrcAlphaFactor", function () {
          return z;
        }),
        n.d(t, "SrcAlphaSaturateFactor", function () {
          return j;
        }),
        n.d(t, "SrcColorFactor", function () {
          return N;
        }),
        n.d(t, "StaticCopyUsage", function () {
          return In;
        }),
        n.d(t, "StaticDrawUsage", function () {
          return Ln;
        }),
        n.d(t, "StaticReadUsage", function () {
          return Pn;
        }),
        n.d(t, "StereoCamera", function () {
          return Kh;
        }),
        n.d(t, "StreamCopyUsage", function () {
          return Bn;
        }),
        n.d(t, "StreamDrawUsage", function () {
          return Rn;
        }),
        n.d(t, "StreamReadUsage", function () {
          return Dn;
        }),
        n.d(t, "StringKeyframeTrack", function () {
          return Rl;
        }),
        n.d(t, "SubtractEquation", function () {
          return C;
        }),
        n.d(t, "SubtractiveBlending", function () {
          return T;
        }),
        n.d(t, "TOUCH", function () {
          return o;
        }),
        n.d(t, "TangentSpaceNormalMap", function () {
          return ln;
        }),
        n.d(t, "TetrahedronBufferGeometry", function () {
          return $c;
        }),
        n.d(t, "TetrahedronGeometry", function () {
          return Qc;
        }),
        n.d(t, "TextBufferGeometry", function () {
          return Vu;
        }),
        n.d(t, "TextGeometry", function () {
          return ju;
        }),
        n.d(t, "Texture", function () {
          return qn;
        }),
        n.d(t, "TextureLoader", function () {
          return Wl;
        }),
        n.d(t, "TorusBufferGeometry", function () {
          return hu;
        }),
        n.d(t, "TorusGeometry", function () {
          return lu;
        }),
        n.d(t, "TorusKnotBufferGeometry", function () {
          return uu;
        }),
        n.d(t, "TorusKnotGeometry", function () {
          return cu;
        }),
        n.d(t, "Triangle", function () {
          return di;
        }),
        n.d(t, "TriangleFanDrawMode", function () {
          return Qt;
        }),
        n.d(t, "TriangleStripDrawMode", function () {
          return Kt;
        }),
        n.d(t, "TrianglesDrawMode", function () {
          return Jt;
        }),
        n.d(t, "TubeBufferGeometry", function () {
          return su;
        }),
        n.d(t, "TubeGeometry", function () {
          return ou;
        }),
        n.d(t, "UVMapping", function () {
          return se;
        }),
        n.d(t, "Uint16Attribute", function () {
          return $p;
        }),
        n.d(t, "Uint16BufferAttribute", function () {
          return Pi;
        }),
        n.d(t, "Uint32Attribute", function () {
          return tf;
        }),
        n.d(t, "Uint32BufferAttribute", function () {
          return Di;
        }),
        n.d(t, "Uint8Attribute", function () {
          return Jp;
        }),
        n.d(t, "Uint8BufferAttribute", function () {
          return Li;
        }),
        n.d(t, "Uint8ClampedAttribute", function () {
          return Kp;
        }),
        n.d(t, "Uint8ClampedBufferAttribute", function () {
          return Ci;
        }),
        n.d(t, "Uniform", function () {
          return Td;
        }),
        n.d(t, "UniformsLib", function () {
          return Pa;
        }),
        n.d(t, "UniformsUtils", function () {
          return _a;
        }),
        n.d(t, "UnsignedByteType", function () {
          return Ae;
        }),
        n.d(t, "UnsignedInt248Type", function () {
          return Fe;
        }),
        n.d(t, "UnsignedIntType", function () {
          return Oe;
        }),
        n.d(t, "UnsignedShort4444Type", function () {
          return Ne;
        }),
        n.d(t, "UnsignedShort5551Type", function () {
          return Be;
        }),
        n.d(t, "UnsignedShort565Type", function () {
          return ze;
        }),
        n.d(t, "UnsignedShortType", function () {
          return Re;
        }),
        n.d(t, "VSMShadowMap", function () {
          return v;
        }),
        n.d(t, "Vector2", function () {
          return Hn;
        }),
        n.d(t, "Vector3", function () {
          return $n;
        }),
        n.d(t, "Vector4", function () {
          return Xn;
        }),
        n.d(t, "VectorKeyframeTrack", function () {
          return Pl;
        }),
        n.d(t, "Vertex", function () {
          return Xp;
        }),
        n.d(t, "VertexColors", function () {
          return Fp;
        }),
        n.d(t, "VideoTexture", function () {
          return jc;
        }),
        n.d(t, "WebGL1Renderer", function () {
          return Us;
        }),
        n.d(t, "WebGLCubeRenderTarget", function () {
          return Ea;
        }),
        n.d(t, "WebGLMultisampleRenderTarget", function () {
          return Zn;
        }),
        n.d(t, "WebGLRenderTarget", function () {
          return Yn;
        }),
        n.d(t, "WebGLRenderTargetCube", function () {
          return ff;
        }),
        n.d(t, "WebGLRenderer", function () {
          return Fs;
        }),
        n.d(t, "WebGLUtils", function () {
          return Os;
        }),
        n.d(t, "WireframeGeometry", function () {
          return Xc;
        }),
        n.d(t, "WireframeHelper", function () {
          return hf;
        }),
        n.d(t, "WrapAroundEnding", function () {
          return Xt;
        }),
        n.d(t, "XHRLoader", function () {
          return df;
        }),
        n.d(t, "ZeroCurvatureEnding", function () {
          return Wt;
        }),
        n.d(t, "ZeroFactor", function () {
          return D;
        }),
        n.d(t, "ZeroSlopeEnding", function () {
          return qt;
        }),
        n.d(t, "ZeroStencilOp", function () {
          return dn;
        }),
        n.d(t, "sRGBEncoding", function () {
          return en;
        }),
        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
        void 0 === Number.isInteger &&
          (Number.isInteger = function (e) {
            return "number" == typeof e && isFinite(e) && Math.floor(e) === e;
          }),
        void 0 === Math.sign &&
          (Math.sign = function (e) {
            return e < 0 ? -1 : e > 0 ? 1 : +e;
          }),
        "name" in Function.prototype == 0 &&
          Object.defineProperty(Function.prototype, "name", {
            get: function () {
              return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
            },
          }),
        void 0 === Object.assign &&
          (Object.assign = function (e) {
            if (null == e)
              throw new TypeError("Cannot convert undefined or null to object");
            for (var t = Object(e), n = 1; n < arguments.length; n++) {
              var r = arguments[n];
              if (null != r)
                for (var i in r)
                  Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
            }
            return t;
          });
      var i = "118",
        a = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
        o = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
        s = 0,
        c = 1,
        u = 2,
        l = 3,
        h = 0,
        d = 1,
        p = 0,
        f = 1,
        m = 2,
        v = 3,
        g = 0,
        y = 1,
        x = 2,
        b = 1,
        _ = 2,
        w = 0,
        M = 1,
        S = 2,
        T = 3,
        E = 4,
        A = 5,
        L = 100,
        C = 101,
        R = 102,
        P = 103,
        O = 104,
        D = 200,
        I = 201,
        N = 202,
        B = 203,
        z = 204,
        F = 205,
        U = 206,
        G = 207,
        k = 208,
        H = 209,
        j = 210,
        V = 0,
        W = 1,
        q = 2,
        X = 3,
        Y = 4,
        Z = 5,
        J = 6,
        K = 7,
        Q = 0,
        $ = 1,
        ee = 2,
        te = 0,
        ne = 1,
        re = 2,
        ie = 3,
        ae = 4,
        oe = 5,
        se = 300,
        ce = 301,
        ue = 302,
        le = 303,
        he = 304,
        de = 306,
        pe = 307,
        fe = 1e3,
        me = 1001,
        ve = 1002,
        ge = 1003,
        ye = 1004,
        xe = 1004,
        be = 1005,
        _e = 1005,
        we = 1006,
        Me = 1007,
        Se = 1007,
        Te = 1008,
        Ee = 1008,
        Ae = 1009,
        Le = 1010,
        Ce = 1011,
        Re = 1012,
        Pe = 1013,
        Oe = 1014,
        De = 1015,
        Ie = 1016,
        Ne = 1017,
        Be = 1018,
        ze = 1019,
        Fe = 1020,
        Ue = 1021,
        Ge = 1022,
        ke = 1023,
        He = 1024,
        je = 1025,
        Ve = ke,
        We = 1026,
        qe = 1027,
        Xe = 1028,
        Ye = 1029,
        Ze = 1030,
        Je = 1031,
        Ke = 1032,
        Qe = 1033,
        $e = 33776,
        et = 33777,
        tt = 33778,
        nt = 33779,
        rt = 35840,
        it = 35841,
        at = 35842,
        ot = 35843,
        st = 36196,
        ct = 37492,
        ut = 37496,
        lt = 37808,
        ht = 37809,
        dt = 37810,
        pt = 37811,
        ft = 37812,
        mt = 37813,
        vt = 37814,
        gt = 37815,
        yt = 37816,
        xt = 37817,
        bt = 37818,
        _t = 37819,
        wt = 37820,
        Mt = 37821,
        St = 36492,
        Tt = 37840,
        Et = 37841,
        At = 37842,
        Lt = 37843,
        Ct = 37844,
        Rt = 37845,
        Pt = 37846,
        Ot = 37847,
        Dt = 37848,
        It = 37849,
        Nt = 37850,
        Bt = 37851,
        zt = 37852,
        Ft = 37853,
        Ut = 2200,
        Gt = 2201,
        kt = 2202,
        Ht = 2300,
        jt = 2301,
        Vt = 2302,
        Wt = 2400,
        qt = 2401,
        Xt = 2402,
        Yt = 2500,
        Zt = 2501,
        Jt = 0,
        Kt = 1,
        Qt = 2,
        $t = 3e3,
        en = 3001,
        tn = 3007,
        nn = 3002,
        rn = 3003,
        an = 3004,
        on = 3005,
        sn = 3006,
        cn = 3200,
        un = 3201,
        ln = 0,
        hn = 1,
        dn = 0,
        pn = 7680,
        fn = 7681,
        mn = 7682,
        vn = 7683,
        gn = 34055,
        yn = 34056,
        xn = 5386,
        bn = 512,
        _n = 513,
        wn = 514,
        Mn = 515,
        Sn = 516,
        Tn = 517,
        En = 518,
        An = 519,
        Ln = 35044,
        Cn = 35048,
        Rn = 35040,
        Pn = 35045,
        On = 35049,
        Dn = 35041,
        In = 35046,
        Nn = 35050,
        Bn = 35042;
      function zn() {}
      Object.assign(zn.prototype, {
        addEventListener: function (e, t) {
          void 0 === this._listeners && (this._listeners = {});
          var n = this._listeners;
          void 0 === n[e] && (n[e] = []),
            -1 === n[e].indexOf(t) && n[e].push(t);
        },
        hasEventListener: function (e, t) {
          if (void 0 === this._listeners) return !1;
          var n = this._listeners;
          return void 0 !== n[e] && -1 !== n[e].indexOf(t);
        },
        removeEventListener: function (e, t) {
          if (void 0 !== this._listeners) {
            var n = this._listeners[e];
            if (void 0 !== n) {
              var r = n.indexOf(t);
              -1 !== r && n.splice(r, 1);
            }
          }
        },
        dispatchEvent: function (e) {
          if (void 0 !== this._listeners) {
            var t = this._listeners[e.type];
            if (void 0 !== t) {
              e.target = this;
              for (var n = t.slice(0), r = 0, i = n.length; r < i; r++)
                n[r].call(this, e);
            }
          }
        },
      });
      for (var Fn = [], Un = 0; Un < 256; Un++)
        Fn[Un] = (Un < 16 ? "0" : "") + Un.toString(16);
      var Gn,
        kn = {
          DEG2RAD: Math.PI / 180,
          RAD2DEG: 180 / Math.PI,
          generateUUID: function () {
            var e = (4294967295 * Math.random()) | 0,
              t = (4294967295 * Math.random()) | 0,
              n = (4294967295 * Math.random()) | 0,
              r = (4294967295 * Math.random()) | 0;
            return (
              Fn[255 & e] +
              Fn[(e >> 8) & 255] +
              Fn[(e >> 16) & 255] +
              Fn[(e >> 24) & 255] +
              "-" +
              Fn[255 & t] +
              Fn[(t >> 8) & 255] +
              "-" +
              Fn[((t >> 16) & 15) | 64] +
              Fn[(t >> 24) & 255] +
              "-" +
              Fn[(63 & n) | 128] +
              Fn[(n >> 8) & 255] +
              "-" +
              Fn[(n >> 16) & 255] +
              Fn[(n >> 24) & 255] +
              Fn[255 & r] +
              Fn[(r >> 8) & 255] +
              Fn[(r >> 16) & 255] +
              Fn[(r >> 24) & 255]
            ).toUpperCase();
          },
          clamp: function (e, t, n) {
            return Math.max(t, Math.min(n, e));
          },
          euclideanModulo: function (e, t) {
            return ((e % t) + t) % t;
          },
          mapLinear: function (e, t, n, r, i) {
            return r + ((e - t) * (i - r)) / (n - t);
          },
          lerp: function (e, t, n) {
            return (1 - n) * e + n * t;
          },
          smoothstep: function (e, t, n) {
            return e <= t
              ? 0
              : e >= n
              ? 1
              : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
          },
          smootherstep: function (e, t, n) {
            return e <= t
              ? 0
              : e >= n
              ? 1
              : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
          },
          randInt: function (e, t) {
            return e + Math.floor(Math.random() * (t - e + 1));
          },
          randFloat: function (e, t) {
            return e + Math.random() * (t - e);
          },
          randFloatSpread: function (e) {
            return e * (0.5 - Math.random());
          },
          degToRad: function (e) {
            return e * kn.DEG2RAD;
          },
          radToDeg: function (e) {
            return e * kn.RAD2DEG;
          },
          isPowerOfTwo: function (e) {
            return 0 == (e & (e - 1)) && 0 !== e;
          },
          ceilPowerOfTwo: function (e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
          },
          floorPowerOfTwo: function (e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
          },
          setQuaternionFromProperEuler: function (e, t, n, r, i) {
            var a = Math.cos,
              o = Math.sin,
              s = a(n / 2),
              c = o(n / 2),
              u = a((t + r) / 2),
              l = o((t + r) / 2),
              h = a((t - r) / 2),
              d = o((t - r) / 2),
              p = a((r - t) / 2),
              f = o((r - t) / 2);
            switch (i) {
              case "XYX":
                e.set(s * l, c * h, c * d, s * u);
                break;
              case "YZY":
                e.set(c * d, s * l, c * h, s * u);
                break;
              case "ZXZ":
                e.set(c * h, c * d, s * l, s * u);
                break;
              case "XZX":
                e.set(s * l, c * f, c * p, s * u);
                break;
              case "YXY":
                e.set(c * p, s * l, c * f, s * u);
                break;
              case "ZYZ":
                e.set(c * f, c * p, s * l, s * u);
                break;
              default:
                console.warn(
                  "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                    i
                );
            }
          },
        };
      function Hn() {
        var e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
          t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        (this.x = e), (this.y = t);
      }
      function jn() {
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
            );
      }
      Object.defineProperties(Hn.prototype, {
        width: {
          get: function () {
            return this.x;
          },
          set: function (e) {
            this.x = e;
          },
        },
        height: {
          get: function () {
            return this.y;
          },
          set: function (e) {
            this.y = e;
          },
        },
      }),
        Object.assign(Hn.prototype, {
          isVector2: !0,
          set: function (e, t) {
            return (this.x = e), (this.y = t), this;
          },
          setScalar: function (e) {
            return (this.x = e), (this.y = e), this;
          },
          setX: function (e) {
            return (this.x = e), this;
          },
          setY: function (e) {
            return (this.y = e), this;
          },
          setComponent: function (e, t) {
            switch (e) {
              case 0:
                this.x = t;
                break;
              case 1:
                this.y = t;
                break;
              default:
                throw new Error("index is out of range: " + e);
            }
            return this;
          },
          getComponent: function (e) {
            switch (e) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw new Error("index is out of range: " + e);
            }
          },
          clone: function () {
            return new this.constructor(this.x, this.y);
          },
          copy: function (e) {
            return (this.x = e.x), (this.y = e.y), this;
          },
          add: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(e, t))
              : ((this.x += e.x), (this.y += e.y), this);
          },
          addScalar: function (e) {
            return (this.x += e), (this.y += e), this;
          },
          addVectors: function (e, t) {
            return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
          },
          addScaledVector: function (e, t) {
            return (this.x += e.x * t), (this.y += e.y * t), this;
          },
          sub: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(e, t))
              : ((this.x -= e.x), (this.y -= e.y), this);
          },
          subScalar: function (e) {
            return (this.x -= e), (this.y -= e), this;
          },
          subVectors: function (e, t) {
            return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
          },
          multiply: function (e) {
            return (this.x *= e.x), (this.y *= e.y), this;
          },
          multiplyScalar: function (e) {
            return (this.x *= e), (this.y *= e), this;
          },
          divide: function (e) {
            return (this.x /= e.x), (this.y /= e.y), this;
          },
          divideScalar: function (e) {
            return this.multiplyScalar(1 / e);
          },
          applyMatrix3: function (e) {
            var t = this.x,
              n = this.y,
              r = e.elements;
            return (
              (this.x = r[0] * t + r[3] * n + r[6]),
              (this.y = r[1] * t + r[4] * n + r[7]),
              this
            );
          },
          min: function (e) {
            return (
              (this.x = Math.min(this.x, e.x)),
              (this.y = Math.min(this.y, e.y)),
              this
            );
          },
          max: function (e) {
            return (
              (this.x = Math.max(this.x, e.x)),
              (this.y = Math.max(this.y, e.y)),
              this
            );
          },
          clamp: function (e, t) {
            return (
              (this.x = Math.max(e.x, Math.min(t.x, this.x))),
              (this.y = Math.max(e.y, Math.min(t.y, this.y))),
              this
            );
          },
          clampScalar: function (e, t) {
            return (
              (this.x = Math.max(e, Math.min(t, this.x))),
              (this.y = Math.max(e, Math.min(t, this.y))),
              this
            );
          },
          clampLength: function (e, t) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(e, Math.min(t, n))
            );
          },
          floor: function () {
            return (
              (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
            );
          },
          ceil: function () {
            return (
              (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
            );
          },
          round: function () {
            return (
              (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
            );
          },
          roundToZero: function () {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              this
            );
          },
          negate: function () {
            return (this.x = -this.x), (this.y = -this.y), this;
          },
          dot: function (e) {
            return this.x * e.x + this.y * e.y;
          },
          cross: function (e) {
            return this.x * e.y - this.y * e.x;
          },
          lengthSq: function () {
            return this.x * this.x + this.y * this.y;
          },
          length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          },
          manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y);
          },
          normalize: function () {
            return this.divideScalar(this.length() || 1);
          },
          angle: function () {
            return Math.atan2(-this.y, -this.x) + Math.PI;
          },
          distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e));
          },
          distanceToSquared: function (e) {
            var t = this.x - e.x,
              n = this.y - e.y;
            return t * t + n * n;
          },
          manhattanDistanceTo: function (e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
          },
          setLength: function (e) {
            return this.normalize().multiplyScalar(e);
          },
          lerp: function (e, t) {
            return (
              (this.x += (e.x - this.x) * t),
              (this.y += (e.y - this.y) * t),
              this
            );
          },
          lerpVectors: function (e, t, n) {
            return (
              (this.x = e.x + (t.x - e.x) * n),
              (this.y = e.y + (t.y - e.y) * n),
              this
            );
          },
          equals: function (e) {
            return e.x === this.x && e.y === this.y;
          },
          fromArray: function (e, t) {
            return (
              void 0 === t && (t = 0),
              (this.x = e[t]),
              (this.y = e[t + 1]),
              this
            );
          },
          toArray: function (e, t) {
            return (
              void 0 === e && (e = []),
              void 0 === t && (t = 0),
              (e[t] = this.x),
              (e[t + 1] = this.y),
              e
            );
          },
          fromBufferAttribute: function (e, t, n) {
            return (
              void 0 !== n &&
                console.warn(
                  "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
                ),
              (this.x = e.getX(t)),
              (this.y = e.getY(t)),
              this
            );
          },
          rotateAround: function (e, t) {
            var n = Math.cos(t),
              r = Math.sin(t),
              i = this.x - e.x,
              a = this.y - e.y;
            return (
              (this.x = i * n - a * r + e.x),
              (this.y = i * r + a * n + e.y),
              this
            );
          },
          random: function () {
            return (this.x = Math.random()), (this.y = Math.random()), this;
          },
        }),
        Object.assign(jn.prototype, {
          isMatrix3: !0,
          set: function (e, t, n, r, i, a, o, s, c) {
            var u = this.elements;
            return (
              (u[0] = e),
              (u[1] = r),
              (u[2] = o),
              (u[3] = t),
              (u[4] = i),
              (u[5] = s),
              (u[6] = n),
              (u[7] = a),
              (u[8] = c),
              this
            );
          },
          identity: function () {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          },
          clone: function () {
            return new this.constructor().fromArray(this.elements);
          },
          copy: function (e) {
            var t = this.elements,
              n = e.elements;
            return (
              (t[0] = n[0]),
              (t[1] = n[1]),
              (t[2] = n[2]),
              (t[3] = n[3]),
              (t[4] = n[4]),
              (t[5] = n[5]),
              (t[6] = n[6]),
              (t[7] = n[7]),
              (t[8] = n[8]),
              this
            );
          },
          extractBasis: function (e, t, n) {
            return (
              e.setFromMatrix3Column(this, 0),
              t.setFromMatrix3Column(this, 1),
              n.setFromMatrix3Column(this, 2),
              this
            );
          },
          setFromMatrix4: function (e) {
            var t = e.elements;
            return (
              this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
              this
            );
          },
          multiply: function (e) {
            return this.multiplyMatrices(this, e);
          },
          premultiply: function (e) {
            return this.multiplyMatrices(e, this);
          },
          multiplyMatrices: function (e, t) {
            var n = e.elements,
              r = t.elements,
              i = this.elements,
              a = n[0],
              o = n[3],
              s = n[6],
              c = n[1],
              u = n[4],
              l = n[7],
              h = n[2],
              d = n[5],
              p = n[8],
              f = r[0],
              m = r[3],
              v = r[6],
              g = r[1],
              y = r[4],
              x = r[7],
              b = r[2],
              _ = r[5],
              w = r[8];
            return (
              (i[0] = a * f + o * g + s * b),
              (i[3] = a * m + o * y + s * _),
              (i[6] = a * v + o * x + s * w),
              (i[1] = c * f + u * g + l * b),
              (i[4] = c * m + u * y + l * _),
              (i[7] = c * v + u * x + l * w),
              (i[2] = h * f + d * g + p * b),
              (i[5] = h * m + d * y + p * _),
              (i[8] = h * v + d * x + p * w),
              this
            );
          },
          multiplyScalar: function (e) {
            var t = this.elements;
            return (
              (t[0] *= e),
              (t[3] *= e),
              (t[6] *= e),
              (t[1] *= e),
              (t[4] *= e),
              (t[7] *= e),
              (t[2] *= e),
              (t[5] *= e),
              (t[8] *= e),
              this
            );
          },
          determinant: function () {
            var e = this.elements,
              t = e[0],
              n = e[1],
              r = e[2],
              i = e[3],
              a = e[4],
              o = e[5],
              s = e[6],
              c = e[7],
              u = e[8];
            return (
              t * a * u -
              t * o * c -
              n * i * u +
              n * o * s +
              r * i * c -
              r * a * s
            );
          },
          getInverse: function (e, t) {
            void 0 !== t &&
              console.warn(
                "THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate."
              );
            var n = e.elements,
              r = this.elements,
              i = n[0],
              a = n[1],
              o = n[2],
              s = n[3],
              c = n[4],
              u = n[5],
              l = n[6],
              h = n[7],
              d = n[8],
              p = d * c - u * h,
              f = u * l - d * s,
              m = h * s - c * l,
              v = i * p + a * f + o * m;
            if (0 === v) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            var g = 1 / v;
            return (
              (r[0] = p * g),
              (r[1] = (o * h - d * a) * g),
              (r[2] = (u * a - o * c) * g),
              (r[3] = f * g),
              (r[4] = (d * i - o * l) * g),
              (r[5] = (o * s - u * i) * g),
              (r[6] = m * g),
              (r[7] = (a * l - h * i) * g),
              (r[8] = (c * i - a * s) * g),
              this
            );
          },
          transpose: function () {
            var e,
              t = this.elements;
            return (
              (e = t[1]),
              (t[1] = t[3]),
              (t[3] = e),
              (e = t[2]),
              (t[2] = t[6]),
              (t[6] = e),
              (e = t[5]),
              (t[5] = t[7]),
              (t[7] = e),
              this
            );
          },
          getNormalMatrix: function (e) {
            return this.setFromMatrix4(e).getInverse(this).transpose();
          },
          transposeIntoArray: function (e) {
            var t = this.elements;
            return (
              (e[0] = t[0]),
              (e[1] = t[3]),
              (e[2] = t[6]),
              (e[3] = t[1]),
              (e[4] = t[4]),
              (e[5] = t[7]),
              (e[6] = t[2]),
              (e[7] = t[5]),
              (e[8] = t[8]),
              this
            );
          },
          setUvTransform: function (e, t, n, r, i, a, o) {
            var s = Math.cos(i),
              c = Math.sin(i);
            this.set(
              n * s,
              n * c,
              -n * (s * a + c * o) + a + e,
              -r * c,
              r * s,
              -r * (-c * a + s * o) + o + t,
              0,
              0,
              1
            );
          },
          scale: function (e, t) {
            var n = this.elements;
            return (
              (n[0] *= e),
              (n[3] *= e),
              (n[6] *= e),
              (n[1] *= t),
              (n[4] *= t),
              (n[7] *= t),
              this
            );
          },
          rotate: function (e) {
            var t = Math.cos(e),
              n = Math.sin(e),
              r = this.elements,
              i = r[0],
              a = r[3],
              o = r[6],
              s = r[1],
              c = r[4],
              u = r[7];
            return (
              (r[0] = t * i + n * s),
              (r[3] = t * a + n * c),
              (r[6] = t * o + n * u),
              (r[1] = -n * i + t * s),
              (r[4] = -n * a + t * c),
              (r[7] = -n * o + t * u),
              this
            );
          },
          translate: function (e, t) {
            var n = this.elements;
            return (
              (n[0] += e * n[2]),
              (n[3] += e * n[5]),
              (n[6] += e * n[8]),
              (n[1] += t * n[2]),
              (n[4] += t * n[5]),
              (n[7] += t * n[8]),
              this
            );
          },
          equals: function (e) {
            for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
              if (t[r] !== n[r]) return !1;
            return !0;
          },
          fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
            return this;
          },
          toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var n = this.elements;
            return (
              (e[t] = n[0]),
              (e[t + 1] = n[1]),
              (e[t + 2] = n[2]),
              (e[t + 3] = n[3]),
              (e[t + 4] = n[4]),
              (e[t + 5] = n[5]),
              (e[t + 6] = n[6]),
              (e[t + 7] = n[7]),
              (e[t + 8] = n[8]),
              e
            );
          },
        });
      var Vn = {
          getDataURL: function (e) {
            if (/^data:/i.test(e.src)) return e.src;
            if ("undefined" == typeof HTMLCanvasElement) return e.src;
            var t;
            if (e instanceof HTMLCanvasElement) t = e;
            else {
              void 0 === Gn &&
                (Gn = document.createElementNS(
                  "http://www.w3.org/1999/xhtml",
                  "canvas"
                )),
                (Gn.width = e.width),
                (Gn.height = e.height);
              var n = Gn.getContext("2d");
              e instanceof ImageData
                ? n.putImageData(e, 0, 0)
                : n.drawImage(e, 0, 0, e.width, e.height),
                (t = Gn);
            }
            return t.width > 2048 || t.height > 2048
              ? t.toDataURL("image/jpeg", 0.6)
              : t.toDataURL("image/png");
          },
        },
        Wn = 0;
      function qn(e, t, n, r, i, a, o, s, c, u) {
        Object.defineProperty(this, "id", { value: Wn++ }),
          (this.uuid = kn.generateUUID()),
          (this.name = ""),
          (this.image = void 0 !== e ? e : qn.DEFAULT_IMAGE),
          (this.mipmaps = []),
          (this.mapping = void 0 !== t ? t : qn.DEFAULT_MAPPING),
          (this.wrapS = void 0 !== n ? n : me),
          (this.wrapT = void 0 !== r ? r : me),
          (this.magFilter = void 0 !== i ? i : we),
          (this.minFilter = void 0 !== a ? a : Te),
          (this.anisotropy = void 0 !== c ? c : 1),
          (this.format = void 0 !== o ? o : ke),
          (this.internalFormat = null),
          (this.type = void 0 !== s ? s : Ae),
          (this.offset = new Hn(0, 0)),
          (this.repeat = new Hn(1, 1)),
          (this.center = new Hn(0, 0)),
          (this.rotation = 0),
          (this.matrixAutoUpdate = !0),
          (this.matrix = new jn()),
          (this.generateMipmaps = !0),
          (this.premultiplyAlpha = !1),
          (this.flipY = !0),
          (this.unpackAlignment = 4),
          (this.encoding = void 0 !== u ? u : $t),
          (this.version = 0),
          (this.onUpdate = null);
      }
      function Xn() {
        var e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
          t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
          n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
          r =
            arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        (this.x = e), (this.y = t), (this.z = n), (this.w = r);
      }
      function Yn(e, t, n) {
        (this.width = e),
          (this.height = t),
          (this.scissor = new Xn(0, 0, e, t)),
          (this.scissorTest = !1),
          (this.viewport = new Xn(0, 0, e, t)),
          (this.texture = new qn(
            void 0,
            (n = n || {}).mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.encoding
          )),
          (this.texture.image = {}),
          (this.texture.image.width = e),
          (this.texture.image.height = t),
          (this.texture.generateMipmaps =
            void 0 !== n.generateMipmaps && n.generateMipmaps),
          (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : we),
          (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
          (this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer),
          (this.depthTexture =
            void 0 !== n.depthTexture ? n.depthTexture : null);
      }
      function Zn(e, t, n) {
        Yn.call(this, e, t, n), (this.samples = 4);
      }
      function Jn() {
        var e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
          t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
          n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
          r =
            arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        (this._x = e), (this._y = t), (this._z = n), (this._w = r);
      }
      (qn.DEFAULT_IMAGE = void 0),
        (qn.DEFAULT_MAPPING = se),
        (qn.prototype = Object.assign(Object.create(zn.prototype), {
          constructor: qn,
          isTexture: !0,
          updateMatrix: function () {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (
              (this.name = e.name),
              (this.image = e.image),
              (this.mipmaps = e.mipmaps.slice(0)),
              (this.mapping = e.mapping),
              (this.wrapS = e.wrapS),
              (this.wrapT = e.wrapT),
              (this.magFilter = e.magFilter),
              (this.minFilter = e.minFilter),
              (this.anisotropy = e.anisotropy),
              (this.format = e.format),
              (this.internalFormat = e.internalFormat),
              (this.type = e.type),
              this.offset.copy(e.offset),
              this.repeat.copy(e.repeat),
              this.center.copy(e.center),
              (this.rotation = e.rotation),
              (this.matrixAutoUpdate = e.matrixAutoUpdate),
              this.matrix.copy(e.matrix),
              (this.generateMipmaps = e.generateMipmaps),
              (this.premultiplyAlpha = e.premultiplyAlpha),
              (this.flipY = e.flipY),
              (this.unpackAlignment = e.unpackAlignment),
              (this.encoding = e.encoding),
              this
            );
          },
          toJSON: function (e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid])
              return e.textures[this.uuid];
            var n = {
              metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON",
              },
              uuid: this.uuid,
              name: this.name,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            if (void 0 !== this.image) {
              var r = this.image;
              if (
                (void 0 === r.uuid && (r.uuid = kn.generateUUID()),
                !t && void 0 === e.images[r.uuid])
              ) {
                var i;
                if (Array.isArray(r)) {
                  i = [];
                  for (var a = 0, o = r.length; a < o; a++)
                    i.push(Vn.getDataURL(r[a]));
                } else i = Vn.getDataURL(r);
                e.images[r.uuid] = { uuid: r.uuid, url: i };
              }
              n.image = r.uuid;
            }
            return t || (e.textures[this.uuid] = n), n;
          },
          dispose: function () {
            this.dispatchEvent({ type: "dispose" });
          },
          transformUv: function (e) {
            if (this.mapping !== se) return e;
            if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
              switch (this.wrapS) {
                case fe:
                  e.x = e.x - Math.floor(e.x);
                  break;
                case me:
                  e.x = e.x < 0 ? 0 : 1;
                  break;
                case ve:
                  e.x =
                    1 === Math.abs(Math.floor(e.x) % 2)
                      ? Math.ceil(e.x) - e.x
                      : e.x - Math.floor(e.x);
              }
            if (e.y < 0 || e.y > 1)
              switch (this.wrapT) {
                case fe:
                  e.y = e.y - Math.floor(e.y);
                  break;
                case me:
                  e.y = e.y < 0 ? 0 : 1;
                  break;
                case ve:
                  e.y =
                    1 === Math.abs(Math.floor(e.y) % 2)
                      ? Math.ceil(e.y) - e.y
                      : e.y - Math.floor(e.y);
              }
            return this.flipY && (e.y = 1 - e.y), e;
          },
        })),
        Object.defineProperty(qn.prototype, "needsUpdate", {
          set: function (e) {
            !0 === e && this.version++;
          },
        }),
        Object.defineProperties(Xn.prototype, {
          width: {
            get: function () {
              return this.z;
            },
            set: function (e) {
              this.z = e;
            },
          },
          height: {
            get: function () {
              return this.w;
            },
            set: function (e) {
              this.w = e;
            },
          },
        }),
        Object.assign(Xn.prototype, {
          isVector4: !0,
          set: function (e, t, n, r) {
            return (this.x = e), (this.y = t), (this.z = n), (this.w = r), this;
          },
          setScalar: function (e) {
            return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
          },
          setX: function (e) {
            return (this.x = e), this;
          },
          setY: function (e) {
            return (this.y = e), this;
          },
          setZ: function (e) {
            return (this.z = e), this;
          },
          setW: function (e) {
            return (this.w = e), this;
          },
          setComponent: function (e, t) {
            switch (e) {
              case 0:
                this.x = t;
                break;
              case 1:
                this.y = t;
                break;
              case 2:
                this.z = t;
                break;
              case 3:
                this.w = t;
                break;
              default:
                throw new Error("index is out of range: " + e);
            }
            return this;
          },
          getComponent: function (e) {
            switch (e) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw new Error("index is out of range: " + e);
            }
          },
          clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w);
          },
          copy: function (e) {
            return (
              (this.x = e.x),
              (this.y = e.y),
              (this.z = e.z),
              (this.w = void 0 !== e.w ? e.w : 1),
              this
            );
          },
          add: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(e, t))
              : ((this.x += e.x),
                (this.y += e.y),
                (this.z += e.z),
                (this.w += e.w),
                this);
          },
          addScalar: function (e) {
            return (
              (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
            );
          },
          addVectors: function (e, t) {
            return (
              (this.x = e.x + t.x),
              (this.y = e.y + t.y),
              (this.z = e.z + t.z),
              (this.w = e.w + t.w),
              this
            );
          },
          addScaledVector: function (e, t) {
            return (
              (this.x += e.x * t),
              (this.y += e.y * t),
              (this.z += e.z * t),
              (this.w += e.w * t),
              this
            );
          },
          sub: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(e, t))
              : ((this.x -= e.x),
                (this.y -= e.y),
                (this.z -= e.z),
                (this.w -= e.w),
                this);
          },
          subScalar: function (e) {
            return (
              (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
            );
          },
          subVectors: function (e, t) {
            return (
              (this.x = e.x - t.x),
              (this.y = e.y - t.y),
              (this.z = e.z - t.z),
              (this.w = e.w - t.w),
              this
            );
          },
          multiplyScalar: function (e) {
            return (
              (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
            );
          },
          applyMatrix4: function (e) {
            var t = this.x,
              n = this.y,
              r = this.z,
              i = this.w,
              a = e.elements;
            return (
              (this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * i),
              (this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * i),
              (this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * i),
              (this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * i),
              this
            );
          },
          divideScalar: function (e) {
            return this.multiplyScalar(1 / e);
          },
          setAxisAngleFromQuaternion: function (e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return (
              t < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
              this
            );
          },
          setAxisAngleFromRotationMatrix: function (e) {
            var t,
              n,
              r,
              i,
              a = e.elements,
              o = a[0],
              s = a[4],
              c = a[8],
              u = a[1],
              l = a[5],
              h = a[9],
              d = a[2],
              p = a[6],
              f = a[10];
            if (
              Math.abs(s - u) < 0.01 &&
              Math.abs(c - d) < 0.01 &&
              Math.abs(h - p) < 0.01
            ) {
              if (
                Math.abs(s + u) < 0.1 &&
                Math.abs(c + d) < 0.1 &&
                Math.abs(h + p) < 0.1 &&
                Math.abs(o + l + f - 3) < 0.1
              )
                return this.set(1, 0, 0, 0), this;
              t = Math.PI;
              var m = (o + 1) / 2,
                v = (l + 1) / 2,
                g = (f + 1) / 2,
                y = (s + u) / 4,
                x = (c + d) / 4,
                b = (h + p) / 4;
              return (
                m > v && m > g
                  ? m < 0.01
                    ? ((n = 0), (r = 0.707106781), (i = 0.707106781))
                    : ((r = y / (n = Math.sqrt(m))), (i = x / n))
                  : v > g
                  ? v < 0.01
                    ? ((n = 0.707106781), (r = 0), (i = 0.707106781))
                    : ((n = y / (r = Math.sqrt(v))), (i = b / r))
                  : g < 0.01
                  ? ((n = 0.707106781), (r = 0.707106781), (i = 0))
                  : ((n = x / (i = Math.sqrt(g))), (r = b / i)),
                this.set(n, r, i, t),
                this
              );
            }
            var _ = Math.sqrt(
              (p - h) * (p - h) + (c - d) * (c - d) + (u - s) * (u - s)
            );
            return (
              Math.abs(_) < 0.001 && (_ = 1),
              (this.x = (p - h) / _),
              (this.y = (c - d) / _),
              (this.z = (u - s) / _),
              (this.w = Math.acos((o + l + f - 1) / 2)),
              this
            );
          },
          min: function (e) {
            return (
              (this.x = Math.min(this.x, e.x)),
              (this.y = Math.min(this.y, e.y)),
              (this.z = Math.min(this.z, e.z)),
              (this.w = Math.min(this.w, e.w)),
              this
            );
          },
          max: function (e) {
            return (
              (this.x = Math.max(this.x, e.x)),
              (this.y = Math.max(this.y, e.y)),
              (this.z = Math.max(this.z, e.z)),
              (this.w = Math.max(this.w, e.w)),
              this
            );
          },
          clamp: function (e, t) {
            return (
              (this.x = Math.max(e.x, Math.min(t.x, this.x))),
              (this.y = Math.max(e.y, Math.min(t.y, this.y))),
              (this.z = Math.max(e.z, Math.min(t.z, this.z))),
              (this.w = Math.max(e.w, Math.min(t.w, this.w))),
              this
            );
          },
          clampScalar: function (e, t) {
            return (
              (this.x = Math.max(e, Math.min(t, this.x))),
              (this.y = Math.max(e, Math.min(t, this.y))),
              (this.z = Math.max(e, Math.min(t, this.z))),
              (this.w = Math.max(e, Math.min(t, this.w))),
              this
            );
          },
          clampLength: function (e, t) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(e, Math.min(t, n))
            );
          },
          floor: function () {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          },
          ceil: function () {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          },
          round: function () {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          },
          roundToZero: function () {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
              this
            );
          },
          negate: function () {
            return (
              (this.x = -this.x),
              (this.y = -this.y),
              (this.z = -this.z),
              (this.w = -this.w),
              this
            );
          },
          dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
          },
          lengthSq: function () {
            return (
              this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
            );
          },
          length: function () {
            return Math.sqrt(
              this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w
            );
          },
          manhattanLength: function () {
            return (
              Math.abs(this.x) +
              Math.abs(this.y) +
              Math.abs(this.z) +
              Math.abs(this.w)
            );
          },
          normalize: function () {
            return this.divideScalar(this.length() || 1);
          },
          setLength: function (e) {
            return this.normalize().multiplyScalar(e);
          },
          lerp: function (e, t) {
            return (
              (this.x += (e.x - this.x) * t),
              (this.y += (e.y - this.y) * t),
              (this.z += (e.z - this.z) * t),
              (this.w += (e.w - this.w) * t),
              this
            );
          },
          lerpVectors: function (e, t, n) {
            return (
              (this.x = e.x + (t.x - e.x) * n),
              (this.y = e.y + (t.y - e.y) * n),
              (this.z = e.z + (t.z - e.z) * n),
              (this.w = e.w + (t.w - e.w) * n),
              this
            );
          },
          equals: function (e) {
            return (
              e.x === this.x &&
              e.y === this.y &&
              e.z === this.z &&
              e.w === this.w
            );
          },
          fromArray: function (e, t) {
            return (
              void 0 === t && (t = 0),
              (this.x = e[t]),
              (this.y = e[t + 1]),
              (this.z = e[t + 2]),
              (this.w = e[t + 3]),
              this
            );
          },
          toArray: function (e, t) {
            return (
              void 0 === e && (e = []),
              void 0 === t && (t = 0),
              (e[t] = this.x),
              (e[t + 1] = this.y),
              (e[t + 2] = this.z),
              (e[t + 3] = this.w),
              e
            );
          },
          fromBufferAttribute: function (e, t, n) {
            return (
              void 0 !== n &&
                console.warn(
                  "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
                ),
              (this.x = e.getX(t)),
              (this.y = e.getY(t)),
              (this.z = e.getZ(t)),
              (this.w = e.getW(t)),
              this
            );
          },
          random: function () {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              (this.w = Math.random()),
              this
            );
          },
        }),
        (Yn.prototype = Object.assign(Object.create(zn.prototype), {
          constructor: Yn,
          isWebGLRenderTarget: !0,
          setSize: function (e, t) {
            (this.width === e && this.height === t) ||
              ((this.width = e),
              (this.height = t),
              (this.texture.image.width = e),
              (this.texture.image.height = t),
              this.dispose()),
              this.viewport.set(0, 0, e, t),
              this.scissor.set(0, 0, e, t);
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (
              (this.width = e.width),
              (this.height = e.height),
              this.viewport.copy(e.viewport),
              (this.texture = e.texture.clone()),
              (this.depthBuffer = e.depthBuffer),
              (this.stencilBuffer = e.stencilBuffer),
              (this.depthTexture = e.depthTexture),
              this
            );
          },
          dispose: function () {
            this.dispatchEvent({ type: "dispose" });
          },
        })),
        (Zn.prototype = Object.assign(Object.create(Yn.prototype), {
          constructor: Zn,
          isWebGLMultisampleRenderTarget: !0,
          copy: function (e) {
            return (
              Yn.prototype.copy.call(this, e), (this.samples = e.samples), this
            );
          },
        })),
        Object.assign(Jn, {
          slerp: function (e, t, n, r) {
            return n.copy(e).slerp(t, r);
          },
          slerpFlat: function (e, t, n, r, i, a, o) {
            var s = n[r + 0],
              c = n[r + 1],
              u = n[r + 2],
              l = n[r + 3],
              h = i[a + 0],
              d = i[a + 1],
              p = i[a + 2],
              f = i[a + 3];
            if (l !== f || s !== h || c !== d || u !== p) {
              var m = 1 - o,
                v = s * h + c * d + u * p + l * f,
                g = v >= 0 ? 1 : -1,
                y = 1 - v * v;
              if (y > Number.EPSILON) {
                var x = Math.sqrt(y),
                  b = Math.atan2(x, v * g);
                (m = Math.sin(m * b) / x), (o = Math.sin(o * b) / x);
              }
              var _ = o * g;
              if (
                ((s = s * m + h * _),
                (c = c * m + d * _),
                (u = u * m + p * _),
                (l = l * m + f * _),
                m === 1 - o)
              ) {
                var w = 1 / Math.sqrt(s * s + c * c + u * u + l * l);
                (s *= w), (c *= w), (u *= w), (l *= w);
              }
            }
            (e[t] = s), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = l);
          },
          multiplyQuaternionsFlat: function (e, t, n, r, i, a) {
            var o = n[r],
              s = n[r + 1],
              c = n[r + 2],
              u = n[r + 3],
              l = i[a],
              h = i[a + 1],
              d = i[a + 2],
              p = i[a + 3];
            return (
              (e[t] = o * p + u * l + s * d - c * h),
              (e[t + 1] = s * p + u * h + c * l - o * d),
              (e[t + 2] = c * p + u * d + o * h - s * l),
              (e[t + 3] = u * p - o * l - s * h - c * d),
              e
            );
          },
        }),
        Object.defineProperties(Jn.prototype, {
          x: {
            get: function () {
              return this._x;
            },
            set: function (e) {
              (this._x = e), this._onChangeCallback();
            },
          },
          y: {
            get: function () {
              return this._y;
            },
            set: function (e) {
              (this._y = e), this._onChangeCallback();
            },
          },
          z: {
            get: function () {
              return this._z;
            },
            set: function (e) {
              (this._z = e), this._onChangeCallback();
            },
          },
          w: {
            get: function () {
              return this._w;
            },
            set: function (e) {
              (this._w = e), this._onChangeCallback();
            },
          },
        }),
        Object.assign(Jn.prototype, {
          isQuaternion: !0,
          set: function (e, t, n, r) {
            return (
              (this._x = e),
              (this._y = t),
              (this._z = n),
              (this._w = r),
              this._onChangeCallback(),
              this
            );
          },
          clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w);
          },
          copy: function (e) {
            return (
              (this._x = e.x),
              (this._y = e.y),
              (this._z = e.z),
              (this._w = e.w),
              this._onChangeCallback(),
              this
            );
          },
          setFromEuler: function (e, t) {
            if (!e || !e.isEuler)
              throw new Error(
                "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
              );
            var n = e._x,
              r = e._y,
              i = e._z,
              a = e.order,
              o = Math.cos,
              s = Math.sin,
              c = o(n / 2),
              u = o(r / 2),
              l = o(i / 2),
              h = s(n / 2),
              d = s(r / 2),
              p = s(i / 2);
            switch (a) {
              case "XYZ":
                (this._x = h * u * l + c * d * p),
                  (this._y = c * d * l - h * u * p),
                  (this._z = c * u * p + h * d * l),
                  (this._w = c * u * l - h * d * p);
                break;
              case "YXZ":
                (this._x = h * u * l + c * d * p),
                  (this._y = c * d * l - h * u * p),
                  (this._z = c * u * p - h * d * l),
                  (this._w = c * u * l + h * d * p);
                break;
              case "ZXY":
                (this._x = h * u * l - c * d * p),
                  (this._y = c * d * l + h * u * p),
                  (this._z = c * u * p + h * d * l),
                  (this._w = c * u * l - h * d * p);
                break;
              case "ZYX":
                (this._x = h * u * l - c * d * p),
                  (this._y = c * d * l + h * u * p),
                  (this._z = c * u * p - h * d * l),
                  (this._w = c * u * l + h * d * p);
                break;
              case "YZX":
                (this._x = h * u * l + c * d * p),
                  (this._y = c * d * l + h * u * p),
                  (this._z = c * u * p - h * d * l),
                  (this._w = c * u * l - h * d * p);
                break;
              case "XZY":
                (this._x = h * u * l - c * d * p),
                  (this._y = c * d * l - h * u * p),
                  (this._z = c * u * p + h * d * l),
                  (this._w = c * u * l + h * d * p);
                break;
              default:
                console.warn(
                  "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                    a
                );
            }
            return !1 !== t && this._onChangeCallback(), this;
          },
          setFromAxisAngle: function (e, t) {
            var n = t / 2,
              r = Math.sin(n);
            return (
              (this._x = e.x * r),
              (this._y = e.y * r),
              (this._z = e.z * r),
              (this._w = Math.cos(n)),
              this._onChangeCallback(),
              this
            );
          },
          setFromRotationMatrix: function (e) {
            var t = e.elements,
              n = t[0],
              r = t[4],
              i = t[8],
              a = t[1],
              o = t[5],
              s = t[9],
              c = t[2],
              u = t[6],
              l = t[10],
              h = n + o + l;
            if (h > 0) {
              var d = 0.5 / Math.sqrt(h + 1);
              (this._w = 0.25 / d),
                (this._x = (u - s) * d),
                (this._y = (i - c) * d),
                (this._z = (a - r) * d);
            } else if (n > o && n > l) {
              var p = 2 * Math.sqrt(1 + n - o - l);
              (this._w = (u - s) / p),
                (this._x = 0.25 * p),
                (this._y = (r + a) / p),
                (this._z = (i + c) / p);
            } else if (o > l) {
              var f = 2 * Math.sqrt(1 + o - n - l);
              (this._w = (i - c) / f),
                (this._x = (r + a) / f),
                (this._y = 0.25 * f),
                (this._z = (s + u) / f);
            } else {
              var m = 2 * Math.sqrt(1 + l - n - o);
              (this._w = (a - r) / m),
                (this._x = (i + c) / m),
                (this._y = (s + u) / m),
                (this._z = 0.25 * m);
            }
            return this._onChangeCallback(), this;
          },
          setFromUnitVectors: function (e, t) {
            var n = e.dot(t) + 1;
            return (
              n < 1e-6
                ? ((n = 0),
                  Math.abs(e.x) > Math.abs(e.z)
                    ? ((this._x = -e.y),
                      (this._y = e.x),
                      (this._z = 0),
                      (this._w = n))
                    : ((this._x = 0),
                      (this._y = -e.z),
                      (this._z = e.y),
                      (this._w = n)))
                : ((this._x = e.y * t.z - e.z * t.y),
                  (this._y = e.z * t.x - e.x * t.z),
                  (this._z = e.x * t.y - e.y * t.x),
                  (this._w = n)),
              this.normalize()
            );
          },
          angleTo: function (e) {
            return 2 * Math.acos(Math.abs(kn.clamp(this.dot(e), -1, 1)));
          },
          rotateTowards: function (e, t) {
            var n = this.angleTo(e);
            if (0 === n) return this;
            var r = Math.min(1, t / n);
            return this.slerp(e, r), this;
          },
          inverse: function () {
            return this.conjugate();
          },
          conjugate: function () {
            return (
              (this._x *= -1),
              (this._y *= -1),
              (this._z *= -1),
              this._onChangeCallback(),
              this
            );
          },
          dot: function (e) {
            return (
              this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            );
          },
          lengthSq: function () {
            return (
              this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
            );
          },
          length: function () {
            return Math.sqrt(
              this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w
            );
          },
          normalize: function () {
            var e = this.length();
            return (
              0 === e
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((e = 1 / e),
                  (this._x = this._x * e),
                  (this._y = this._y * e),
                  (this._z = this._z * e),
                  (this._w = this._w * e)),
              this._onChangeCallback(),
              this
            );
          },
          multiply: function (e, t) {
            return void 0 !== t
              ? (console.warn(
                  "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
                ),
                this.multiplyQuaternions(e, t))
              : this.multiplyQuaternions(this, e);
          },
          premultiply: function (e) {
            return this.multiplyQuaternions(e, this);
          },
          multiplyQuaternions: function (e, t) {
            var n = e._x,
              r = e._y,
              i = e._z,
              a = e._w,
              o = t._x,
              s = t._y,
              c = t._z,
              u = t._w;
            return (
              (this._x = n * u + a * o + r * c - i * s),
              (this._y = r * u + a * s + i * o - n * c),
              (this._z = i * u + a * c + n * s - r * o),
              (this._w = a * u - n * o - r * s - i * c),
              this._onChangeCallback(),
              this
            );
          },
          slerp: function (e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            var n = this._x,
              r = this._y,
              i = this._z,
              a = this._w,
              o = a * e._w + n * e._x + r * e._y + i * e._z;
            if (
              (o < 0
                ? ((this._w = -e._w),
                  (this._x = -e._x),
                  (this._y = -e._y),
                  (this._z = -e._z),
                  (o = -o))
                : this.copy(e),
              o >= 1)
            )
              return (
                (this._w = a), (this._x = n), (this._y = r), (this._z = i), this
              );
            var s = 1 - o * o;
            if (s <= Number.EPSILON) {
              var c = 1 - t;
              return (
                (this._w = c * a + t * this._w),
                (this._x = c * n + t * this._x),
                (this._y = c * r + t * this._y),
                (this._z = c * i + t * this._z),
                this.normalize(),
                this._onChangeCallback(),
                this
              );
            }
            var u = Math.sqrt(s),
              l = Math.atan2(u, o),
              h = Math.sin((1 - t) * l) / u,
              d = Math.sin(t * l) / u;
            return (
              (this._w = a * h + this._w * d),
              (this._x = n * h + this._x * d),
              (this._y = r * h + this._y * d),
              (this._z = i * h + this._z * d),
              this._onChangeCallback(),
              this
            );
          },
          equals: function (e) {
            return (
              e._x === this._x &&
              e._y === this._y &&
              e._z === this._z &&
              e._w === this._w
            );
          },
          fromArray: function (e, t) {
            return (
              void 0 === t && (t = 0),
              (this._x = e[t]),
              (this._y = e[t + 1]),
              (this._z = e[t + 2]),
              (this._w = e[t + 3]),
              this._onChangeCallback(),
              this
            );
          },
          toArray: function (e, t) {
            return (
              void 0 === e && (e = []),
              void 0 === t && (t = 0),
              (e[t] = this._x),
              (e[t + 1] = this._y),
              (e[t + 2] = this._z),
              (e[t + 3] = this._w),
              e
            );
          },
          fromBufferAttribute: function (e, t) {
            return (
              (this._x = e.getX(t)),
              (this._y = e.getY(t)),
              (this._z = e.getZ(t)),
              (this._w = e.getW(t)),
              this
            );
          },
          _onChange: function (e) {
            return (this._onChangeCallback = e), this;
          },
          _onChangeCallback: function () {},
        });
      var Kn = new $n(),
        Qn = new Jn();
      function $n() {
        var e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
          t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
          n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        (this.x = e), (this.y = t), (this.z = n);
      }
      Object.assign($n.prototype, {
        isVector3: !0,
        set: function (e, t, n) {
          return (this.x = e), (this.y = t), (this.z = n), this;
        },
        setScalar: function (e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        },
        setX: function (e) {
          return (this.x = e), this;
        },
        setY: function (e) {
          return (this.y = e), this;
        },
        setZ: function (e) {
          return (this.z = e), this;
        },
        setComponent: function (e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        },
        getComponent: function (e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y, this.z);
        },
        copy: function (e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        },
        add: function (e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
        },
        addScalar: function (e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        },
        addVectors: function (e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        },
        addScaledVector: function (e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        },
        sub: function (e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
        },
        subScalar: function (e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        },
        subVectors: function (e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        },
        multiply: function (e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(e, t))
            : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
        },
        multiplyScalar: function (e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        },
        multiplyVectors: function (e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        },
        applyEuler: function (e) {
          return (
            (e && e.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(Qn.setFromEuler(e))
          );
        },
        applyAxisAngle: function (e, t) {
          return this.applyQuaternion(Qn.setFromAxisAngle(e, t));
        },
        applyMatrix3: function (e) {
          var t = this.x,
            n = this.y,
            r = this.z,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[3] * n + i[6] * r),
            (this.y = i[1] * t + i[4] * n + i[7] * r),
            (this.z = i[2] * t + i[5] * n + i[8] * r),
            this
          );
        },
        applyNormalMatrix: function (e) {
          return this.applyMatrix3(e).normalize();
        },
        applyMatrix4: function (e) {
          var t = this.x,
            n = this.y,
            r = this.z,
            i = e.elements,
            a = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
          return (
            (this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * a),
            (this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * a),
            (this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * a),
            this
          );
        },
        applyQuaternion: function (e) {
          var t = this.x,
            n = this.y,
            r = this.z,
            i = e.x,
            a = e.y,
            o = e.z,
            s = e.w,
            c = s * t + a * r - o * n,
            u = s * n + o * t - i * r,
            l = s * r + i * n - a * t,
            h = -i * t - a * n - o * r;
          return (
            (this.x = c * s + h * -i + u * -o - l * -a),
            (this.y = u * s + h * -a + l * -i - c * -o),
            (this.z = l * s + h * -o + c * -a - u * -i),
            this
          );
        },
        project: function (e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        },
        unproject: function (e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        },
        transformDirection: function (e) {
          var t = this.x,
            n = this.y,
            r = this.z,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[4] * n + i[8] * r),
            (this.y = i[1] * t + i[5] * n + i[9] * r),
            (this.z = i[2] * t + i[6] * n + i[10] * r),
            this.normalize()
          );
        },
        divide: function (e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        },
        divideScalar: function (e) {
          return this.multiplyScalar(1 / e);
        },
        min: function (e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        },
        max: function (e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        },
        clamp: function (e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        },
        clampScalar: function (e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        },
        clampLength: function (e, t) {
          var n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        },
        floor: function () {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        },
        ceil: function () {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        },
        round: function () {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        },
        roundToZero: function () {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        },
        negate: function () {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        },
        dot: function (e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        },
        lengthSq: function () {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        length: function () {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        manhattanLength: function () {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },
        normalize: function () {
          return this.divideScalar(this.length() || 1);
        },
        setLength: function (e) {
          return this.normalize().multiplyScalar(e);
        },
        lerp: function (e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        },
        lerpVectors: function (e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
          );
        },
        cross: function (e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(e, t))
            : this.crossVectors(this, e);
        },
        crossVectors: function (e, t) {
          var n = e.x,
            r = e.y,
            i = e.z,
            a = t.x,
            o = t.y,
            s = t.z;
          return (
            (this.x = r * s - i * o),
            (this.y = i * a - n * s),
            (this.z = n * o - r * a),
            this
          );
        },
        projectOnVector: function (e) {
          var t = e.lengthSq();
          if (0 === t) return this.set(0, 0, 0);
          var n = e.dot(this) / t;
          return this.copy(e).multiplyScalar(n);
        },
        projectOnPlane: function (e) {
          return Kn.copy(this).projectOnVector(e), this.sub(Kn);
        },
        reflect: function (e) {
          return this.sub(Kn.copy(e).multiplyScalar(2 * this.dot(e)));
        },
        angleTo: function (e) {
          var t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          var n = this.dot(e) / t;
          return Math.acos(kn.clamp(n, -1, 1));
        },
        distanceTo: function (e) {
          return Math.sqrt(this.distanceToSquared(e));
        },
        distanceToSquared: function (e) {
          var t = this.x - e.x,
            n = this.y - e.y,
            r = this.z - e.z;
          return t * t + n * n + r * r;
        },
        manhattanDistanceTo: function (e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        },
        setFromSpherical: function (e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        },
        setFromSphericalCoords: function (e, t, n) {
          var r = Math.sin(t) * e;
          return (
            (this.x = r * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = r * Math.cos(n)),
            this
          );
        },
        setFromCylindrical: function (e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        },
        setFromCylindricalCoords: function (e, t, n) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
          );
        },
        setFromMatrixPosition: function (e) {
          var t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        },
        setFromMatrixScale: function (e) {
          var t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            r = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = n), (this.z = r), this;
        },
        setFromMatrixColumn: function (e, t) {
          return this.fromArray(e.elements, 4 * t);
        },
        setFromMatrix3Column: function (e, t) {
          return this.fromArray(e.elements, 3 * t);
        },
        equals: function (e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        },
        fromArray: function (e, t) {
          return (
            void 0 === t && (t = 0),
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            this
          );
        },
        toArray: function (e, t) {
          return (
            void 0 === e && (e = []),
            void 0 === t && (t = 0),
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            e
          );
        },
        fromBufferAttribute: function (e, t, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        },
        random: function () {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        },
      });
      var er = new $n(),
        tr = new sr(),
        nr = new $n(0, 0, 0),
        rr = new $n(1, 1, 1),
        ir = new $n(),
        ar = new $n(),
        or = new $n();
      function sr() {
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
            );
      }
      Object.assign(sr.prototype, {
        isMatrix4: !0,
        set: function (e, t, n, r, i, a, o, s, c, u, l, h, d, p, f, m) {
          var v = this.elements;
          return (
            (v[0] = e),
            (v[4] = t),
            (v[8] = n),
            (v[12] = r),
            (v[1] = i),
            (v[5] = a),
            (v[9] = o),
            (v[13] = s),
            (v[2] = c),
            (v[6] = u),
            (v[10] = l),
            (v[14] = h),
            (v[3] = d),
            (v[7] = p),
            (v[11] = f),
            (v[15] = m),
            this
          );
        },
        identity: function () {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        },
        clone: function () {
          return new sr().fromArray(this.elements);
        },
        copy: function (e) {
          var t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
          );
        },
        copyPosition: function (e) {
          var t = this.elements,
            n = e.elements;
          return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        },
        extractBasis: function (e, t, n) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        },
        makeBasis: function (e, t, n) {
          return (
            this.set(
              e.x,
              t.x,
              n.x,
              0,
              e.y,
              t.y,
              n.y,
              0,
              e.z,
              t.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        },
        extractRotation: function (e) {
          var t = this.elements,
            n = e.elements,
            r = 1 / er.setFromMatrixColumn(e, 0).length(),
            i = 1 / er.setFromMatrixColumn(e, 1).length(),
            a = 1 / er.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = n[0] * r),
            (t[1] = n[1] * r),
            (t[2] = n[2] * r),
            (t[3] = 0),
            (t[4] = n[4] * i),
            (t[5] = n[5] * i),
            (t[6] = n[6] * i),
            (t[7] = 0),
            (t[8] = n[8] * a),
            (t[9] = n[9] * a),
            (t[10] = n[10] * a),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        },
        makeRotationFromEuler: function (e) {
          (e && e.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          var t = this.elements,
            n = e.x,
            r = e.y,
            i = e.z,
            a = Math.cos(n),
            o = Math.sin(n),
            s = Math.cos(r),
            c = Math.sin(r),
            u = Math.cos(i),
            l = Math.sin(i);
          if ("XYZ" === e.order) {
            var h = a * u,
              d = a * l,
              p = o * u,
              f = o * l;
            (t[0] = s * u),
              (t[4] = -s * l),
              (t[8] = c),
              (t[1] = d + p * c),
              (t[5] = h - f * c),
              (t[9] = -o * s),
              (t[2] = f - h * c),
              (t[6] = p + d * c),
              (t[10] = a * s);
          } else if ("YXZ" === e.order) {
            var m = s * u,
              v = s * l,
              g = c * u,
              y = c * l;
            (t[0] = m + y * o),
              (t[4] = g * o - v),
              (t[8] = a * c),
              (t[1] = a * l),
              (t[5] = a * u),
              (t[9] = -o),
              (t[2] = v * o - g),
              (t[6] = y + m * o),
              (t[10] = a * s);
          } else if ("ZXY" === e.order) {
            var x = s * u,
              b = s * l,
              _ = c * u,
              w = c * l;
            (t[0] = x - w * o),
              (t[4] = -a * l),
              (t[8] = _ + b * o),
              (t[1] = b + _ * o),
              (t[5] = a * u),
              (t[9] = w - x * o),
              (t[2] = -a * c),
              (t[6] = o),
              (t[10] = a * s);
          } else if ("ZYX" === e.order) {
            var M = a * u,
              S = a * l,
              T = o * u,
              E = o * l;
            (t[0] = s * u),
              (t[4] = T * c - S),
              (t[8] = M * c + E),
              (t[1] = s * l),
              (t[5] = E * c + M),
              (t[9] = S * c - T),
              (t[2] = -c),
              (t[6] = o * s),
              (t[10] = a * s);
          } else if ("YZX" === e.order) {
            var A = a * s,
              L = a * c,
              C = o * s,
              R = o * c;
            (t[0] = s * u),
              (t[4] = R - A * l),
              (t[8] = C * l + L),
              (t[1] = l),
              (t[5] = a * u),
              (t[9] = -o * u),
              (t[2] = -c * u),
              (t[6] = L * l + C),
              (t[10] = A - R * l);
          } else if ("XZY" === e.order) {
            var P = a * s,
              O = a * c,
              D = o * s,
              I = o * c;
            (t[0] = s * u),
              (t[4] = -l),
              (t[8] = c * u),
              (t[1] = P * l + I),
              (t[5] = a * u),
              (t[9] = O * l - D),
              (t[2] = D * l - O),
              (t[6] = o * u),
              (t[10] = I * l + P);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        },
        makeRotationFromQuaternion: function (e) {
          return this.compose(nr, e, rr);
        },
        lookAt: function (e, t, n) {
          var r = this.elements;
          return (
            or.subVectors(e, t),
            0 === or.lengthSq() && (or.z = 1),
            or.normalize(),
            ir.crossVectors(n, or),
            0 === ir.lengthSq() &&
              (1 === Math.abs(n.z) ? (or.x += 1e-4) : (or.z += 1e-4),
              or.normalize(),
              ir.crossVectors(n, or)),
            ir.normalize(),
            ar.crossVectors(or, ir),
            (r[0] = ir.x),
            (r[4] = ar.x),
            (r[8] = or.x),
            (r[1] = ir.y),
            (r[5] = ar.y),
            (r[9] = or.y),
            (r[2] = ir.z),
            (r[6] = ar.z),
            (r[10] = or.z),
            this
          );
        },
        multiply: function (e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(e, t))
            : this.multiplyMatrices(this, e);
        },
        premultiply: function (e) {
          return this.multiplyMatrices(e, this);
        },
        multiplyMatrices: function (e, t) {
          var n = e.elements,
            r = t.elements,
            i = this.elements,
            a = n[0],
            o = n[4],
            s = n[8],
            c = n[12],
            u = n[1],
            l = n[5],
            h = n[9],
            d = n[13],
            p = n[2],
            f = n[6],
            m = n[10],
            v = n[14],
            g = n[3],
            y = n[7],
            x = n[11],
            b = n[15],
            _ = r[0],
            w = r[4],
            M = r[8],
            S = r[12],
            T = r[1],
            E = r[5],
            A = r[9],
            L = r[13],
            C = r[2],
            R = r[6],
            P = r[10],
            O = r[14],
            D = r[3],
            I = r[7],
            N = r[11],
            B = r[15];
          return (
            (i[0] = a * _ + o * T + s * C + c * D),
            (i[4] = a * w + o * E + s * R + c * I),
            (i[8] = a * M + o * A + s * P + c * N),
            (i[12] = a * S + o * L + s * O + c * B),
            (i[1] = u * _ + l * T + h * C + d * D),
            (i[5] = u * w + l * E + h * R + d * I),
            (i[9] = u * M + l * A + h * P + d * N),
            (i[13] = u * S + l * L + h * O + d * B),
            (i[2] = p * _ + f * T + m * C + v * D),
            (i[6] = p * w + f * E + m * R + v * I),
            (i[10] = p * M + f * A + m * P + v * N),
            (i[14] = p * S + f * L + m * O + v * B),
            (i[3] = g * _ + y * T + x * C + b * D),
            (i[7] = g * w + y * E + x * R + b * I),
            (i[11] = g * M + y * A + x * P + b * N),
            (i[15] = g * S + y * L + x * O + b * B),
            this
          );
        },
        multiplyScalar: function (e) {
          var t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        },
        determinant: function () {
          var e = this.elements,
            t = e[0],
            n = e[4],
            r = e[8],
            i = e[12],
            a = e[1],
            o = e[5],
            s = e[9],
            c = e[13],
            u = e[2],
            l = e[6],
            h = e[10],
            d = e[14];
          return (
            e[3] *
              (+i * s * l -
                r * c * l -
                i * o * h +
                n * c * h +
                r * o * d -
                n * s * d) +
            e[7] *
              (+t * s * d -
                t * c * h +
                i * a * h -
                r * a * d +
                r * c * u -
                i * s * u) +
            e[11] *
              (+t * c * l -
                t * o * d -
                i * a * l +
                n * a * d +
                i * o * u -
                n * c * u) +
            e[15] *
              (-r * o * u -
                t * s * l +
                t * o * h +
                r * a * l -
                n * a * h +
                n * s * u)
          );
        },
        transpose: function () {
          var e,
            t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[4]),
            (t[4] = e),
            (e = t[2]),
            (t[2] = t[8]),
            (t[8] = e),
            (e = t[6]),
            (t[6] = t[9]),
            (t[9] = e),
            (e = t[3]),
            (t[3] = t[12]),
            (t[12] = e),
            (e = t[7]),
            (t[7] = t[13]),
            (t[13] = e),
            (e = t[11]),
            (t[11] = t[14]),
            (t[14] = e),
            this
          );
        },
        setPosition: function (e, t, n) {
          var r = this.elements;
          return (
            e.isVector3
              ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
              : ((r[12] = e), (r[13] = t), (r[14] = n)),
            this
          );
        },
        getInverse: function (e, t) {
          void 0 !== t &&
            console.warn(
              "THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate."
            );
          var n = this.elements,
            r = e.elements,
            i = r[0],
            a = r[1],
            o = r[2],
            s = r[3],
            c = r[4],
            u = r[5],
            l = r[6],
            h = r[7],
            d = r[8],
            p = r[9],
            f = r[10],
            m = r[11],
            v = r[12],
            g = r[13],
            y = r[14],
            x = r[15],
            b =
              p * y * h -
              g * f * h +
              g * l * m -
              u * y * m -
              p * l * x +
              u * f * x,
            _ =
              v * f * h -
              d * y * h -
              v * l * m +
              c * y * m +
              d * l * x -
              c * f * x,
            w =
              d * g * h -
              v * p * h +
              v * u * m -
              c * g * m -
              d * u * x +
              c * p * x,
            M =
              v * p * l -
              d * g * l -
              v * u * f +
              c * g * f +
              d * u * y -
              c * p * y,
            S = i * b + a * _ + o * w + s * M;
          if (0 === S)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          var T = 1 / S;
          return (
            (n[0] = b * T),
            (n[1] =
              (g * f * s -
                p * y * s -
                g * o * m +
                a * y * m +
                p * o * x -
                a * f * x) *
              T),
            (n[2] =
              (u * y * s -
                g * l * s +
                g * o * h -
                a * y * h -
                u * o * x +
                a * l * x) *
              T),
            (n[3] =
              (p * l * s -
                u * f * s -
                p * o * h +
                a * f * h +
                u * o * m -
                a * l * m) *
              T),
            (n[4] = _ * T),
            (n[5] =
              (d * y * s -
                v * f * s +
                v * o * m -
                i * y * m -
                d * o * x +
                i * f * x) *
              T),
            (n[6] =
              (v * l * s -
                c * y * s -
                v * o * h +
                i * y * h +
                c * o * x -
                i * l * x) *
              T),
            (n[7] =
              (c * f * s -
                d * l * s +
                d * o * h -
                i * f * h -
                c * o * m +
                i * l * m) *
              T),
            (n[8] = w * T),
            (n[9] =
              (v * p * s -
                d * g * s -
                v * a * m +
                i * g * m +
                d * a * x -
                i * p * x) *
              T),
            (n[10] =
              (c * g * s -
                v * u * s +
                v * a * h -
                i * g * h -
                c * a * x +
                i * u * x) *
              T),
            (n[11] =
              (d * u * s -
                c * p * s -
                d * a * h +
                i * p * h +
                c * a * m -
                i * u * m) *
              T),
            (n[12] = M * T),
            (n[13] =
              (d * g * o -
                v * p * o +
                v * a * f -
                i * g * f -
                d * a * y +
                i * p * y) *
              T),
            (n[14] =
              (v * u * o -
                c * g * o -
                v * a * l +
                i * g * l +
                c * a * y -
                i * u * y) *
              T),
            (n[15] =
              (c * p * o -
                d * u * o +
                d * a * l -
                i * p * l -
                c * a * f +
                i * u * f) *
              T),
            this
          );
        },
        scale: function (e) {
          var t = this.elements,
            n = e.x,
            r = e.y,
            i = e.z;
          return (
            (t[0] *= n),
            (t[4] *= r),
            (t[8] *= i),
            (t[1] *= n),
            (t[5] *= r),
            (t[9] *= i),
            (t[2] *= n),
            (t[6] *= r),
            (t[10] *= i),
            (t[3] *= n),
            (t[7] *= r),
            (t[11] *= i),
            this
          );
        },
        getMaxScaleOnAxis: function () {
          var e = this.elements;
          return Math.sqrt(
            Math.max(
              e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
              e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
              e[8] * e[8] + e[9] * e[9] + e[10] * e[10]
            )
          );
        },
        makeTranslation: function (e, t, n) {
          return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        },
        makeRotationX: function (e) {
          var t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
          );
        },
        makeRotationY: function (e) {
          var t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
          );
        },
        makeRotationZ: function (e) {
          var t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        },
        makeRotationAxis: function (e, t) {
          var n = Math.cos(t),
            r = Math.sin(t),
            i = 1 - n,
            a = e.x,
            o = e.y,
            s = e.z,
            c = i * a,
            u = i * o;
          return (
            this.set(
              c * a + n,
              c * o - r * s,
              c * s + r * o,
              0,
              c * o + r * s,
              u * o + n,
              u * s - r * a,
              0,
              c * s - r * o,
              u * s + r * a,
              i * s * s + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        },
        makeScale: function (e, t, n) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        },
        makeShear: function (e, t, n) {
          return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this;
        },
        compose: function (e, t, n) {
          var r = this.elements,
            i = t._x,
            a = t._y,
            o = t._z,
            s = t._w,
            c = i + i,
            u = a + a,
            l = o + o,
            h = i * c,
            d = i * u,
            p = i * l,
            f = a * u,
            m = a * l,
            v = o * l,
            g = s * c,
            y = s * u,
            x = s * l,
            b = n.x,
            _ = n.y,
            w = n.z;
          return (
            (r[0] = (1 - (f + v)) * b),
            (r[1] = (d + x) * b),
            (r[2] = (p - y) * b),
            (r[3] = 0),
            (r[4] = (d - x) * _),
            (r[5] = (1 - (h + v)) * _),
            (r[6] = (m + g) * _),
            (r[7] = 0),
            (r[8] = (p + y) * w),
            (r[9] = (m - g) * w),
            (r[10] = (1 - (h + f)) * w),
            (r[11] = 0),
            (r[12] = e.x),
            (r[13] = e.y),
            (r[14] = e.z),
            (r[15] = 1),
            this
          );
        },
        decompose: function (e, t, n) {
          var r = this.elements,
            i = er.set(r[0], r[1], r[2]).length(),
            a = er.set(r[4], r[5], r[6]).length(),
            o = er.set(r[8], r[9], r[10]).length();
          this.determinant() < 0 && (i = -i),
            (e.x = r[12]),
            (e.y = r[13]),
            (e.z = r[14]),
            tr.copy(this);
          var s = 1 / i,
            c = 1 / a,
            u = 1 / o;
          return (
            (tr.elements[0] *= s),
            (tr.elements[1] *= s),
            (tr.elements[2] *= s),
            (tr.elements[4] *= c),
            (tr.elements[5] *= c),
            (tr.elements[6] *= c),
            (tr.elements[8] *= u),
            (tr.elements[9] *= u),
            (tr.elements[10] *= u),
            t.setFromRotationMatrix(tr),
            (n.x = i),
            (n.y = a),
            (n.z = o),
            this
          );
        },
        makePerspective: function (e, t, n, r, i, a) {
          void 0 === a &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          var o = this.elements,
            s = (2 * i) / (n - r),
            c = (t + e) / (t - e),
            u = (n + r) / (n - r),
            l = -(a + i) / (a - i),
            h = (-2 * a * i) / (a - i);
          return (
            (o[0] = (2 * i) / (t - e)),
            (o[4] = 0),
            (o[8] = c),
            (o[12] = 0),
            (o[1] = 0),
            (o[5] = s),
            (o[9] = u),
            (o[13] = 0),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = l),
            (o[14] = h),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = -1),
            (o[15] = 0),
            this
          );
        },
        makeOrthographic: function (e, t, n, r, i, a) {
          var o = this.elements,
            s = 1 / (t - e),
            c = 1 / (n - r),
            u = 1 / (a - i),
            l = (t + e) * s,
            h = (n + r) * c,
            d = (a + i) * u;
          return (
            (o[0] = 2 * s),
            (o[4] = 0),
            (o[8] = 0),
            (o[12] = -l),
            (o[1] = 0),
            (o[5] = 2 * c),
            (o[9] = 0),
            (o[13] = -h),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = -2 * u),
            (o[14] = -d),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = 0),
            (o[15] = 1),
            this
          );
        },
        equals: function (e) {
          for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)
            if (t[r] !== n[r]) return !1;
          return !0;
        },
        fromArray: function (e, t) {
          void 0 === t && (t = 0);
          for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
          return this;
        },
        toArray: function (e, t) {
          void 0 === e && (e = []), void 0 === t && (t = 0);
          var n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
          );
        },
      });
      var cr = new sr(),
        ur = new Jn();
      function lr() {
        var e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
          t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
          n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
          r =
            arguments.length > 3 && void 0 !== arguments[3]
              ? arguments[3]
              : lr.DefaultOrder;
        (this._x = e), (this._y = t), (this._z = n), (this._order = r);
      }
      function hr() {
        this.mask = 1;
      }
      (lr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
        (lr.DefaultOrder = "XYZ"),
        Object.defineProperties(lr.prototype, {
          x: {
            get: function () {
              return this._x;
            },
            set: function (e) {
              (this._x = e), this._onChangeCallback();
            },
          },
          y: {
            get: function () {
              return this._y;
            },
            set: function (e) {
              (this._y = e), this._onChangeCallback();
            },
          },
          z: {
            get: function () {
              return this._z;
            },
            set: function (e) {
              (this._z = e), this._onChangeCallback();
            },
          },
          order: {
            get: function () {
              return this._order;
            },
            set: function (e) {
              (this._order = e), this._onChangeCallback();
            },
          },
        }),
        Object.assign(lr.prototype, {
          isEuler: !0,
          set: function (e, t, n, r) {
            return (
              (this._x = e),
              (this._y = t),
              (this._z = n),
              (this._order = r || this._order),
              this._onChangeCallback(),
              this
            );
          },
          clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order);
          },
          copy: function (e) {
            return (
              (this._x = e._x),
              (this._y = e._y),
              (this._z = e._z),
              (this._order = e._order),
              this._onChangeCallback(),
              this
            );
          },
          setFromRotationMatrix: function (e, t, n) {
            var r = kn.clamp,
              i = e.elements,
              a = i[0],
              o = i[4],
              s = i[8],
              c = i[1],
              u = i[5],
              l = i[9],
              h = i[2],
              d = i[6],
              p = i[10];
            switch ((t = t || this._order)) {
              case "XYZ":
                (this._y = Math.asin(r(s, -1, 1))),
                  Math.abs(s) < 0.9999999
                    ? ((this._x = Math.atan2(-l, p)),
                      (this._z = Math.atan2(-o, a)))
                    : ((this._x = Math.atan2(d, u)), (this._z = 0));
                break;
              case "YXZ":
                (this._x = Math.asin(-r(l, -1, 1))),
                  Math.abs(l) < 0.9999999
                    ? ((this._y = Math.atan2(s, p)),
                      (this._z = Math.atan2(c, u)))
                    : ((this._y = Math.atan2(-h, a)), (this._z = 0));
                break;
              case "ZXY":
                (this._x = Math.asin(r(d, -1, 1))),
                  Math.abs(d) < 0.9999999
                    ? ((this._y = Math.atan2(-h, p)),
                      (this._z = Math.atan2(-o, u)))
                    : ((this._y = 0), (this._z = Math.atan2(c, a)));
                break;
              case "ZYX":
                (this._y = Math.asin(-r(h, -1, 1))),
                  Math.abs(h) < 0.9999999
                    ? ((this._x = Math.atan2(d, p)),
                      (this._z = Math.atan2(c, a)))
                    : ((this._x = 0), (this._z = Math.atan2(-o, u)));
                break;
              case "YZX":
                (this._z = Math.asin(r(c, -1, 1))),
                  Math.abs(c) < 0.9999999
                    ? ((this._x = Math.atan2(-l, u)),
                      (this._y = Math.atan2(-h, a)))
                    : ((this._x = 0), (this._y = Math.atan2(s, p)));
                break;
              case "XZY":
                (this._z = Math.asin(-r(o, -1, 1))),
                  Math.abs(o) < 0.9999999
                    ? ((this._x = Math.atan2(d, u)),
                      (this._y = Math.atan2(s, a)))
                    : ((this._x = Math.atan2(-l, p)), (this._y = 0));
                break;
              default:
                console.warn(
                  "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                    t
                );
            }
            return (
              (this._order = t), !1 !== n && this._onChangeCallback(), this
            );
          },
          setFromQuaternion: function (e, t, n) {
            return (
              cr.makeRotationFromQuaternion(e),
              this.setFromRotationMatrix(cr, t, n)
            );
          },
          setFromVector3: function (e, t) {
            return this.set(e.x, e.y, e.z, t || this._order);
          },
          reorder: function (e) {
            return ur.setFromEuler(this), this.setFromQuaternion(ur, e);
          },
          equals: function (e) {
            return (
              e._x === this._x &&
              e._y === this._y &&
              e._z === this._z &&
              e._order === this._order
            );
          },
          fromArray: function (e) {
            return (
              (this._x = e[0]),
              (this._y = e[1]),
              (this._z = e[2]),
              void 0 !== e[3] && (this._order = e[3]),
              this._onChangeCallback(),
              this
            );
          },
          toArray: function (e, t) {
            return (
              void 0 === e && (e = []),
              void 0 === t && (t = 0),
              (e[t] = this._x),
              (e[t + 1] = this._y),
              (e[t + 2] = this._z),
              (e[t + 3] = this._order),
              e
            );
          },
          toVector3: function (e) {
            return e
              ? e.set(this._x, this._y, this._z)
              : new $n(this._x, this._y, this._z);
          },
          _onChange: function (e) {
            return (this._onChangeCallback = e), this;
          },
          _onChangeCallback: function () {},
        }),
        Object.assign(hr.prototype, {
          set: function (e) {
            this.mask = (1 << e) | 0;
          },
          enable: function (e) {
            this.mask |= (1 << e) | 0;
          },
          enableAll: function () {
            this.mask = -1;
          },
          toggle: function (e) {
            this.mask ^= (1 << e) | 0;
          },
          disable: function (e) {
            this.mask &= ~((1 << e) | 0);
          },
          disableAll: function () {
            this.mask = 0;
          },
          test: function (e) {
            return 0 != (this.mask & e.mask);
          },
        });
      var dr = 0,
        pr = new $n(),
        fr = new Jn(),
        mr = new sr(),
        vr = new $n(),
        gr = new $n(),
        yr = new $n(),
        xr = new Jn(),
        br = new $n(1, 0, 0),
        _r = new $n(0, 1, 0),
        wr = new $n(0, 0, 1),
        Mr = { type: "added" },
        Sr = { type: "removed" };
      function Tr() {
        Object.defineProperty(this, "id", { value: dr++ }),
          (this.uuid = kn.generateUUID()),
          (this.name = ""),
          (this.type = "Object3D"),
          (this.parent = null),
          (this.children = []),
          (this.up = Tr.DefaultUp.clone());
        var e = new $n(),
          t = new lr(),
          n = new Jn(),
          r = new $n(1, 1, 1);
        t._onChange(function () {
          n.setFromEuler(t, !1);
        }),
          n._onChange(function () {
            t.setFromQuaternion(n, void 0, !1);
          }),
          Object.defineProperties(this, {
            position: { configurable: !0, enumerable: !0, value: e },
            rotation: { configurable: !0, enumerable: !0, value: t },
            quaternion: { configurable: !0, enumerable: !0, value: n },
            scale: { configurable: !0, enumerable: !0, value: r },
            modelViewMatrix: { value: new sr() },
            normalMatrix: { value: new jn() },
          }),
          (this.matrix = new sr()),
          (this.matrixWorld = new sr()),
          (this.matrixAutoUpdate = Tr.DefaultMatrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = !1),
          (this.layers = new hr()),
          (this.visible = !0),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !0),
          (this.renderOrder = 0),
          (this.userData = {});
      }
      function Er() {
        Tr.call(this),
          (this.type = "Scene"),
          (this.background = null),
          (this.environment = null),
          (this.fog = null),
          (this.overrideMaterial = null),
          (this.autoUpdate = !0),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      (Tr.DefaultUp = new $n(0, 1, 0)),
        (Tr.DefaultMatrixAutoUpdate = !0),
        (Tr.prototype = Object.assign(Object.create(zn.prototype), {
          constructor: Tr,
          isObject3D: !0,
          onBeforeRender: function () {},
          onAfterRender: function () {},
          applyMatrix4: function (e) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(e),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          },
          applyQuaternion: function (e) {
            return this.quaternion.premultiply(e), this;
          },
          setRotationFromAxisAngle: function (e, t) {
            this.quaternion.setFromAxisAngle(e, t);
          },
          setRotationFromEuler: function (e) {
            this.quaternion.setFromEuler(e, !0);
          },
          setRotationFromMatrix: function (e) {
            this.quaternion.setFromRotationMatrix(e);
          },
          setRotationFromQuaternion: function (e) {
            this.quaternion.copy(e);
          },
          rotateOnAxis: function (e, t) {
            return (
              fr.setFromAxisAngle(e, t), this.quaternion.multiply(fr), this
            );
          },
          rotateOnWorldAxis: function (e, t) {
            return (
              fr.setFromAxisAngle(e, t), this.quaternion.premultiply(fr), this
            );
          },
          rotateX: function (e) {
            return this.rotateOnAxis(br, e);
          },
          rotateY: function (e) {
            return this.rotateOnAxis(_r, e);
          },
          rotateZ: function (e) {
            return this.rotateOnAxis(wr, e);
          },
          translateOnAxis: function (e, t) {
            return (
              pr.copy(e).applyQuaternion(this.quaternion),
              this.position.add(pr.multiplyScalar(t)),
              this
            );
          },
          translateX: function (e) {
            return this.translateOnAxis(br, e);
          },
          translateY: function (e) {
            return this.translateOnAxis(_r, e);
          },
          translateZ: function (e) {
            return this.translateOnAxis(wr, e);
          },
          localToWorld: function (e) {
            return e.applyMatrix4(this.matrixWorld);
          },
          worldToLocal: function (e) {
            return e.applyMatrix4(mr.getInverse(this.matrixWorld));
          },
          lookAt: function (e, t, n) {
            e.isVector3 ? vr.copy(e) : vr.set(e, t, n);
            var r = this.parent;
            this.updateWorldMatrix(!0, !1),
              gr.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? mr.lookAt(gr, vr, this.up)
                : mr.lookAt(vr, gr, this.up),
              this.quaternion.setFromRotationMatrix(mr),
              r &&
                (mr.extractRotation(r.matrixWorld),
                fr.setFromRotationMatrix(mr),
                this.quaternion.premultiply(fr.inverse()));
          },
          add: function (e) {
            if (arguments.length > 1) {
              for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
              return this;
            }
            return e === this
              ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  e
                ),
                this)
              : (e && e.isObject3D
                  ? (null !== e.parent && e.parent.remove(e),
                    (e.parent = this),
                    this.children.push(e),
                    e.dispatchEvent(Mr))
                  : console.error(
                      "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                      e
                    ),
                this);
          },
          remove: function (e) {
            if (arguments.length > 1) {
              for (var t = 0; t < arguments.length; t++)
                this.remove(arguments[t]);
              return this;
            }
            var n = this.children.indexOf(e);
            return (
              -1 !== n &&
                ((e.parent = null),
                this.children.splice(n, 1),
                e.dispatchEvent(Sr)),
              this
            );
          },
          attach: function (e) {
            return (
              this.updateWorldMatrix(!0, !1),
              mr.getInverse(this.matrixWorld),
              null !== e.parent &&
                (e.parent.updateWorldMatrix(!0, !1),
                mr.multiply(e.parent.matrixWorld)),
              e.applyMatrix4(mr),
              e.updateWorldMatrix(!1, !1),
              this.add(e),
              this
            );
          },
          getObjectById: function (e) {
            return this.getObjectByProperty("id", e);
          },
          getObjectByName: function (e) {
            return this.getObjectByProperty("name", e);
          },
          getObjectByProperty: function (e, t) {
            if (this[e] === t) return this;
            for (var n = 0, r = this.children.length; n < r; n++) {
              var i = this.children[n].getObjectByProperty(e, t);
              if (void 0 !== i) return i;
            }
          },
          getWorldPosition: function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Object3D: .getWorldPosition() target is now required"
                ),
                (e = new $n())),
              this.updateMatrixWorld(!0),
              e.setFromMatrixPosition(this.matrixWorld)
            );
          },
          getWorldQuaternion: function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Object3D: .getWorldQuaternion() target is now required"
                ),
                (e = new Jn())),
              this.updateMatrixWorld(!0),
              this.matrixWorld.decompose(gr, e, yr),
              e
            );
          },
          getWorldScale: function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Object3D: .getWorldScale() target is now required"
                ),
                (e = new $n())),
              this.updateMatrixWorld(!0),
              this.matrixWorld.decompose(gr, xr, e),
              e
            );
          },
          getWorldDirection: function (e) {
            void 0 === e &&
              (console.warn(
                "THREE.Object3D: .getWorldDirection() target is now required"
              ),
              (e = new $n())),
              this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize();
          },
          raycast: function () {},
          traverse: function (e) {
            e(this);
            for (var t = this.children, n = 0, r = t.length; n < r; n++)
              t[n].traverse(e);
          },
          traverseVisible: function (e) {
            if (!1 !== this.visible) {
              e(this);
              for (var t = this.children, n = 0, r = t.length; n < r; n++)
                t[n].traverseVisible(e);
            }
          },
          traverseAncestors: function (e) {
            var t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e));
          },
          updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          },
          updateMatrixWorld: function (e) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || e) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    ),
                (this.matrixWorldNeedsUpdate = !1),
                (e = !0));
            for (var t = this.children, n = 0, r = t.length; n < r; n++)
              t[n].updateMatrixWorld(e);
          },
          updateWorldMatrix: function (e, t) {
            var n = this.parent;
            if (
              (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              !0 === t)
            )
              for (var r = this.children, i = 0, a = r.length; i < a; i++)
                r[i].updateWorldMatrix(!1, !0);
          },
          toJSON: function (e) {
            var t = void 0 === e || "string" == typeof e,
              n = {};
            t &&
              ((e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
              }),
              (n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON",
              }));
            var r = {};
            function i(t, n) {
              return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
            }
            if (
              ((r.uuid = this.uuid),
              (r.type = this.type),
              "" !== this.name && (r.name = this.name),
              !0 === this.castShadow && (r.castShadow = !0),
              !0 === this.receiveShadow && (r.receiveShadow = !0),
              !1 === this.visible && (r.visible = !1),
              !1 === this.frustumCulled && (r.frustumCulled = !1),
              0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
              "{}" !== JSON.stringify(this.userData) &&
                (r.userData = this.userData),
              (r.layers = this.layers.mask),
              (r.matrix = this.matrix.toArray()),
              !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
              this.isInstancedMesh &&
                ((r.type = "InstancedMesh"),
                (r.count = this.count),
                (r.instanceMatrix = this.instanceMatrix.toJSON())),
              this.isMesh || this.isLine || this.isPoints)
            ) {
              r.geometry = i(e.geometries, this.geometry);
              var a = this.geometry.parameters;
              if (void 0 !== a && void 0 !== a.shapes) {
                var o = a.shapes;
                if (Array.isArray(o))
                  for (var s = 0, c = o.length; s < c; s++) i(e.shapes, o[s]);
                else i(e.shapes, o);
              }
            }
            if (void 0 !== this.material)
              if (Array.isArray(this.material)) {
                for (var u = [], l = 0, h = this.material.length; l < h; l++)
                  u.push(i(e.materials, this.material[l]));
                r.material = u;
              } else r.material = i(e.materials, this.material);
            if (this.children.length > 0) {
              r.children = [];
              for (var d = 0; d < this.children.length; d++)
                r.children.push(this.children[d].toJSON(e).object);
            }
            if (t) {
              var p = y(e.geometries),
                f = y(e.materials),
                m = y(e.textures),
                v = y(e.images),
                g = y(e.shapes);
              p.length > 0 && (n.geometries = p),
                f.length > 0 && (n.materials = f),
                m.length > 0 && (n.textures = m),
                v.length > 0 && (n.images = v),
                g.length > 0 && (n.shapes = g);
            }
            return (n.object = r), n;
            function y(e) {
              var t = [];
              for (var n in e) {
                var r = e[n];
                delete r.metadata, t.push(r);
              }
              return t;
            }
          },
          clone: function (e) {
            return new this.constructor().copy(this, e);
          },
          copy: function (e, t) {
            if (
              (void 0 === t && (t = !0),
              (this.name = e.name),
              this.up.copy(e.up),
              this.position.copy(e.position),
              this.quaternion.copy(e.quaternion),
              this.scale.copy(e.scale),
              this.matrix.copy(e.matrix),
              this.matrixWorld.copy(e.matrixWorld),
              (this.matrixAutoUpdate = e.matrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
              (this.layers.mask = e.layers.mask),
              (this.visible = e.visible),
              (this.castShadow = e.castShadow),
              (this.receiveShadow = e.receiveShadow),
              (this.frustumCulled = e.frustumCulled),
              (this.renderOrder = e.renderOrder),
              (this.userData = JSON.parse(JSON.stringify(e.userData))),
              !0 === t)
            )
              for (var n = 0; n < e.children.length; n++)
                this.add(e.children[n].clone());
            return this;
          },
        })),
        (Er.prototype = Object.assign(Object.create(Tr.prototype), {
          constructor: Er,
          isScene: !0,
          copy: function (e, t) {
            return (
              Tr.prototype.copy.call(this, e, t),
              null !== e.background && (this.background = e.background.clone()),
              null !== e.environment &&
                (this.environment = e.environment.clone()),
              null !== e.fog && (this.fog = e.fog.clone()),
              null !== e.overrideMaterial &&
                (this.overrideMaterial = e.overrideMaterial.clone()),
              (this.autoUpdate = e.autoUpdate),
              (this.matrixAutoUpdate = e.matrixAutoUpdate),
              this
            );
          },
          toJSON: function (e) {
            var t = Tr.prototype.toJSON.call(this, e);
            return (
              null !== this.background &&
                (t.object.background = this.background.toJSON(e)),
              null !== this.environment &&
                (t.object.environment = this.environment.toJSON(e)),
              null !== this.fog && (t.object.fog = this.fog.toJSON()),
              t
            );
          },
          dispose: function () {
            this.dispatchEvent({ type: "dispose" });
          },
        }));
      var Ar = [
          new $n(),
          new $n(),
          new $n(),
          new $n(),
          new $n(),
          new $n(),
          new $n(),
          new $n(),
        ],
        Lr = new $n(),
        Cr = new Gr(),
        Rr = new $n(),
        Pr = new $n(),
        Or = new $n(),
        Dr = new $n(),
        Ir = new $n(),
        Nr = new $n(),
        Br = new $n(),
        zr = new $n(),
        Fr = new $n(),
        Ur = new $n();
      function Gr(e, t) {
        (this.min = void 0 !== e ? e : new $n(1 / 0, 1 / 0, 1 / 0)),
          (this.max = void 0 !== t ? t : new $n(-1 / 0, -1 / 0, -1 / 0));
      }
      function kr(e, t, n, r, i) {
        for (var a = 0, o = e.length - 3; a <= o; a += 3) {
          Ur.fromArray(e, a);
          var s =
              i.x * Math.abs(Ur.x) +
              i.y * Math.abs(Ur.y) +
              i.z * Math.abs(Ur.z),
            c = t.dot(Ur),
            u = n.dot(Ur),
            l = r.dot(Ur);
          if (Math.max(-Math.max(c, u, l), Math.min(c, u, l)) > s) return !1;
        }
        return !0;
      }
      Object.assign(Gr.prototype, {
        isBox3: !0,
        set: function (e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        },
        setFromArray: function (e) {
          for (
            var t = 1 / 0,
              n = 1 / 0,
              r = 1 / 0,
              i = -1 / 0,
              a = -1 / 0,
              o = -1 / 0,
              s = 0,
              c = e.length;
            s < c;
            s += 3
          ) {
            var u = e[s],
              l = e[s + 1],
              h = e[s + 2];
            u < t && (t = u),
              l < n && (n = l),
              h < r && (r = h),
              u > i && (i = u),
              l > a && (a = l),
              h > o && (o = h);
          }
          return this.min.set(t, n, r), this.max.set(i, a, o), this;
        },
        setFromBufferAttribute: function (e) {
          for (
            var t = 1 / 0,
              n = 1 / 0,
              r = 1 / 0,
              i = -1 / 0,
              a = -1 / 0,
              o = -1 / 0,
              s = 0,
              c = e.count;
            s < c;
            s++
          ) {
            var u = e.getX(s),
              l = e.getY(s),
              h = e.getZ(s);
            u < t && (t = u),
              l < n && (n = l),
              h < r && (r = h),
              u > i && (i = u),
              l > a && (a = l),
              h > o && (o = h);
          }
          return this.min.set(t, n, r), this.max.set(i, a, o), this;
        },
        setFromPoints: function (e) {
          this.makeEmpty();
          for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        },
        setFromCenterAndSize: function (e, t) {
          var n = Lr.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        },
        setFromObject: function (e) {
          return this.makeEmpty(), this.expandByObject(e);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        },
        makeEmpty: function () {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        },
        isEmpty: function () {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        },
        getCenter: function (e) {
          return (
            void 0 === e &&
              (console.warn("THREE.Box3: .getCenter() target is now required"),
              (e = new $n())),
            this.isEmpty()
              ? e.set(0, 0, 0)
              : e.addVectors(this.min, this.max).multiplyScalar(0.5)
          );
        },
        getSize: function (e) {
          return (
            void 0 === e &&
              (console.warn("THREE.Box3: .getSize() target is now required"),
              (e = new $n())),
            this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
          );
        },
        expandByPoint: function (e) {
          return this.min.min(e), this.max.max(e), this;
        },
        expandByVector: function (e) {
          return this.min.sub(e), this.max.add(e), this;
        },
        expandByScalar: function (e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        },
        expandByObject: function (e) {
          e.updateWorldMatrix(!1, !1);
          var t = e.geometry;
          void 0 !== t &&
            (null === t.boundingBox && t.computeBoundingBox(),
            Cr.copy(t.boundingBox),
            Cr.applyMatrix4(e.matrixWorld),
            this.union(Cr));
          for (var n = e.children, r = 0, i = n.length; r < i; r++)
            this.expandByObject(n[r]);
          return this;
        },
        containsPoint: function (e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
          );
        },
        containsBox: function (e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        },
        getParameter: function (e, t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Box3: .getParameter() target is now required"
              ),
              (t = new $n())),
            t.set(
              (e.x - this.min.x) / (this.max.x - this.min.x),
              (e.y - this.min.y) / (this.max.y - this.min.y),
              (e.z - this.min.z) / (this.max.z - this.min.z)
            )
          );
        },
        intersectsBox: function (e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
          );
        },
        intersectsSphere: function (e) {
          return (
            this.clampPoint(e.center, Lr),
            Lr.distanceToSquared(e.center) <= e.radius * e.radius
          );
        },
        intersectsPlane: function (e) {
          var t, n;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (n += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
          );
        },
        intersectsTriangle: function (e) {
          if (this.isEmpty()) return !1;
          this.getCenter(Br),
            zr.subVectors(this.max, Br),
            Rr.subVectors(e.a, Br),
            Pr.subVectors(e.b, Br),
            Or.subVectors(e.c, Br),
            Dr.subVectors(Pr, Rr),
            Ir.subVectors(Or, Pr),
            Nr.subVectors(Rr, Or);
          var t = [
            0,
            -Dr.z,
            Dr.y,
            0,
            -Ir.z,
            Ir.y,
            0,
            -Nr.z,
            Nr.y,
            Dr.z,
            0,
            -Dr.x,
            Ir.z,
            0,
            -Ir.x,
            Nr.z,
            0,
            -Nr.x,
            -Dr.y,
            Dr.x,
            0,
            -Ir.y,
            Ir.x,
            0,
            -Nr.y,
            Nr.x,
            0,
          ];
          return (
            !!kr(t, Rr, Pr, Or, zr) &&
            !!kr((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), Rr, Pr, Or, zr) &&
            (Fr.crossVectors(Dr, Ir),
            kr((t = [Fr.x, Fr.y, Fr.z]), Rr, Pr, Or, zr))
          );
        },
        clampPoint: function (e, t) {
          return (
            void 0 === t &&
              (console.warn("THREE.Box3: .clampPoint() target is now required"),
              (t = new $n())),
            t.copy(e).clamp(this.min, this.max)
          );
        },
        distanceToPoint: function (e) {
          return Lr.copy(e).clamp(this.min, this.max).sub(e).length();
        },
        getBoundingSphere: function (e) {
          return (
            void 0 === e &&
              console.error(
                "THREE.Box3: .getBoundingSphere() target is now required"
              ),
            this.getCenter(e.center),
            (e.radius = 0.5 * this.getSize(Lr).length()),
            e
          );
        },
        intersect: function (e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        },
        union: function (e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        },
        applyMatrix4: function (e) {
          return (
            this.isEmpty() ||
              (Ar[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              Ar[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              Ar[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              Ar[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              Ar[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              Ar[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              Ar[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              Ar[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(Ar)),
            this
          );
        },
        translate: function (e) {
          return this.min.add(e), this.max.add(e), this;
        },
        equals: function (e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        },
      });
      var Hr = new Gr();
      function jr(e, t) {
        (this.center = void 0 !== e ? e : new $n()),
          (this.radius = void 0 !== t ? t : -1);
      }
      Object.assign(jr.prototype, {
        set: function (e, t) {
          return this.center.copy(e), (this.radius = t), this;
        },
        setFromPoints: function (e, t) {
          var n = this.center;
          void 0 !== t ? n.copy(t) : Hr.setFromPoints(e).getCenter(n);
          for (var r = 0, i = 0, a = e.length; i < a; i++)
            r = Math.max(r, n.distanceToSquared(e[i]));
          return (this.radius = Math.sqrt(r)), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        },
        isEmpty: function () {
          return this.radius < 0;
        },
        makeEmpty: function () {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        },
        containsPoint: function (e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        },
        distanceToPoint: function (e) {
          return e.distanceTo(this.center) - this.radius;
        },
        intersectsSphere: function (e) {
          var t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        },
        intersectsBox: function (e) {
          return e.intersectsSphere(this);
        },
        intersectsPlane: function (e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        },
        clampPoint: function (e, t) {
          var n = this.center.distanceToSquared(e);
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Sphere: .clampPoint() target is now required"
              ),
              (t = new $n())),
            t.copy(e),
            n > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        },
        getBoundingBox: function (e) {
          return (
            void 0 === e &&
              (console.warn(
                "THREE.Sphere: .getBoundingBox() target is now required"
              ),
              (e = new Gr())),
            this.isEmpty()
              ? (e.makeEmpty(), e)
              : (e.set(this.center, this.center),
                e.expandByScalar(this.radius),
                e)
          );
        },
        applyMatrix4: function (e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        },
        translate: function (e) {
          return this.center.add(e), this;
        },
        equals: function (e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        },
      });
      var Vr = new $n(),
        Wr = new $n(),
        qr = new $n(),
        Xr = new $n(),
        Yr = new $n(),
        Zr = new $n(),
        Jr = new $n();
      function Kr(e, t) {
        (this.origin = void 0 !== e ? e : new $n()),
          (this.direction = void 0 !== t ? t : new $n(0, 0, -1));
      }
      Object.assign(Kr.prototype, {
        set: function (e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        },
        at: function (e, t) {
          return (
            void 0 === t &&
              (console.warn("THREE.Ray: .at() target is now required"),
              (t = new $n())),
            t.copy(this.direction).multiplyScalar(e).add(this.origin)
          );
        },
        lookAt: function (e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        },
        recast: function (e) {
          return this.origin.copy(this.at(e, Vr)), this;
        },
        closestPointToPoint: function (e, t) {
          void 0 === t &&
            (console.warn(
              "THREE.Ray: .closestPointToPoint() target is now required"
            ),
            (t = new $n())),
            t.subVectors(e, this.origin);
          var n = t.dot(this.direction);
          return n < 0
            ? t.copy(this.origin)
            : t.copy(this.direction).multiplyScalar(n).add(this.origin);
        },
        distanceToPoint: function (e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        },
        distanceSqToPoint: function (e) {
          var t = Vr.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (Vr.copy(this.direction).multiplyScalar(t).add(this.origin),
              Vr.distanceToSquared(e));
        },
        distanceSqToSegment: function (e, t, n, r) {
          Wr.copy(e).add(t).multiplyScalar(0.5),
            qr.copy(t).sub(e).normalize(),
            Xr.copy(this.origin).sub(Wr);
          var i,
            a,
            o,
            s,
            c = 0.5 * e.distanceTo(t),
            u = -this.direction.dot(qr),
            l = Xr.dot(this.direction),
            h = -Xr.dot(qr),
            d = Xr.lengthSq(),
            p = Math.abs(1 - u * u);
          if (p > 0)
            if (((a = u * l - h), (s = c * p), (i = u * h - l) >= 0))
              if (a >= -s)
                if (a <= s) {
                  var f = 1 / p;
                  o =
                    (i *= f) * (i + u * (a *= f) + 2 * l) +
                    a * (u * i + a + 2 * h) +
                    d;
                } else
                  (a = c),
                    (o =
                      -(i = Math.max(0, -(u * a + l))) * i +
                      a * (a + 2 * h) +
                      d);
              else
                (a = -c),
                  (o =
                    -(i = Math.max(0, -(u * a + l))) * i + a * (a + 2 * h) + d);
            else
              a <= -s
                ? (o =
                    -(i = Math.max(0, -(-u * c + l))) * i +
                    (a = i > 0 ? -c : Math.min(Math.max(-c, -h), c)) *
                      (a + 2 * h) +
                    d)
                : a <= s
                ? ((i = 0),
                  (o = (a = Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d))
                : (o =
                    -(i = Math.max(0, -(u * c + l))) * i +
                    (a = i > 0 ? c : Math.min(Math.max(-c, -h), c)) *
                      (a + 2 * h) +
                    d);
          else
            (a = u > 0 ? -c : c),
              (o = -(i = Math.max(0, -(u * a + l))) * i + a * (a + 2 * h) + d);
          return (
            n && n.copy(this.direction).multiplyScalar(i).add(this.origin),
            r && r.copy(qr).multiplyScalar(a).add(Wr),
            o
          );
        },
        intersectSphere: function (e, t) {
          Vr.subVectors(e.center, this.origin);
          var n = Vr.dot(this.direction),
            r = Vr.dot(Vr) - n * n,
            i = e.radius * e.radius;
          if (r > i) return null;
          var a = Math.sqrt(i - r),
            o = n - a,
            s = n + a;
          return o < 0 && s < 0 ? null : this.at(o < 0 ? s : o, t);
        },
        intersectsSphere: function (e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        },
        distanceToPlane: function (e) {
          var t = e.normal.dot(this.direction);
          if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
          var n = -(this.origin.dot(e.normal) + e.constant) / t;
          return n >= 0 ? n : null;
        },
        intersectPlane: function (e, t) {
          var n = this.distanceToPlane(e);
          return null === n ? null : this.at(n, t);
        },
        intersectsPlane: function (e) {
          var t = e.distanceToPoint(this.origin);
          return 0 === t || e.normal.dot(this.direction) * t < 0;
        },
        intersectBox: function (e, t) {
          var n,
            r,
            i,
            a,
            o,
            s,
            c = 1 / this.direction.x,
            u = 1 / this.direction.y,
            l = 1 / this.direction.z,
            h = this.origin;
          return (
            c >= 0
              ? ((n = (e.min.x - h.x) * c), (r = (e.max.x - h.x) * c))
              : ((n = (e.max.x - h.x) * c), (r = (e.min.x - h.x) * c)),
            u >= 0
              ? ((i = (e.min.y - h.y) * u), (a = (e.max.y - h.y) * u))
              : ((i = (e.max.y - h.y) * u), (a = (e.min.y - h.y) * u)),
            n > a || i > r
              ? null
              : ((i > n || n != n) && (n = i),
                (a < r || r != r) && (r = a),
                l >= 0
                  ? ((o = (e.min.z - h.z) * l), (s = (e.max.z - h.z) * l))
                  : ((o = (e.max.z - h.z) * l), (s = (e.min.z - h.z) * l)),
                n > s || o > r
                  ? null
                  : ((o > n || n != n) && (n = o),
                    (s < r || r != r) && (r = s),
                    r < 0 ? null : this.at(n >= 0 ? n : r, t)))
          );
        },
        intersectsBox: function (e) {
          return null !== this.intersectBox(e, Vr);
        },
        intersectTriangle: function (e, t, n, r, i) {
          Yr.subVectors(t, e), Zr.subVectors(n, e), Jr.crossVectors(Yr, Zr);
          var a,
            o = this.direction.dot(Jr);
          if (o > 0) {
            if (r) return null;
            a = 1;
          } else {
            if (!(o < 0)) return null;
            (a = -1), (o = -o);
          }
          Xr.subVectors(this.origin, e);
          var s = a * this.direction.dot(Zr.crossVectors(Xr, Zr));
          if (s < 0) return null;
          var c = a * this.direction.dot(Yr.cross(Xr));
          if (c < 0) return null;
          if (s + c > o) return null;
          var u = -a * Xr.dot(Jr);
          return u < 0 ? null : this.at(u / o, i);
        },
        applyMatrix4: function (e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        },
        equals: function (e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        },
      });
      var Qr = new $n(),
        $r = new $n(),
        ei = new jn();
      function ti(e, t) {
        (this.normal = void 0 !== e ? e : new $n(1, 0, 0)),
          (this.constant = void 0 !== t ? t : 0);
      }
      Object.assign(ti.prototype, {
        isPlane: !0,
        set: function (e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        },
        setComponents: function (e, t, n, r) {
          return this.normal.set(e, t, n), (this.constant = r), this;
        },
        setFromNormalAndCoplanarPoint: function (e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        },
        setFromCoplanarPoints: function (e, t, n) {
          var r = Qr.subVectors(n, t).cross($r.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(r, e), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        },
        normalize: function () {
          var e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        },
        negate: function () {
          return (this.constant *= -1), this.normal.negate(), this;
        },
        distanceToPoint: function (e) {
          return this.normal.dot(e) + this.constant;
        },
        distanceToSphere: function (e) {
          return this.distanceToPoint(e.center) - e.radius;
        },
        projectPoint: function (e, t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Plane: .projectPoint() target is now required"
              ),
              (t = new $n())),
            t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
          );
        },
        intersectLine: function (e, t) {
          void 0 === t &&
            (console.warn(
              "THREE.Plane: .intersectLine() target is now required"
            ),
            (t = new $n()));
          var n = e.delta(Qr),
            r = this.normal.dot(n);
          if (0 === r)
            return 0 === this.distanceToPoint(e.start)
              ? t.copy(e.start)
              : void 0;
          var i = -(e.start.dot(this.normal) + this.constant) / r;
          return i < 0 || i > 1
            ? void 0
            : t.copy(n).multiplyScalar(i).add(e.start);
        },
        intersectsLine: function (e) {
          var t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
          return (t < 0 && n > 0) || (n < 0 && t > 0);
        },
        intersectsBox: function (e) {
          return e.intersectsPlane(this);
        },
        intersectsSphere: function (e) {
          return e.intersectsPlane(this);
        },
        coplanarPoint: function (e) {
          return (
            void 0 === e &&
              (console.warn(
                "THREE.Plane: .coplanarPoint() target is now required"
              ),
              (e = new $n())),
            e.copy(this.normal).multiplyScalar(-this.constant)
          );
        },
        applyMatrix4: function (e, t) {
          var n = t || ei.getNormalMatrix(e),
            r = this.coplanarPoint(Qr).applyMatrix4(e),
            i = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -r.dot(i)), this;
        },
        translate: function (e) {
          return (this.constant -= e.dot(this.normal)), this;
        },
        equals: function (e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        },
      });
      var ni = new $n(),
        ri = new $n(),
        ii = new $n(),
        ai = new $n(),
        oi = new $n(),
        si = new $n(),
        ci = new $n(),
        ui = new $n(),
        li = new $n(),
        hi = new $n();
      function di(e, t, n) {
        (this.a = void 0 !== e ? e : new $n()),
          (this.b = void 0 !== t ? t : new $n()),
          (this.c = void 0 !== n ? n : new $n());
      }
      Object.assign(di, {
        getNormal: function (e, t, n, r) {
          void 0 === r &&
            (console.warn(
              "THREE.Triangle: .getNormal() target is now required"
            ),
            (r = new $n())),
            r.subVectors(n, t),
            ni.subVectors(e, t),
            r.cross(ni);
          var i = r.lengthSq();
          return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0);
        },
        getBarycoord: function (e, t, n, r, i) {
          ni.subVectors(r, t), ri.subVectors(n, t), ii.subVectors(e, t);
          var a = ni.dot(ni),
            o = ni.dot(ri),
            s = ni.dot(ii),
            c = ri.dot(ri),
            u = ri.dot(ii),
            l = a * c - o * o;
          if (
            (void 0 === i &&
              (console.warn(
                "THREE.Triangle: .getBarycoord() target is now required"
              ),
              (i = new $n())),
            0 === l)
          )
            return i.set(-2, -1, -1);
          var h = 1 / l,
            d = (c * s - o * u) * h,
            p = (a * u - o * s) * h;
          return i.set(1 - d - p, p, d);
        },
        containsPoint: function (e, t, n, r) {
          return (
            di.getBarycoord(e, t, n, r, ai),
            ai.x >= 0 && ai.y >= 0 && ai.x + ai.y <= 1
          );
        },
        getUV: function (e, t, n, r, i, a, o, s) {
          return (
            this.getBarycoord(e, t, n, r, ai),
            s.set(0, 0),
            s.addScaledVector(i, ai.x),
            s.addScaledVector(a, ai.y),
            s.addScaledVector(o, ai.z),
            s
          );
        },
        isFrontFacing: function (e, t, n, r) {
          return (
            ni.subVectors(n, t), ri.subVectors(e, t), ni.cross(ri).dot(r) < 0
          );
        },
      }),
        Object.assign(di.prototype, {
          set: function (e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
          },
          setFromPointsAndIndices: function (e, t, n, r) {
            return (
              this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
          },
          getArea: function () {
            return (
              ni.subVectors(this.c, this.b),
              ri.subVectors(this.a, this.b),
              0.5 * ni.cross(ri).length()
            );
          },
          getMidpoint: function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Triangle: .getMidpoint() target is now required"
                ),
                (e = new $n())),
              e
                .addVectors(this.a, this.b)
                .add(this.c)
                .multiplyScalar(1 / 3)
            );
          },
          getNormal: function (e) {
            return di.getNormal(this.a, this.b, this.c, e);
          },
          getPlane: function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Triangle: .getPlane() target is now required"
                ),
                (e = new ti())),
              e.setFromCoplanarPoints(this.a, this.b, this.c)
            );
          },
          getBarycoord: function (e, t) {
            return di.getBarycoord(e, this.a, this.b, this.c, t);
          },
          getUV: function (e, t, n, r, i) {
            return di.getUV(e, this.a, this.b, this.c, t, n, r, i);
          },
          containsPoint: function (e) {
            return di.containsPoint(e, this.a, this.b, this.c);
          },
          isFrontFacing: function (e) {
            return di.isFrontFacing(this.a, this.b, this.c, e);
          },
          intersectsBox: function (e) {
            return e.intersectsTriangle(this);
          },
          closestPointToPoint: function (e, t) {
            void 0 === t &&
              (console.warn(
                "THREE.Triangle: .closestPointToPoint() target is now required"
              ),
              (t = new $n()));
            var n,
              r,
              i = this.a,
              a = this.b,
              o = this.c;
            oi.subVectors(a, i), si.subVectors(o, i), ui.subVectors(e, i);
            var s = oi.dot(ui),
              c = si.dot(ui);
            if (s <= 0 && c <= 0) return t.copy(i);
            li.subVectors(e, a);
            var u = oi.dot(li),
              l = si.dot(li);
            if (u >= 0 && l <= u) return t.copy(a);
            var h = s * l - u * c;
            if (h <= 0 && s >= 0 && u <= 0)
              return (n = s / (s - u)), t.copy(i).addScaledVector(oi, n);
            hi.subVectors(e, o);
            var d = oi.dot(hi),
              p = si.dot(hi);
            if (p >= 0 && d <= p) return t.copy(o);
            var f = d * c - s * p;
            if (f <= 0 && c >= 0 && p <= 0)
              return (r = c / (c - p)), t.copy(i).addScaledVector(si, r);
            var m = u * p - d * l;
            if (m <= 0 && l - u >= 0 && d - p >= 0)
              return (
                ci.subVectors(o, a),
                (r = (l - u) / (l - u + (d - p))),
                t.copy(a).addScaledVector(ci, r)
              );
            var v = 1 / (m + f + h);
            return (
              (n = f * v),
              (r = h * v),
              t.copy(i).addScaledVector(oi, n).addScaledVector(si, r)
            );
          },
          equals: function (e) {
            return (
              e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            );
          },
        });
      var pi = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        fi = { h: 0, s: 0, l: 0 },
        mi = { h: 0, s: 0, l: 0 };
      function vi(e, t, n) {
        return void 0 === t && void 0 === n
          ? this.set(e)
          : this.setRGB(e, t, n);
      }
      function gi(e, t, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? e + 6 * (t - e) * n
            : n < 0.5
            ? t
            : n < 2 / 3
            ? e + 6 * (t - e) * (2 / 3 - n)
            : e
        );
      }
      function yi(e) {
        return e < 0.04045
          ? 0.0773993808 * e
          : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
      }
      function xi(e) {
        return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
      }
      function bi(e, t, n, r, i, a) {
        (this.a = e),
          (this.b = t),
          (this.c = n),
          (this.normal = r && r.isVector3 ? r : new $n()),
          (this.vertexNormals = Array.isArray(r) ? r : []),
          (this.color = i && i.isColor ? i : new vi()),
          (this.vertexColors = Array.isArray(i) ? i : []),
          (this.materialIndex = void 0 !== a ? a : 0);
      }
      Object.assign(vi.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function (e) {
          return (
            e && e.isColor
              ? this.copy(e)
              : "number" == typeof e
              ? this.setHex(e)
              : "string" == typeof e && this.setStyle(e),
            this
          );
        },
        setScalar: function (e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        },
        setHex: function (e) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (255 & e) / 255),
            this
          );
        },
        setRGB: function (e, t, n) {
          return (this.r = e), (this.g = t), (this.b = n), this;
        },
        setHSL: function (e, t, n) {
          if (
            ((e = kn.euclideanModulo(e, 1)),
            (t = kn.clamp(t, 0, 1)),
            (n = kn.clamp(n, 0, 1)),
            0 === t)
          )
            this.r = this.g = this.b = n;
          else {
            var r = n <= 0.5 ? n * (1 + t) : n + t - n * t,
              i = 2 * n - r;
            (this.r = gi(i, r, e + 1 / 3)),
              (this.g = gi(i, r, e)),
              (this.b = gi(i, r, e - 1 / 3));
          }
          return this;
        },
        setStyle: function (e) {
          function t(t) {
            void 0 !== t &&
              parseFloat(t) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          var n;
          if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e))) {
            var r,
              i = n[2];
            switch (n[1]) {
              case "rgb":
              case "rgba":
                if (
                  (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    i
                  ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(r[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(r[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(r[3], 10)) / 255),
                    t(r[5]),
                    this
                  );
                if (
                  (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    i
                  ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(r[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(r[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(r[3], 10)) / 100),
                    t(r[5]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    i
                  ))
                ) {
                  var a = parseFloat(r[1]) / 360,
                    o = parseInt(r[2], 10) / 100,
                    s = parseInt(r[3], 10) / 100;
                  return t(r[5]), this.setHSL(a, o, s);
                }
            }
          } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(e))) {
            var c = n[1],
              u = c.length;
            if (3 === u)
              return (
                (this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255),
                (this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255),
                (this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255),
                this
              );
            if (6 === u)
              return (
                (this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255),
                (this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255),
                (this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255),
                this
              );
          }
          return e && e.length > 0 ? this.setColorName(e) : this;
        },
        setColorName: function (e) {
          var t = pi[e];
          return (
            void 0 !== t
              ? this.setHex(t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        },
        clone: function () {
          return new this.constructor(this.r, this.g, this.b);
        },
        copy: function (e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        },
        copyGammaToLinear: function (e, t) {
          return (
            void 0 === t && (t = 2),
            (this.r = Math.pow(e.r, t)),
            (this.g = Math.pow(e.g, t)),
            (this.b = Math.pow(e.b, t)),
            this
          );
        },
        copyLinearToGamma: function (e, t) {
          void 0 === t && (t = 2);
          var n = t > 0 ? 1 / t : 1;
          return (
            (this.r = Math.pow(e.r, n)),
            (this.g = Math.pow(e.g, n)),
            (this.b = Math.pow(e.b, n)),
            this
          );
        },
        convertGammaToLinear: function (e) {
          return this.copyGammaToLinear(this, e), this;
        },
        convertLinearToGamma: function (e) {
          return this.copyLinearToGamma(this, e), this;
        },
        copySRGBToLinear: function (e) {
          return (
            (this.r = yi(e.r)), (this.g = yi(e.g)), (this.b = yi(e.b)), this
          );
        },
        copyLinearToSRGB: function (e) {
          return (
            (this.r = xi(e.r)), (this.g = xi(e.g)), (this.b = xi(e.b)), this
          );
        },
        convertSRGBToLinear: function () {
          return this.copySRGBToLinear(this), this;
        },
        convertLinearToSRGB: function () {
          return this.copyLinearToSRGB(this), this;
        },
        getHex: function () {
          return (
            ((255 * this.r) << 16) ^
            ((255 * this.g) << 8) ^
            ((255 * this.b) << 0)
          );
        },
        getHexString: function () {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        },
        getHSL: function (e) {
          void 0 === e &&
            (console.warn("THREE.Color: .getHSL() target is now required"),
            (e = { h: 0, s: 0, l: 0 }));
          var t,
            n,
            r = this.r,
            i = this.g,
            a = this.b,
            o = Math.max(r, i, a),
            s = Math.min(r, i, a),
            c = (s + o) / 2;
          if (s === o) (t = 0), (n = 0);
          else {
            var u = o - s;
            switch (((n = c <= 0.5 ? u / (o + s) : u / (2 - o - s)), o)) {
              case r:
                t = (i - a) / u + (i < a ? 6 : 0);
                break;
              case i:
                t = (a - r) / u + 2;
                break;
              case a:
                t = (r - i) / u + 4;
            }
            t /= 6;
          }
          return (e.h = t), (e.s = n), (e.l = c), e;
        },
        getStyle: function () {
          return (
            "rgb(" +
            ((255 * this.r) | 0) +
            "," +
            ((255 * this.g) | 0) +
            "," +
            ((255 * this.b) | 0) +
            ")"
          );
        },
        offsetHSL: function (e, t, n) {
          return (
            this.getHSL(fi),
            (fi.h += e),
            (fi.s += t),
            (fi.l += n),
            this.setHSL(fi.h, fi.s, fi.l),
            this
          );
        },
        add: function (e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        },
        addColors: function (e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        },
        addScalar: function (e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        },
        sub: function (e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        },
        multiply: function (e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        },
        multiplyScalar: function (e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        },
        lerp: function (e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        },
        lerpHSL: function (e, t) {
          this.getHSL(fi), e.getHSL(mi);
          var n = kn.lerp(fi.h, mi.h, t),
            r = kn.lerp(fi.s, mi.s, t),
            i = kn.lerp(fi.l, mi.l, t);
          return this.setHSL(n, r, i), this;
        },
        equals: function (e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        },
        fromArray: function (e, t) {
          return (
            void 0 === t && (t = 0),
            (this.r = e[t]),
            (this.g = e[t + 1]),
            (this.b = e[t + 2]),
            this
          );
        },
        toArray: function (e, t) {
          return (
            void 0 === e && (e = []),
            void 0 === t && (t = 0),
            (e[t] = this.r),
            (e[t + 1] = this.g),
            (e[t + 2] = this.b),
            e
          );
        },
        fromBufferAttribute: function (e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            !0 === e.normalized &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        },
        toJSON: function () {
          return this.getHex();
        },
      }),
        (vi.NAMES = pi),
        Object.assign(bi.prototype, {
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            (this.a = e.a),
              (this.b = e.b),
              (this.c = e.c),
              this.normal.copy(e.normal),
              this.color.copy(e.color),
              (this.materialIndex = e.materialIndex);
            for (var t = 0, n = e.vertexNormals.length; t < n; t++)
              this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (var r = 0, i = e.vertexColors.length; r < i; r++)
              this.vertexColors[r] = e.vertexColors[r].clone();
            return this;
          },
        });
      var _i = 0;
      function wi() {
        Object.defineProperty(this, "id", { value: _i++ }),
          (this.uuid = kn.generateUUID()),
          (this.name = ""),
          (this.type = "Material"),
          (this.fog = !0),
          (this.blending = M),
          (this.side = g),
          (this.flatShading = !1),
          (this.vertexColors = !1),
          (this.opacity = 1),
          (this.transparent = !1),
          (this.blendSrc = z),
          (this.blendDst = F),
          (this.blendEquation = L),
          (this.blendSrcAlpha = null),
          (this.blendDstAlpha = null),
          (this.blendEquationAlpha = null),
          (this.depthFunc = X),
          (this.depthTest = !0),
          (this.depthWrite = !0),
          (this.stencilWriteMask = 255),
          (this.stencilFunc = An),
          (this.stencilRef = 0),
          (this.stencilFuncMask = 255),
          (this.stencilFail = pn),
          (this.stencilZFail = pn),
          (this.stencilZPass = pn),
          (this.stencilWrite = !1),
          (this.clippingPlanes = null),
          (this.clipIntersection = !1),
          (this.clipShadows = !1),
          (this.shadowSide = null),
          (this.colorWrite = !0),
          (this.precision = null),
          (this.polygonOffset = !1),
          (this.polygonOffsetFactor = 0),
          (this.polygonOffsetUnits = 0),
          (this.dithering = !1),
          (this.alphaTest = 0),
          (this.premultipliedAlpha = !1),
          (this.visible = !0),
          (this.toneMapped = !0),
          (this.userData = {}),
          (this.version = 0);
      }
      function Mi(e) {
        wi.call(this),
          (this.type = "MeshBasicMaterial"),
          (this.color = new vi(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Q),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          this.setValues(e);
      }
      (wi.prototype = Object.assign(Object.create(zn.prototype), {
        constructor: wi,
        isMaterial: !0,
        onBeforeCompile: function () {},
        customProgramCacheKey: function () {
          return this.onBeforeCompile.toString();
        },
        setValues: function (e) {
          if (void 0 !== e)
            for (var t in e) {
              var n = e[t];
              if (void 0 !== n)
                if ("shading" !== t) {
                  var r = this[t];
                  void 0 !== r
                    ? r && r.isColor
                      ? r.set(n)
                      : r && r.isVector3 && n && n.isVector3
                      ? r.copy(n)
                      : (this[t] = n)
                    : console.warn(
                        "THREE." +
                          this.type +
                          ": '" +
                          t +
                          "' is not a property of this material."
                      );
                } else
                  console.warn(
                    "THREE." +
                      this.type +
                      ": .shading has been removed. Use the boolean .flatShading instead."
                  ),
                    (this.flatShading = n === b);
              else
                console.warn(
                  "THREE.Material: '" + t + "' parameter is undefined."
                );
            }
        },
        toJSON: function (e) {
          var t = void 0 === e || "string" == typeof e;
          t && (e = { textures: {}, images: {} });
          var n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function r(e) {
            var t = [];
            for (var n in e) {
              var r = e[n];
              delete r.metadata, t.push(r);
            }
            return t;
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(
                e
              ).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              (n.lightMap = this.lightMap.toJSON(e).uuid),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(e).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(e).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(e).uuid),
              (n.reflectivity = this.reflectivity),
              (n.refractionRatio = this.refractionRatio),
              void 0 !== this.combine && (n.combine = this.combine),
              void 0 !== this.envMapIntensity &&
                (n.envMapIntensity = this.envMapIntensity)),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.size && (n.size = this.size),
            void 0 !== this.sizeAttenuation &&
              (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== M && (n.blending = this.blending),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            this.side !== g && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            this.rotation &&
              0 !== this.rotation &&
              (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth &&
              1 !== this.linewidth &&
              (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (n.morphTargets = !0),
            !0 === this.morphNormals && (n.morphNormals = !0),
            !0 === this.skinning && (n.skinning = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) &&
              (n.userData = this.userData),
            t)
          ) {
            var i = r(e.textures),
              a = r(e.images);
            i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a);
          }
          return n;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (e) {
          (this.name = e.name),
            (this.fog = e.fog),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.flatShading = e.flatShading),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          var t = e.clippingPlanes,
            n = null;
          if (null !== t) {
            var r = t.length;
            n = new Array(r);
            for (var i = 0; i !== r; ++i) n[i] = t[i].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      })),
        Object.defineProperty(wi.prototype, "needsUpdate", {
          set: function (e) {
            !0 === e && this.version++;
          },
        }),
        ((Mi.prototype = Object.create(wi.prototype)).constructor = Mi),
        (Mi.prototype.isMeshBasicMaterial = !0),
        (Mi.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            this
          );
        });
      var Si = new $n(),
        Ti = new Hn();
      function Ei(e, t, n) {
        if (Array.isArray(e))
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array."
          );
        (this.name = ""),
          (this.array = e),
          (this.itemSize = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.normalized = !0 === n),
          (this.usage = Ln),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0);
      }
      function Ai(e, t, n) {
        Ei.call(this, new Int8Array(e), t, n);
      }
      function Li(e, t, n) {
        Ei.call(this, new Uint8Array(e), t, n);
      }
      function Ci(e, t, n) {
        Ei.call(this, new Uint8ClampedArray(e), t, n);
      }
      function Ri(e, t, n) {
        Ei.call(this, new Int16Array(e), t, n);
      }
      function Pi(e, t, n) {
        Ei.call(this, new Uint16Array(e), t, n);
      }
      function Oi(e, t, n) {
        Ei.call(this, new Int32Array(e), t, n);
      }
      function Di(e, t, n) {
        Ei.call(this, new Uint32Array(e), t, n);
      }
      function Ii(e, t, n) {
        Ei.call(this, new Float32Array(e), t, n);
      }
      function Ni(e, t, n) {
        Ei.call(this, new Float64Array(e), t, n);
      }
      function Bi() {
        (this.vertices = []),
          (this.normals = []),
          (this.colors = []),
          (this.uvs = []),
          (this.uvs2 = []),
          (this.groups = []),
          (this.morphTargets = {}),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.verticesNeedUpdate = !1),
          (this.normalsNeedUpdate = !1),
          (this.colorsNeedUpdate = !1),
          (this.uvsNeedUpdate = !1),
          (this.groupsNeedUpdate = !1);
      }
      function zi(e) {
        if (0 === e.length) return -1 / 0;
        for (var t = e[0], n = 1, r = e.length; n < r; ++n)
          e[n] > t && (t = e[n]);
        return t;
      }
      Object.defineProperty(Ei.prototype, "needsUpdate", {
        set: function (e) {
          !0 === e && this.version++;
        },
      }),
        Object.assign(Ei.prototype, {
          isBufferAttribute: !0,
          onUploadCallback: function () {},
          setUsage: function (e) {
            return (this.usage = e), this;
          },
          copy: function (e) {
            return (
              (this.name = e.name),
              (this.array = new e.array.constructor(e.array)),
              (this.itemSize = e.itemSize),
              (this.count = e.count),
              (this.normalized = e.normalized),
              (this.usage = e.usage),
              this
            );
          },
          copyAt: function (e, t, n) {
            (e *= this.itemSize), (n *= t.itemSize);
            for (var r = 0, i = this.itemSize; r < i; r++)
              this.array[e + r] = t.array[n + r];
            return this;
          },
          copyArray: function (e) {
            return this.array.set(e), this;
          },
          copyColorsArray: function (e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
              var a = e[r];
              void 0 === a &&
                (console.warn(
                  "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                  r
                ),
                (a = new vi())),
                (t[n++] = a.r),
                (t[n++] = a.g),
                (t[n++] = a.b);
            }
            return this;
          },
          copyVector2sArray: function (e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
              var a = e[r];
              void 0 === a &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                  r
                ),
                (a = new Hn())),
                (t[n++] = a.x),
                (t[n++] = a.y);
            }
            return this;
          },
          copyVector3sArray: function (e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
              var a = e[r];
              void 0 === a &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                  r
                ),
                (a = new $n())),
                (t[n++] = a.x),
                (t[n++] = a.y),
                (t[n++] = a.z);
            }
            return this;
          },
          copyVector4sArray: function (e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
              var a = e[r];
              void 0 === a &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                  r
                ),
                (a = new Xn())),
                (t[n++] = a.x),
                (t[n++] = a.y),
                (t[n++] = a.z),
                (t[n++] = a.w);
            }
            return this;
          },
          applyMatrix3: function (e) {
            if (2 === this.itemSize)
              for (var t = 0, n = this.count; t < n; t++)
                Ti.fromBufferAttribute(this, t),
                  Ti.applyMatrix3(e),
                  this.setXY(t, Ti.x, Ti.y);
            else if (3 === this.itemSize)
              for (var r = 0, i = this.count; r < i; r++)
                Si.fromBufferAttribute(this, r),
                  Si.applyMatrix3(e),
                  this.setXYZ(r, Si.x, Si.y, Si.z);
            return this;
          },
          applyMatrix4: function (e) {
            for (var t = 0, n = this.count; t < n; t++)
              (Si.x = this.getX(t)),
                (Si.y = this.getY(t)),
                (Si.z = this.getZ(t)),
                Si.applyMatrix4(e),
                this.setXYZ(t, Si.x, Si.y, Si.z);
            return this;
          },
          applyNormalMatrix: function (e) {
            for (var t = 0, n = this.count; t < n; t++)
              (Si.x = this.getX(t)),
                (Si.y = this.getY(t)),
                (Si.z = this.getZ(t)),
                Si.applyNormalMatrix(e),
                this.setXYZ(t, Si.x, Si.y, Si.z);
            return this;
          },
          transformDirection: function (e) {
            for (var t = 0, n = this.count; t < n; t++)
              (Si.x = this.getX(t)),
                (Si.y = this.getY(t)),
                (Si.z = this.getZ(t)),
                Si.transformDirection(e),
                this.setXYZ(t, Si.x, Si.y, Si.z);
            return this;
          },
          set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this;
          },
          getX: function (e) {
            return this.array[e * this.itemSize];
          },
          setX: function (e, t) {
            return (this.array[e * this.itemSize] = t), this;
          },
          getY: function (e) {
            return this.array[e * this.itemSize + 1];
          },
          setY: function (e, t) {
            return (this.array[e * this.itemSize + 1] = t), this;
          },
          getZ: function (e) {
            return this.array[e * this.itemSize + 2];
          },
          setZ: function (e, t) {
            return (this.array[e * this.itemSize + 2] = t), this;
          },
          getW: function (e) {
            return this.array[e * this.itemSize + 3];
          },
          setW: function (e, t) {
            return (this.array[e * this.itemSize + 3] = t), this;
          },
          setXY: function (e, t, n) {
            return (
              (this.array[0 + (e *= this.itemSize)] = t),
              (this.array[e + 1] = n),
              this
            );
          },
          setXYZ: function (e, t, n, r) {
            return (
              (this.array[0 + (e *= this.itemSize)] = t),
              (this.array[e + 1] = n),
              (this.array[e + 2] = r),
              this
            );
          },
          setXYZW: function (e, t, n, r, i) {
            return (
              (this.array[0 + (e *= this.itemSize)] = t),
              (this.array[e + 1] = n),
              (this.array[e + 2] = r),
              (this.array[e + 3] = i),
              this
            );
          },
          onUpload: function (e) {
            return (this.onUploadCallback = e), this;
          },
          clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this);
          },
          toJSON: function () {
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.prototype.slice.call(this.array),
              normalized: this.normalized,
            };
          },
        }),
        ((Ai.prototype = Object.create(Ei.prototype)).constructor = Ai),
        ((Li.prototype = Object.create(Ei.prototype)).constructor = Li),
        ((Ci.prototype = Object.create(Ei.prototype)).constructor = Ci),
        ((Ri.prototype = Object.create(Ei.prototype)).constructor = Ri),
        ((Pi.prototype = Object.create(Ei.prototype)).constructor = Pi),
        ((Oi.prototype = Object.create(Ei.prototype)).constructor = Oi),
        ((Di.prototype = Object.create(Ei.prototype)).constructor = Di),
        ((Ii.prototype = Object.create(Ei.prototype)).constructor = Ii),
        ((Ni.prototype = Object.create(Ei.prototype)).constructor = Ni),
        Object.assign(Bi.prototype, {
          computeGroups: function (e) {
            var t,
              n,
              r = [],
              i = void 0,
              a = e.faces;
            for (n = 0; n < a.length; n++) {
              var o = a[n];
              o.materialIndex !== i &&
                ((i = o.materialIndex),
                void 0 !== t && ((t.count = 3 * n - t.start), r.push(t)),
                (t = { start: 3 * n, materialIndex: i }));
            }
            void 0 !== t && ((t.count = 3 * n - t.start), r.push(t)),
              (this.groups = r);
          },
          fromGeometry: function (e) {
            var t,
              n = e.faces,
              r = e.vertices,
              i = e.faceVertexUvs,
              a = i[0] && i[0].length > 0,
              o = i[1] && i[1].length > 0,
              s = e.morphTargets,
              c = s.length;
            if (c > 0) {
              t = [];
              for (var u = 0; u < c; u++) t[u] = { name: s[u].name, data: [] };
              this.morphTargets.position = t;
            }
            var l,
              h = e.morphNormals,
              d = h.length;
            if (d > 0) {
              l = [];
              for (var p = 0; p < d; p++) l[p] = { name: h[p].name, data: [] };
              this.morphTargets.normal = l;
            }
            var f = e.skinIndices,
              m = e.skinWeights,
              v = f.length === r.length,
              g = m.length === r.length;
            r.length > 0 &&
              0 === n.length &&
              console.error(
                "THREE.DirectGeometry: Faceless geometries are not supported."
              );
            for (var y = 0; y < n.length; y++) {
              var x = n[y];
              this.vertices.push(r[x.a], r[x.b], r[x.c]);
              var b = x.vertexNormals;
              if (3 === b.length) this.normals.push(b[0], b[1], b[2]);
              else {
                var _ = x.normal;
                this.normals.push(_, _, _);
              }
              var w = x.vertexColors;
              if (3 === w.length) this.colors.push(w[0], w[1], w[2]);
              else {
                var M = x.color;
                this.colors.push(M, M, M);
              }
              if (!0 === a) {
                var S = i[0][y];
                void 0 !== S
                  ? this.uvs.push(S[0], S[1], S[2])
                  : (console.warn(
                      "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                      y
                    ),
                    this.uvs.push(new Hn(), new Hn(), new Hn()));
              }
              if (!0 === o) {
                var T = i[1][y];
                void 0 !== T
                  ? this.uvs2.push(T[0], T[1], T[2])
                  : (console.warn(
                      "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                      y
                    ),
                    this.uvs2.push(new Hn(), new Hn(), new Hn()));
              }
              for (var E = 0; E < c; E++) {
                var A = s[E].vertices;
                t[E].data.push(A[x.a], A[x.b], A[x.c]);
              }
              for (var L = 0; L < d; L++) {
                var C = h[L].vertexNormals[y];
                l[L].data.push(C.a, C.b, C.c);
              }
              v && this.skinIndices.push(f[x.a], f[x.b], f[x.c]),
                g && this.skinWeights.push(m[x.a], m[x.b], m[x.c]);
            }
            return (
              this.computeGroups(e),
              (this.verticesNeedUpdate = e.verticesNeedUpdate),
              (this.normalsNeedUpdate = e.normalsNeedUpdate),
              (this.colorsNeedUpdate = e.colorsNeedUpdate),
              (this.uvsNeedUpdate = e.uvsNeedUpdate),
              (this.groupsNeedUpdate = e.groupsNeedUpdate),
              null !== e.boundingSphere &&
                (this.boundingSphere = e.boundingSphere.clone()),
              null !== e.boundingBox &&
                (this.boundingBox = e.boundingBox.clone()),
              this
            );
          },
        });
      var Fi = 1,
        Ui = new sr(),
        Gi = new Tr(),
        ki = new $n(),
        Hi = new Gr(),
        ji = new Gr(),
        Vi = new $n();
      function Wi() {
        Object.defineProperty(this, "id", { value: (Fi += 2) }),
          (this.uuid = kn.generateUUID()),
          (this.name = ""),
          (this.type = "BufferGeometry"),
          (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.morphTargetsRelative = !1),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.drawRange = { start: 0, count: 1 / 0 }),
          (this.userData = {});
      }
      Wi.prototype = Object.assign(Object.create(zn.prototype), {
        constructor: Wi,
        isBufferGeometry: !0,
        getIndex: function () {
          return this.index;
        },
        setIndex: function (e) {
          this.index = Array.isArray(e)
            ? new (zi(e) > 65535 ? Di : Pi)(e, 1)
            : e;
        },
        getAttribute: function (e) {
          return this.attributes[e];
        },
        setAttribute: function (e, t) {
          return (this.attributes[e] = t), this;
        },
        deleteAttribute: function (e) {
          return delete this.attributes[e], this;
        },
        addGroup: function (e, t, n) {
          this.groups.push({
            start: e,
            count: t,
            materialIndex: void 0 !== n ? n : 0,
          });
        },
        clearGroups: function () {
          this.groups = [];
        },
        setDrawRange: function (e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        },
        applyMatrix4: function (e) {
          var t = this.attributes.position;
          void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
          var n = this.attributes.normal;
          if (void 0 !== n) {
            var r = new jn().getNormalMatrix(e);
            n.applyNormalMatrix(r), (n.needsUpdate = !0);
          }
          var i = this.attributes.tangent;
          return (
            void 0 !== i && (i.transformDirection(e), (i.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        },
        rotateX: function (e) {
          return Ui.makeRotationX(e), this.applyMatrix4(Ui), this;
        },
        rotateY: function (e) {
          return Ui.makeRotationY(e), this.applyMatrix4(Ui), this;
        },
        rotateZ: function (e) {
          return Ui.makeRotationZ(e), this.applyMatrix4(Ui), this;
        },
        translate: function (e, t, n) {
          return Ui.makeTranslation(e, t, n), this.applyMatrix4(Ui), this;
        },
        scale: function (e, t, n) {
          return Ui.makeScale(e, t, n), this.applyMatrix4(Ui), this;
        },
        lookAt: function (e) {
          return (
            Gi.lookAt(e), Gi.updateMatrix(), this.applyMatrix4(Gi.matrix), this
          );
        },
        center: function () {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(ki).negate(),
            this.translate(ki.x, ki.y, ki.z),
            this
          );
        },
        setFromObject: function (e) {
          var t = e.geometry;
          if (e.isPoints || e.isLine) {
            var n = new Ii(3 * t.vertices.length, 3),
              r = new Ii(3 * t.colors.length, 3);
            if (
              (this.setAttribute("position", n.copyVector3sArray(t.vertices)),
              this.setAttribute("color", r.copyColorsArray(t.colors)),
              t.lineDistances && t.lineDistances.length === t.vertices.length)
            ) {
              var i = new Ii(t.lineDistances.length, 1);
              this.setAttribute("lineDistance", i.copyArray(t.lineDistances));
            }
            null !== t.boundingSphere &&
              (this.boundingSphere = t.boundingSphere.clone()),
              null !== t.boundingBox &&
                (this.boundingBox = t.boundingBox.clone());
          } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
          return this;
        },
        setFromPoints: function (e) {
          for (var t = [], n = 0, r = e.length; n < r; n++) {
            var i = e[n];
            t.push(i.x, i.y, i.z || 0);
          }
          return this.setAttribute("position", new Ii(t, 3)), this;
        },
        updateFromObject: function (e) {
          var t = e.geometry;
          if (e.isMesh) {
            var n = t.__directGeometry;
            if (
              (!0 === t.elementsNeedUpdate &&
                ((n = void 0), (t.elementsNeedUpdate = !1)),
              void 0 === n)
            )
              return this.fromGeometry(t);
            (n.verticesNeedUpdate = t.verticesNeedUpdate),
              (n.normalsNeedUpdate = t.normalsNeedUpdate),
              (n.colorsNeedUpdate = t.colorsNeedUpdate),
              (n.uvsNeedUpdate = t.uvsNeedUpdate),
              (n.groupsNeedUpdate = t.groupsNeedUpdate),
              (t.verticesNeedUpdate = !1),
              (t.normalsNeedUpdate = !1),
              (t.colorsNeedUpdate = !1),
              (t.uvsNeedUpdate = !1),
              (t.groupsNeedUpdate = !1),
              (t = n);
          }
          if (!0 === t.verticesNeedUpdate) {
            var r = this.attributes.position;
            void 0 !== r &&
              (r.copyVector3sArray(t.vertices), (r.needsUpdate = !0)),
              (t.verticesNeedUpdate = !1);
          }
          if (!0 === t.normalsNeedUpdate) {
            var i = this.attributes.normal;
            void 0 !== i &&
              (i.copyVector3sArray(t.normals), (i.needsUpdate = !0)),
              (t.normalsNeedUpdate = !1);
          }
          if (!0 === t.colorsNeedUpdate) {
            var a = this.attributes.color;
            void 0 !== a && (a.copyColorsArray(t.colors), (a.needsUpdate = !0)),
              (t.colorsNeedUpdate = !1);
          }
          if (t.uvsNeedUpdate) {
            var o = this.attributes.uv;
            void 0 !== o && (o.copyVector2sArray(t.uvs), (o.needsUpdate = !0)),
              (t.uvsNeedUpdate = !1);
          }
          if (t.lineDistancesNeedUpdate) {
            var s = this.attributes.lineDistance;
            void 0 !== s &&
              (s.copyArray(t.lineDistances), (s.needsUpdate = !0)),
              (t.lineDistancesNeedUpdate = !1);
          }
          return (
            t.groupsNeedUpdate &&
              (t.computeGroups(e.geometry),
              (this.groups = t.groups),
              (t.groupsNeedUpdate = !1)),
            this
          );
        },
        fromGeometry: function (e) {
          return (
            (e.__directGeometry = new Bi().fromGeometry(e)),
            this.fromDirectGeometry(e.__directGeometry)
          );
        },
        fromDirectGeometry: function (e) {
          var t = new Float32Array(3 * e.vertices.length);
          if (
            (this.setAttribute(
              "position",
              new Ei(t, 3).copyVector3sArray(e.vertices)
            ),
            e.normals.length > 0)
          ) {
            var n = new Float32Array(3 * e.normals.length);
            this.setAttribute(
              "normal",
              new Ei(n, 3).copyVector3sArray(e.normals)
            );
          }
          if (e.colors.length > 0) {
            var r = new Float32Array(3 * e.colors.length);
            this.setAttribute("color", new Ei(r, 3).copyColorsArray(e.colors));
          }
          if (e.uvs.length > 0) {
            var i = new Float32Array(2 * e.uvs.length);
            this.setAttribute("uv", new Ei(i, 2).copyVector2sArray(e.uvs));
          }
          if (e.uvs2.length > 0) {
            var a = new Float32Array(2 * e.uvs2.length);
            this.setAttribute("uv2", new Ei(a, 2).copyVector2sArray(e.uvs2));
          }
          for (var o in ((this.groups = e.groups), e.morphTargets)) {
            for (
              var s = [], c = e.morphTargets[o], u = 0, l = c.length;
              u < l;
              u++
            ) {
              var h = c[u],
                d = new Ii(3 * h.data.length, 3);
              (d.name = h.name), s.push(d.copyVector3sArray(h.data));
            }
            this.morphAttributes[o] = s;
          }
          if (e.skinIndices.length > 0) {
            var p = new Ii(4 * e.skinIndices.length, 4);
            this.setAttribute("skinIndex", p.copyVector4sArray(e.skinIndices));
          }
          if (e.skinWeights.length > 0) {
            var f = new Ii(4 * e.skinWeights.length, 4);
            this.setAttribute("skinWeight", f.copyVector4sArray(e.skinWeights));
          }
          return (
            null !== e.boundingSphere &&
              (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone()),
            this
          );
        },
        computeBoundingBox: function () {
          null === this.boundingBox && (this.boundingBox = new Gr());
          var e = this.attributes.position,
            t = this.morphAttributes.position;
          if (void 0 !== e) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (var n = 0, r = t.length; n < r; n++)
                Hi.setFromBufferAttribute(t[n]),
                  this.morphTargetsRelative
                    ? (Vi.addVectors(this.boundingBox.min, Hi.min),
                      this.boundingBox.expandByPoint(Vi),
                      Vi.addVectors(this.boundingBox.max, Hi.max),
                      this.boundingBox.expandByPoint(Vi))
                    : (this.boundingBox.expandByPoint(Hi.min),
                      this.boundingBox.expandByPoint(Hi.max));
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        },
        computeBoundingSphere: function () {
          null === this.boundingSphere && (this.boundingSphere = new jr());
          var e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e) {
            var n = this.boundingSphere.center;
            if ((Hi.setFromBufferAttribute(e), t))
              for (var r = 0, i = t.length; r < i; r++)
                ji.setFromBufferAttribute(t[r]),
                  this.morphTargetsRelative
                    ? (Vi.addVectors(Hi.min, ji.min),
                      Hi.expandByPoint(Vi),
                      Vi.addVectors(Hi.max, ji.max),
                      Hi.expandByPoint(Vi))
                    : (Hi.expandByPoint(ji.min), Hi.expandByPoint(ji.max));
            Hi.getCenter(n);
            for (var a = 0, o = 0, s = e.count; o < s; o++)
              Vi.fromBufferAttribute(e, o),
                (a = Math.max(a, n.distanceToSquared(Vi)));
            if (t)
              for (var c = 0, u = t.length; c < u; c++)
                for (
                  var l = t[c],
                    h = this.morphTargetsRelative,
                    d = 0,
                    p = l.count;
                  d < p;
                  d++
                )
                  Vi.fromBufferAttribute(l, d),
                    h && (ki.fromBufferAttribute(e, d), Vi.add(ki)),
                    (a = Math.max(a, n.distanceToSquared(Vi)));
            (this.boundingSphere.radius = Math.sqrt(a)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        },
        computeFaceNormals: function () {},
        computeVertexNormals: function () {
          var e = this.index,
            t = this.getAttribute("position");
          if (void 0 !== t) {
            var n = this.getAttribute("normal");
            if (void 0 === n)
              (n = new Ei(new Float32Array(3 * t.count), 3)),
                this.setAttribute("normal", n);
            else for (var r = 0, i = n.count; r < i; r++) n.setXYZ(r, 0, 0, 0);
            var a = new $n(),
              o = new $n(),
              s = new $n(),
              c = new $n(),
              u = new $n(),
              l = new $n(),
              h = new $n(),
              d = new $n();
            if (e)
              for (var p = 0, f = e.count; p < f; p += 3) {
                var m = e.getX(p + 0),
                  v = e.getX(p + 1),
                  g = e.getX(p + 2);
                a.fromBufferAttribute(t, m),
                  o.fromBufferAttribute(t, v),
                  s.fromBufferAttribute(t, g),
                  h.subVectors(s, o),
                  d.subVectors(a, o),
                  h.cross(d),
                  c.fromBufferAttribute(n, m),
                  u.fromBufferAttribute(n, v),
                  l.fromBufferAttribute(n, g),
                  c.add(h),
                  u.add(h),
                  l.add(h),
                  n.setXYZ(m, c.x, c.y, c.z),
                  n.setXYZ(v, u.x, u.y, u.z),
                  n.setXYZ(g, l.x, l.y, l.z);
              }
            else
              for (var y = 0, x = t.count; y < x; y += 3)
                a.fromBufferAttribute(t, y + 0),
                  o.fromBufferAttribute(t, y + 1),
                  s.fromBufferAttribute(t, y + 2),
                  h.subVectors(s, o),
                  d.subVectors(a, o),
                  h.cross(d),
                  n.setXYZ(y + 0, h.x, h.y, h.z),
                  n.setXYZ(y + 1, h.x, h.y, h.z),
                  n.setXYZ(y + 2, h.x, h.y, h.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        },
        merge: function (e, t) {
          if (e && e.isBufferGeometry) {
            void 0 === t &&
              ((t = 0),
              console.warn(
                "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
              ));
            var n = this.attributes;
            for (var r in n)
              if (void 0 !== e.attributes[r])
                for (
                  var i = n[r].array,
                    a = e.attributes[r],
                    o = a.array,
                    s = a.itemSize * t,
                    c = Math.min(o.length, i.length - s),
                    u = 0,
                    l = s;
                  u < c;
                  u++, l++
                )
                  i[l] = o[u];
            return this;
          }
          console.error(
            "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
            e
          );
        },
        normalizeNormals: function () {
          for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++)
            Vi.fromBufferAttribute(e, t),
              Vi.normalize(),
              e.setXYZ(t, Vi.x, Vi.y, Vi.z);
        },
        toNonIndexed: function () {
          function e(e, t) {
            for (
              var n = e.array,
                r = e.itemSize,
                i = e.normalized,
                a = new n.constructor(t.length * r),
                o = 0,
                s = 0,
                c = 0,
                u = t.length;
              c < u;
              c++
            ) {
              o = t[c] * r;
              for (var l = 0; l < r; l++) a[s++] = n[o++];
            }
            return new Ei(a, r, i);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
              ),
              this
            );
          var t = new Wi(),
            n = this.index.array,
            r = this.attributes;
          for (var i in r) {
            var a = e(r[i], n);
            t.setAttribute(i, a);
          }
          var o = this.morphAttributes;
          for (var s in o) {
            for (var c = [], u = o[s], l = 0, h = u.length; l < h; l++) {
              var d = e(u[l], n);
              c.push(d);
            }
            t.morphAttributes[s] = c;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          for (var p = this.groups, f = 0, m = p.length; f < m; f++) {
            var v = p[f];
            t.addGroup(v.start, v.count, v.materialIndex);
          }
          return t;
        },
        toJSON: function () {
          var e = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            var t = this.parameters;
            for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
            return e;
          }
          e.data = { attributes: {} };
          var r = this.index;
          null !== r &&
            (e.data.index = {
              type: r.array.constructor.name,
              array: Array.prototype.slice.call(r.array),
            });
          var i = this.attributes;
          for (var a in i) {
            var o = i[a],
              s = o.toJSON(e.data);
            "" !== o.name && (s.name = o.name), (e.data.attributes[a] = s);
          }
          var c = {},
            u = !1;
          for (var l in this.morphAttributes) {
            for (
              var h = this.morphAttributes[l], d = [], p = 0, f = h.length;
              p < f;
              p++
            ) {
              var m = h[p],
                v = m.toJSON(e.data);
              "" !== m.name && (v.name = m.name), d.push(v);
            }
            d.length > 0 && ((c[l] = d), (u = !0));
          }
          u &&
            ((e.data.morphAttributes = c),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          var g = this.groups;
          g.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(g)));
          var y = this.boundingSphere;
          return (
            null !== y &&
              (e.data.boundingSphere = {
                center: y.center.toArray(),
                radius: y.radius,
              }),
            e
          );
        },
        clone: function () {
          return new Wi().copy(this);
        },
        copy: function (e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          var t = {};
          this.name = e.name;
          var n = e.index;
          null !== n && this.setIndex(n.clone(t));
          var r = e.attributes;
          for (var i in r) this.setAttribute(i, r[i].clone(t));
          var a = e.morphAttributes;
          for (var o in a) {
            for (var s = [], c = a[o], u = 0, l = c.length; u < l; u++)
              s.push(c[u].clone(t));
            this.morphAttributes[o] = s;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          for (var h = e.groups, d = 0, p = h.length; d < p; d++) {
            var f = h[d];
            this.addGroup(f.start, f.count, f.materialIndex);
          }
          var m = e.boundingBox;
          null !== m && (this.boundingBox = m.clone());
          var v = e.boundingSphere;
          return (
            null !== v && (this.boundingSphere = v.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      });
      var qi = new sr(),
        Xi = new Kr(),
        Yi = new jr(),
        Zi = new $n(),
        Ji = new $n(),
        Ki = new $n(),
        Qi = new $n(),
        $i = new $n(),
        ea = new $n(),
        ta = new $n(),
        na = new $n(),
        ra = new $n(),
        ia = new Hn(),
        aa = new Hn(),
        oa = new Hn(),
        sa = new $n(),
        ca = new $n();
      function ua(e, t) {
        Tr.call(this),
          (this.type = "Mesh"),
          (this.geometry = void 0 !== e ? e : new Wi()),
          (this.material = void 0 !== t ? t : new Mi()),
          this.updateMorphTargets();
      }
      function la(e, t, n, r, i, a, o, s) {
        if (
          null ===
          (t.side === y
            ? r.intersectTriangle(o, a, i, !0, s)
            : r.intersectTriangle(i, a, o, t.side !== x, s))
        )
          return null;
        ca.copy(s), ca.applyMatrix4(e.matrixWorld);
        var c = n.ray.origin.distanceTo(ca);
        return c < n.near || c > n.far
          ? null
          : { distance: c, point: ca.clone(), object: e };
      }
      function ha(e, t, n, r, i, a, o, s, c, u, l, h) {
        Zi.fromBufferAttribute(i, u),
          Ji.fromBufferAttribute(i, l),
          Ki.fromBufferAttribute(i, h);
        var d = e.morphTargetInfluences;
        if (t.morphTargets && a && d) {
          ta.set(0, 0, 0), na.set(0, 0, 0), ra.set(0, 0, 0);
          for (var p = 0, f = a.length; p < f; p++) {
            var m = d[p],
              v = a[p];
            0 !== m &&
              (Qi.fromBufferAttribute(v, u),
              $i.fromBufferAttribute(v, l),
              ea.fromBufferAttribute(v, h),
              o
                ? (ta.addScaledVector(Qi, m),
                  na.addScaledVector($i, m),
                  ra.addScaledVector(ea, m))
                : (ta.addScaledVector(Qi.sub(Zi), m),
                  na.addScaledVector($i.sub(Ji), m),
                  ra.addScaledVector(ea.sub(Ki), m)));
          }
          Zi.add(ta), Ji.add(na), Ki.add(ra);
        }
        e.isSkinnedMesh &&
          (e.boneTransform(u, Zi),
          e.boneTransform(l, Ji),
          e.boneTransform(h, Ki));
        var g = la(e, t, n, r, Zi, Ji, Ki, sa);
        if (g) {
          s &&
            (ia.fromBufferAttribute(s, u),
            aa.fromBufferAttribute(s, l),
            oa.fromBufferAttribute(s, h),
            (g.uv = di.getUV(sa, Zi, Ji, Ki, ia, aa, oa, new Hn()))),
            c &&
              (ia.fromBufferAttribute(c, u),
              aa.fromBufferAttribute(c, l),
              oa.fromBufferAttribute(c, h),
              (g.uv2 = di.getUV(sa, Zi, Ji, Ki, ia, aa, oa, new Hn())));
          var y = new bi(u, l, h);
          di.getNormal(Zi, Ji, Ki, y.normal), (g.face = y);
        }
        return g;
      }
      ua.prototype = Object.assign(Object.create(Tr.prototype), {
        constructor: ua,
        isMesh: !0,
        copy: function (e) {
          return (
            Tr.prototype.copy.call(this, e),
            void 0 !== e.morphTargetInfluences &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        },
        updateMorphTargets: function () {
          var e = this.geometry;
          if (e.isBufferGeometry) {
            var t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              var r = t[n[0]];
              if (void 0 !== r) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (var i = 0, a = r.length; i < a; i++) {
                  var o = r[i].name || String(i);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[o] = i);
                }
              }
            }
          } else {
            var s = e.morphTargets;
            void 0 !== s &&
              s.length > 0 &&
              console.error(
                "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        },
        raycast: function (e, t) {
          var n,
            r = this.geometry,
            i = this.material,
            a = this.matrixWorld;
          if (
            void 0 !== i &&
            (null === r.boundingSphere && r.computeBoundingSphere(),
            Yi.copy(r.boundingSphere),
            Yi.applyMatrix4(a),
            !1 !== e.ray.intersectsSphere(Yi) &&
              (qi.getInverse(a),
              Xi.copy(e.ray).applyMatrix4(qi),
              null === r.boundingBox || !1 !== Xi.intersectsBox(r.boundingBox)))
          )
            if (r.isBufferGeometry) {
              var o = r.index,
                s = r.attributes.position,
                c = r.morphAttributes.position,
                u = r.morphTargetsRelative,
                l = r.attributes.uv,
                h = r.attributes.uv2,
                d = r.groups,
                p = r.drawRange;
              if (null !== o)
                if (Array.isArray(i))
                  for (var f = 0, m = d.length; f < m; f++)
                    for (
                      var v = d[f],
                        g = i[v.materialIndex],
                        y = Math.max(v.start, p.start),
                        x = Math.min(v.start + v.count, p.start + p.count);
                      y < x;
                      y += 3
                    ) {
                      var b = o.getX(y),
                        _ = o.getX(y + 1),
                        w = o.getX(y + 2);
                      (n = ha(this, g, e, Xi, s, c, u, l, h, b, _, w)) &&
                        ((n.faceIndex = Math.floor(y / 3)),
                        (n.face.materialIndex = v.materialIndex),
                        t.push(n));
                    }
                else
                  for (
                    var M = Math.max(0, p.start),
                      S = Math.min(o.count, p.start + p.count);
                    M < S;
                    M += 3
                  ) {
                    var T = o.getX(M),
                      E = o.getX(M + 1),
                      A = o.getX(M + 2);
                    (n = ha(this, i, e, Xi, s, c, u, l, h, T, E, A)) &&
                      ((n.faceIndex = Math.floor(M / 3)), t.push(n));
                  }
              else if (void 0 !== s)
                if (Array.isArray(i))
                  for (var L = 0, C = d.length; L < C; L++)
                    for (
                      var R = d[L],
                        P = i[R.materialIndex],
                        O = Math.max(R.start, p.start),
                        D = Math.min(R.start + R.count, p.start + p.count);
                      O < D;
                      O += 3
                    )
                      (n = ha(
                        this,
                        P,
                        e,
                        Xi,
                        s,
                        c,
                        u,
                        l,
                        h,
                        O,
                        O + 1,
                        O + 2
                      )) &&
                        ((n.faceIndex = Math.floor(O / 3)),
                        (n.face.materialIndex = R.materialIndex),
                        t.push(n));
                else
                  for (
                    var I = Math.max(0, p.start),
                      N = Math.min(s.count, p.start + p.count);
                    I < N;
                    I += 3
                  )
                    (n = ha(this, i, e, Xi, s, c, u, l, h, I, I + 1, I + 2)) &&
                      ((n.faceIndex = Math.floor(I / 3)), t.push(n));
            } else if (r.isGeometry) {
              var B,
                z = Array.isArray(i),
                F = r.vertices,
                U = r.faces,
                G = r.faceVertexUvs[0];
              G.length > 0 && (B = G);
              for (var k = 0, H = U.length; k < H; k++) {
                var j = U[k],
                  V = z ? i[j.materialIndex] : i;
                if (void 0 !== V) {
                  var W = F[j.a],
                    q = F[j.b],
                    X = F[j.c];
                  if ((n = la(this, V, e, Xi, W, q, X, sa))) {
                    if (B && B[k]) {
                      var Y = B[k];
                      ia.copy(Y[0]),
                        aa.copy(Y[1]),
                        oa.copy(Y[2]),
                        (n.uv = di.getUV(sa, W, q, X, ia, aa, oa, new Hn()));
                    }
                    (n.face = j), (n.faceIndex = k), t.push(n);
                  }
                }
              }
            }
        },
      });
      var da = 0,
        pa = new sr(),
        fa = new Tr(),
        ma = new $n();
      function va() {
        Object.defineProperty(this, "id", { value: (da += 2) }),
          (this.uuid = kn.generateUUID()),
          (this.name = ""),
          (this.type = "Geometry"),
          (this.vertices = []),
          (this.colors = []),
          (this.faces = []),
          (this.faceVertexUvs = [[]]),
          (this.morphTargets = []),
          (this.morphNormals = []),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.lineDistances = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.elementsNeedUpdate = !1),
          (this.verticesNeedUpdate = !1),
          (this.uvsNeedUpdate = !1),
          (this.normalsNeedUpdate = !1),
          (this.colorsNeedUpdate = !1),
          (this.lineDistancesNeedUpdate = !1),
          (this.groupsNeedUpdate = !1);
      }
      va.prototype = Object.assign(Object.create(zn.prototype), {
        constructor: va,
        isGeometry: !0,
        applyMatrix4: function (e) {
          for (
            var t = new jn().getNormalMatrix(e),
              n = 0,
              r = this.vertices.length;
            n < r;
            n++
          )
            this.vertices[n].applyMatrix4(e);
          for (var i = 0, a = this.faces.length; i < a; i++) {
            var o = this.faces[i];
            o.normal.applyMatrix3(t).normalize();
            for (var s = 0, c = o.vertexNormals.length; s < c; s++)
              o.vertexNormals[s].applyMatrix3(t).normalize();
          }
          return (
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            (this.verticesNeedUpdate = !0),
            (this.normalsNeedUpdate = !0),
            this
          );
        },
        rotateX: function (e) {
          return pa.makeRotationX(e), this.applyMatrix4(pa), this;
        },
        rotateY: function (e) {
          return pa.makeRotationY(e), this.applyMatrix4(pa), this;
        },
        rotateZ: function (e) {
          return pa.makeRotationZ(e), this.applyMatrix4(pa), this;
        },
        translate: function (e, t, n) {
          return pa.makeTranslation(e, t, n), this.applyMatrix4(pa), this;
        },
        scale: function (e, t, n) {
          return pa.makeScale(e, t, n), this.applyMatrix4(pa), this;
        },
        lookAt: function (e) {
          return (
            fa.lookAt(e), fa.updateMatrix(), this.applyMatrix4(fa.matrix), this
          );
        },
        fromBufferGeometry: function (e) {
          var t = this,
            n = null !== e.index ? e.index : void 0,
            r = e.attributes;
          if (void 0 === r.position)
            return (
              console.error(
                "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
              ),
              this
            );
          var i = r.position,
            a = r.normal,
            o = r.color,
            s = r.uv,
            c = r.uv2;
          void 0 !== c && (this.faceVertexUvs[1] = []);
          for (var u = 0; u < i.count; u++)
            t.vertices.push(new $n().fromBufferAttribute(i, u)),
              void 0 !== o && t.colors.push(new vi().fromBufferAttribute(o, u));
          function l(e, n, r, i) {
            var u =
                void 0 === o
                  ? []
                  : [
                      t.colors[e].clone(),
                      t.colors[n].clone(),
                      t.colors[r].clone(),
                    ],
              l = new bi(
                e,
                n,
                r,
                void 0 === a
                  ? []
                  : [
                      new $n().fromBufferAttribute(a, e),
                      new $n().fromBufferAttribute(a, n),
                      new $n().fromBufferAttribute(a, r),
                    ],
                u,
                i
              );
            t.faces.push(l),
              void 0 !== s &&
                t.faceVertexUvs[0].push([
                  new Hn().fromBufferAttribute(s, e),
                  new Hn().fromBufferAttribute(s, n),
                  new Hn().fromBufferAttribute(s, r),
                ]),
              void 0 !== c &&
                t.faceVertexUvs[1].push([
                  new Hn().fromBufferAttribute(c, e),
                  new Hn().fromBufferAttribute(c, n),
                  new Hn().fromBufferAttribute(c, r),
                ]);
          }
          var h = e.groups;
          if (h.length > 0)
            for (var d = 0; d < h.length; d++)
              for (
                var p = h[d], f = p.start, m = f, v = f + p.count;
                m < v;
                m += 3
              )
                void 0 !== n
                  ? l(n.getX(m), n.getX(m + 1), n.getX(m + 2), p.materialIndex)
                  : l(m, m + 1, m + 2, p.materialIndex);
          else if (void 0 !== n)
            for (var g = 0; g < n.count; g += 3)
              l(n.getX(g), n.getX(g + 1), n.getX(g + 2));
          else for (var y = 0; y < i.count; y += 3) l(y, y + 1, y + 2);
          return (
            this.computeFaceNormals(),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere &&
              (this.boundingSphere = e.boundingSphere.clone()),
            this
          );
        },
        center: function () {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(ma).negate(),
            this.translate(ma.x, ma.y, ma.z),
            this
          );
        },
        normalize: function () {
          this.computeBoundingSphere();
          var e = this.boundingSphere.center,
            t = this.boundingSphere.radius,
            n = 0 === t ? 1 : 1 / t,
            r = new sr();
          return (
            r.set(
              n,
              0,
              0,
              -n * e.x,
              0,
              n,
              0,
              -n * e.y,
              0,
              0,
              n,
              -n * e.z,
              0,
              0,
              0,
              1
            ),
            this.applyMatrix4(r),
            this
          );
        },
        computeFaceNormals: function () {
          for (
            var e = new $n(), t = new $n(), n = 0, r = this.faces.length;
            n < r;
            n++
          ) {
            var i = this.faces[n],
              a = this.vertices[i.a],
              o = this.vertices[i.b];
            e.subVectors(this.vertices[i.c], o),
              t.subVectors(a, o),
              e.cross(t),
              e.normalize(),
              i.normal.copy(e);
          }
        },
        computeVertexNormals: function (e) {
          void 0 === e && (e = !0);
          for (
            var t = new Array(this.vertices.length),
              n = 0,
              r = this.vertices.length;
            n < r;
            n++
          )
            t[n] = new $n();
          if (e)
            for (
              var i = new $n(), a = new $n(), o = 0, s = this.faces.length;
              o < s;
              o++
            ) {
              var c = this.faces[o],
                u = this.vertices[c.a],
                l = this.vertices[c.b];
              i.subVectors(this.vertices[c.c], l),
                a.subVectors(u, l),
                i.cross(a),
                t[c.a].add(i),
                t[c.b].add(i),
                t[c.c].add(i);
            }
          else {
            this.computeFaceNormals();
            for (var h = 0, d = this.faces.length; h < d; h++) {
              var p = this.faces[h];
              t[p.a].add(p.normal), t[p.b].add(p.normal), t[p.c].add(p.normal);
            }
          }
          for (var f = 0, m = this.vertices.length; f < m; f++)
            t[f].normalize();
          for (var v = 0, g = this.faces.length; v < g; v++) {
            var y = this.faces[v],
              x = y.vertexNormals;
            3 === x.length
              ? (x[0].copy(t[y.a]), x[1].copy(t[y.b]), x[2].copy(t[y.c]))
              : ((x[0] = t[y.a].clone()),
                (x[1] = t[y.b].clone()),
                (x[2] = t[y.c].clone()));
          }
          this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeFlatVertexNormals: function () {
          this.computeFaceNormals();
          for (var e = 0, t = this.faces.length; e < t; e++) {
            var n = this.faces[e],
              r = n.vertexNormals;
            3 === r.length
              ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal))
              : ((r[0] = n.normal.clone()),
                (r[1] = n.normal.clone()),
                (r[2] = n.normal.clone()));
          }
          this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeMorphNormals: function () {
          for (var e = 0, t = this.faces.length; e < t; e++) {
            var n = this.faces[e];
            n.__originalFaceNormal
              ? n.__originalFaceNormal.copy(n.normal)
              : (n.__originalFaceNormal = n.normal.clone()),
              n.__originalVertexNormals || (n.__originalVertexNormals = []);
            for (var r = 0, i = n.vertexNormals.length; r < i; r++)
              n.__originalVertexNormals[r]
                ? n.__originalVertexNormals[r].copy(n.vertexNormals[r])
                : (n.__originalVertexNormals[r] = n.vertexNormals[r].clone());
          }
          var a = new va();
          a.faces = this.faces;
          for (var o = 0, s = this.morphTargets.length; o < s; o++) {
            if (!this.morphNormals[o]) {
              (this.morphNormals[o] = {}),
                (this.morphNormals[o].faceNormals = []),
                (this.morphNormals[o].vertexNormals = []);
              for (
                var c = this.morphNormals[o].faceNormals,
                  u = this.morphNormals[o].vertexNormals,
                  l = 0,
                  h = this.faces.length;
                l < h;
                l++
              ) {
                var d = new $n(),
                  p = { a: new $n(), b: new $n(), c: new $n() };
                c.push(d), u.push(p);
              }
            }
            var f = this.morphNormals[o];
            (a.vertices = this.morphTargets[o].vertices),
              a.computeFaceNormals(),
              a.computeVertexNormals();
            for (var m = 0, v = this.faces.length; m < v; m++) {
              var g = this.faces[m],
                y = f.vertexNormals[m];
              f.faceNormals[m].copy(g.normal),
                y.a.copy(g.vertexNormals[0]),
                y.b.copy(g.vertexNormals[1]),
                y.c.copy(g.vertexNormals[2]);
            }
          }
          for (var x = 0, b = this.faces.length; x < b; x++) {
            var _ = this.faces[x];
            (_.normal = _.__originalFaceNormal),
              (_.vertexNormals = _.__originalVertexNormals);
          }
        },
        computeBoundingBox: function () {
          null === this.boundingBox && (this.boundingBox = new Gr()),
            this.boundingBox.setFromPoints(this.vertices);
        },
        computeBoundingSphere: function () {
          null === this.boundingSphere && (this.boundingSphere = new jr()),
            this.boundingSphere.setFromPoints(this.vertices);
        },
        merge: function (e, t, n) {
          if (e && e.isGeometry) {
            var r,
              i = this.vertices.length,
              a = this.vertices,
              o = e.vertices,
              s = this.faces,
              c = e.faces,
              u = this.colors,
              l = e.colors;
            void 0 === n && (n = 0),
              void 0 !== t && (r = new jn().getNormalMatrix(t));
            for (var h = 0, d = o.length; h < d; h++) {
              var p = o[h].clone();
              void 0 !== t && p.applyMatrix4(t), a.push(p);
            }
            for (var f = 0, m = l.length; f < m; f++) u.push(l[f].clone());
            for (var v = 0, g = c.length; v < g; v++) {
              var y = void 0,
                x = void 0,
                b = void 0,
                _ = c[v],
                w = _.vertexNormals,
                M = _.vertexColors;
              (y = new bi(_.a + i, _.b + i, _.c + i)).normal.copy(_.normal),
                void 0 !== r && y.normal.applyMatrix3(r).normalize();
              for (var S = 0, T = w.length; S < T; S++)
                (x = w[S].clone()),
                  void 0 !== r && x.applyMatrix3(r).normalize(),
                  y.vertexNormals.push(x);
              y.color.copy(_.color);
              for (var E = 0, A = M.length; E < A; E++)
                (b = M[E]), y.vertexColors.push(b.clone());
              (y.materialIndex = _.materialIndex + n), s.push(y);
            }
            for (var L = 0, C = e.faceVertexUvs.length; L < C; L++) {
              var R = e.faceVertexUvs[L];
              void 0 === this.faceVertexUvs[L] && (this.faceVertexUvs[L] = []);
              for (var P = 0, O = R.length; P < O; P++) {
                for (var D = R[P], I = [], N = 0, B = D.length; N < B; N++)
                  I.push(D[N].clone());
                this.faceVertexUvs[L].push(I);
              }
            }
          } else
            console.error(
              "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
              e
            );
        },
        mergeMesh: function (e) {
          e && e.isMesh
            ? (e.matrixAutoUpdate && e.updateMatrix(),
              this.merge(e.geometry, e.matrix))
            : console.error(
                "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
                e
              );
        },
        mergeVertices: function () {
          for (
            var e = {},
              t = [],
              n = [],
              r = Math.pow(10, 4),
              i = 0,
              a = this.vertices.length;
            i < a;
            i++
          ) {
            var o = this.vertices[i],
              s =
                Math.round(o.x * r) +
                "_" +
                Math.round(o.y * r) +
                "_" +
                Math.round(o.z * r);
            void 0 === e[s]
              ? ((e[s] = i), t.push(this.vertices[i]), (n[i] = t.length - 1))
              : (n[i] = n[e[s]]);
          }
          for (var c = [], u = 0, l = this.faces.length; u < l; u++) {
            var h = this.faces[u];
            (h.a = n[h.a]), (h.b = n[h.b]), (h.c = n[h.c]);
            for (var d = [h.a, h.b, h.c], p = 0; p < 3; p++)
              if (d[p] === d[(p + 1) % 3]) {
                c.push(u);
                break;
              }
          }
          for (var f = c.length - 1; f >= 0; f--) {
            var m = c[f];
            this.faces.splice(m, 1);
            for (var v = 0, g = this.faceVertexUvs.length; v < g; v++)
              this.faceVertexUvs[v].splice(m, 1);
          }
          var y = this.vertices.length - t.length;
          return (this.vertices = t), y;
        },
        setFromPoints: function (e) {
          this.vertices = [];
          for (var t = 0, n = e.length; t < n; t++) {
            var r = e[t];
            this.vertices.push(new $n(r.x, r.y, r.z || 0));
          }
          return this;
        },
        sortFacesByMaterialIndex: function () {
          for (var e = this.faces, t = e.length, n = 0; n < t; n++)
            e[n]._id = n;
          e.sort(function (e, t) {
            return e.materialIndex - t.materialIndex;
          });
          var r,
            i,
            a = this.faceVertexUvs[0],
            o = this.faceVertexUvs[1];
          a && a.length === t && (r = []), o && o.length === t && (i = []);
          for (var s = 0; s < t; s++) {
            var c = e[s]._id;
            r && r.push(a[c]), i && i.push(o[c]);
          }
          r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i);
        },
        toJSON: function () {
          var e = {
            metadata: {
              version: 4.5,
              type: "Geometry",
              generator: "Geometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            "" !== this.name && (e.name = this.name),
            void 0 !== this.parameters)
          ) {
            var t = this.parameters;
            for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
            return e;
          }
          for (var r = [], i = 0; i < this.vertices.length; i++) {
            var a = this.vertices[i];
            r.push(a.x, a.y, a.z);
          }
          for (
            var o = [], s = [], c = {}, u = [], l = {}, h = [], d = {}, p = 0;
            p < this.faces.length;
            p++
          ) {
            var f = this.faces[p],
              m = void 0 !== this.faceVertexUvs[0][p],
              v = f.normal.length() > 0,
              g = f.vertexNormals.length > 0,
              y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
              x = f.vertexColors.length > 0,
              b = 0;
            if (
              ((b = S(b, 0, 0)),
              (b = S(b, 1, !0)),
              (b = S(b, 2, !1)),
              (b = S(b, 3, m)),
              (b = S(b, 4, v)),
              (b = S(b, 5, g)),
              (b = S(b, 6, y)),
              (b = S(b, 7, x)),
              o.push(b),
              o.push(f.a, f.b, f.c),
              o.push(f.materialIndex),
              m)
            ) {
              var _ = this.faceVertexUvs[0][p];
              o.push(A(_[0]), A(_[1]), A(_[2]));
            }
            if ((v && o.push(T(f.normal)), g)) {
              var w = f.vertexNormals;
              o.push(T(w[0]), T(w[1]), T(w[2]));
            }
            if ((y && o.push(E(f.color)), x)) {
              var M = f.vertexColors;
              o.push(E(M[0]), E(M[1]), E(M[2]));
            }
          }
          function S(e, t, n) {
            return n ? e | (1 << t) : e & ~(1 << t);
          }
          function T(e) {
            var t = e.x.toString() + e.y.toString() + e.z.toString();
            return (
              void 0 !== c[t] || ((c[t] = s.length / 3), s.push(e.x, e.y, e.z)),
              c[t]
            );
          }
          function E(e) {
            var t = e.r.toString() + e.g.toString() + e.b.toString();
            return (
              void 0 !== l[t] || ((l[t] = u.length), u.push(e.getHex())), l[t]
            );
          }
          function A(e) {
            var t = e.x.toString() + e.y.toString();
            return (
              void 0 !== d[t] || ((d[t] = h.length / 2), h.push(e.x, e.y)), d[t]
            );
          }
          return (
            (e.data = {}),
            (e.data.vertices = r),
            (e.data.normals = s),
            u.length > 0 && (e.data.colors = u),
            h.length > 0 && (e.data.uvs = [h]),
            (e.data.faces = o),
            e
          );
        },
        clone: function () {
          return new va().copy(this);
        },
        copy: function (e) {
          (this.vertices = []),
            (this.colors = []),
            (this.faces = []),
            (this.faceVertexUvs = [[]]),
            (this.morphTargets = []),
            (this.morphNormals = []),
            (this.skinWeights = []),
            (this.skinIndices = []),
            (this.lineDistances = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.name = e.name);
          for (var t = e.vertices, n = 0, r = t.length; n < r; n++)
            this.vertices.push(t[n].clone());
          for (var i = e.colors, a = 0, o = i.length; a < o; a++)
            this.colors.push(i[a].clone());
          for (var s = e.faces, c = 0, u = s.length; c < u; c++)
            this.faces.push(s[c].clone());
          for (var l = 0, h = e.faceVertexUvs.length; l < h; l++) {
            var d = e.faceVertexUvs[l];
            void 0 === this.faceVertexUvs[l] && (this.faceVertexUvs[l] = []);
            for (var p = 0, f = d.length; p < f; p++) {
              for (var m = d[p], v = [], g = 0, y = m.length; g < y; g++)
                v.push(m[g].clone());
              this.faceVertexUvs[l].push(v);
            }
          }
          for (var x = e.morphTargets, b = 0, _ = x.length; b < _; b++) {
            var w = {};
            if (((w.name = x[b].name), void 0 !== x[b].vertices)) {
              w.vertices = [];
              for (var M = 0, S = x[b].vertices.length; M < S; M++)
                w.vertices.push(x[b].vertices[M].clone());
            }
            if (void 0 !== x[b].normals) {
              w.normals = [];
              for (var T = 0, E = x[b].normals.length; T < E; T++)
                w.normals.push(x[b].normals[T].clone());
            }
            this.morphTargets.push(w);
          }
          for (var A = e.morphNormals, L = 0, C = A.length; L < C; L++) {
            var R = {};
            if (void 0 !== A[L].vertexNormals) {
              R.vertexNormals = [];
              for (var P = 0, O = A[L].vertexNormals.length; P < O; P++) {
                var D = A[L].vertexNormals[P],
                  I = {};
                (I.a = D.a.clone()),
                  (I.b = D.b.clone()),
                  (I.c = D.c.clone()),
                  R.vertexNormals.push(I);
              }
            }
            if (void 0 !== A[L].faceNormals) {
              R.faceNormals = [];
              for (var N = 0, B = A[L].faceNormals.length; N < B; N++)
                R.faceNormals.push(A[L].faceNormals[N].clone());
            }
            this.morphNormals.push(R);
          }
          for (var z = e.skinWeights, F = 0, U = z.length; F < U; F++)
            this.skinWeights.push(z[F].clone());
          for (var G = e.skinIndices, k = 0, H = G.length; k < H; k++)
            this.skinIndices.push(G[k].clone());
          for (var j = e.lineDistances, V = 0, W = j.length; V < W; V++)
            this.lineDistances.push(j[V]);
          var q = e.boundingBox;
          null !== q && (this.boundingBox = q.clone());
          var X = e.boundingSphere;
          return (
            null !== X && (this.boundingSphere = X.clone()),
            (this.elementsNeedUpdate = e.elementsNeedUpdate),
            (this.verticesNeedUpdate = e.verticesNeedUpdate),
            (this.uvsNeedUpdate = e.uvsNeedUpdate),
            (this.normalsNeedUpdate = e.normalsNeedUpdate),
            (this.colorsNeedUpdate = e.colorsNeedUpdate),
            (this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate),
            (this.groupsNeedUpdate = e.groupsNeedUpdate),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      });
      var ga = (function (e) {
          _inherits(n, e);
          var t = _createSuper(n);
          function n(e, r, i, a, o, s) {
            var c;
            return (
              _classCallCheck(this, n),
              ((c = t.call(this)).type = "BoxGeometry"),
              (c.parameters = {
                width: e,
                height: r,
                depth: i,
                widthSegments: a,
                heightSegments: o,
                depthSegments: s,
              }),
              c.fromBufferGeometry(new ya(e, r, i, a, o, s)),
              c.mergeVertices(),
              c
            );
          }
          return n;
        })(va),
        ya = (function (e) {
          _inherits(n, e);
          var t = _createSuper(n);
          function n(e, r, i, a, o, s) {
            var c;
            _classCallCheck(this, n),
              ((c = t.call(this)).type = "BoxBufferGeometry"),
              (c.parameters = {
                width: e,
                height: r,
                depth: i,
                widthSegments: a,
                heightSegments: o,
                depthSegments: s,
              });
            var u = _assertThisInitialized(c);
            (e = e || 1),
              (r = r || 1),
              (i = i || 1),
              (a = Math.floor(a) || 1),
              (o = Math.floor(o) || 1),
              (s = Math.floor(s) || 1);
            var l = [],
              h = [],
              d = [],
              p = [],
              f = 0,
              m = 0;
            function v(e, t, n, r, i, a, o, s, c, v, g) {
              for (
                var y = a / c,
                  x = o / v,
                  b = a / 2,
                  _ = o / 2,
                  w = s / 2,
                  M = c + 1,
                  S = v + 1,
                  T = 0,
                  E = 0,
                  A = new $n(),
                  L = 0;
                L < S;
                L++
              )
                for (var C = L * x - _, R = 0; R < M; R++)
                  (A[e] = (R * y - b) * r),
                    (A[t] = C * i),
                    (A[n] = w),
                    h.push(A.x, A.y, A.z),
                    (A[e] = 0),
                    (A[t] = 0),
                    (A[n] = s > 0 ? 1 : -1),
                    d.push(A.x, A.y, A.z),
                    p.push(R / c),
                    p.push(1 - L / v),
                    (T += 1);
              for (var P = 0; P < v; P++)
                for (var O = 0; O < c; O++) {
                  var D = f + O + M * (P + 1),
                    I = f + (O + 1) + M * (P + 1),
                    N = f + (O + 1) + M * P;
                  l.push(f + O + M * P, D, N), l.push(D, I, N), (E += 6);
                }
              u.addGroup(m, E, g), (m += E), (f += T);
            }
            return (
              v("z", "y", "x", -1, -1, i, r, e, s, o, 0),
              v("z", "y", "x", 1, -1, i, r, -e, s, o, 1),
              v("x", "z", "y", 1, 1, e, i, r, a, s, 2),
              v("x", "z", "y", 1, -1, e, i, -r, a, s, 3),
              v("x", "y", "z", 1, -1, e, r, i, a, o, 4),
              v("x", "y", "z", -1, -1, e, r, -i, a, o, 5),
              c.setIndex(l),
              c.setAttribute("position", new Ii(h, 3)),
              c.setAttribute("normal", new Ii(d, 3)),
              c.setAttribute("uv", new Ii(p, 2)),
              c
            );
          }
          return n;
        })(Wi);
      function xa(e) {
        var t = {};
        for (var n in e)
          for (var r in ((t[n] = {}), e[n])) {
            var i = e[n][r];
            t[n][r] =
              i &&
              (i.isColor ||
                i.isMatrix3 ||
                i.isMatrix4 ||
                i.isVector2 ||
                i.isVector3 ||
                i.isVector4 ||
                i.isTexture)
                ? i.clone()
                : Array.isArray(i)
                ? i.slice()
                : i;
          }
        return t;
      }
      function ba(e) {
        for (var t = {}, n = 0; n < e.length; n++) {
          var r = xa(e[n]);
          for (var i in r) t[i] = r[i];
        }
        return t;
      }
      var _a = { clone: xa, merge: ba };
      function wa(e) {
        wi.call(this),
          (this.type = "ShaderMaterial"),
          (this.defines = {}),
          (this.uniforms = {}),
          (this.vertexShader =
            "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
          (this.fragmentShader =
            "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
          (this.linewidth = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.clipping = !1),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
          }),
          (this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0],
          }),
          (this.index0AttributeName = void 0),
          (this.uniformsNeedUpdate = !1),
          void 0 !== e &&
            (void 0 !== e.attributes &&
              console.error(
                "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
              ),
            this.setValues(e));
      }
      function Ma() {
        Tr.call(this),
          (this.type = "Camera"),
          (this.matrixWorldInverse = new sr()),
          (this.projectionMatrix = new sr()),
          (this.projectionMatrixInverse = new sr());
      }
      function Sa(e, t, n, r) {
        Ma.call(this),
          (this.type = "PerspectiveCamera"),
          (this.fov = void 0 !== e ? e : 50),
          (this.zoom = 1),
          (this.near = void 0 !== n ? n : 0.1),
          (this.far = void 0 !== r ? r : 2e3),
          (this.focus = 10),
          (this.aspect = void 0 !== t ? t : 1),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      function Ta(e, t, n) {
        if (
          (Tr.call(this),
          (this.type = "CubeCamera"),
          !0 === n.isWebGLCubeRenderTarget)
        ) {
          this.renderTarget = n;
          var r = new Sa(90, 1, e, t);
          (r.layers = this.layers),
            r.up.set(0, -1, 0),
            r.lookAt(new $n(1, 0, 0)),
            this.add(r);
          var i = new Sa(90, 1, e, t);
          (i.layers = this.layers),
            i.up.set(0, -1, 0),
            i.lookAt(new $n(-1, 0, 0)),
            this.add(i);
          var a = new Sa(90, 1, e, t);
          (a.layers = this.layers),
            a.up.set(0, 0, 1),
            a.lookAt(new $n(0, 1, 0)),
            this.add(a);
          var o = new Sa(90, 1, e, t);
          (o.layers = this.layers),
            o.up.set(0, 0, -1),
            o.lookAt(new $n(0, -1, 0)),
            this.add(o);
          var s = new Sa(90, 1, e, t);
          (s.layers = this.layers),
            s.up.set(0, -1, 0),
            s.lookAt(new $n(0, 0, 1)),
            this.add(s);
          var c = new Sa(90, 1, e, t);
          (c.layers = this.layers),
            c.up.set(0, -1, 0),
            c.lookAt(new $n(0, 0, -1)),
            this.add(c),
            (this.update = function (e, t) {
              null === this.parent && this.updateMatrixWorld();
              var u = e.xr.enabled,
                l = e.getRenderTarget();
              e.xr.enabled = !1;
              var h = n.texture.generateMipmaps;
              (n.texture.generateMipmaps = !1),
                e.setRenderTarget(n, 0),
                e.render(t, r),
                e.setRenderTarget(n, 1),
                e.render(t, i),
                e.setRenderTarget(n, 2),
                e.render(t, a),
                e.setRenderTarget(n, 3),
                e.render(t, o),
                e.setRenderTarget(n, 4),
                e.render(t, s),
                (n.texture.generateMipmaps = h),
                e.setRenderTarget(n, 5),
                e.render(t, c),
                e.setRenderTarget(l),
                (e.xr.enabled = u);
            }),
            (this.clear = function (e, t, r, i) {
              for (var a = e.getRenderTarget(), o = 0; o < 6; o++)
                e.setRenderTarget(n, o), e.clear(t, r, i);
              e.setRenderTarget(a);
            });
        } else
          console.error(
            "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
          );
      }
      function Ea(e, t, n) {
        Number.isInteger(t) &&
          (console.warn(
            "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
          ),
          (t = n)),
          Yn.call(this, e, e, t);
      }
      function Aa(e, t, n, r, i, a, o, s, c, u, l, h) {
        qn.call(this, null, a, o, s, c, u, r, i, l, h),
          (this.image = { data: e || null, width: t || 1, height: n || 1 }),
          (this.magFilter = void 0 !== c ? c : ge),
          (this.minFilter = void 0 !== u ? u : ge),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1),
          (this.needsUpdate = !0);
      }
      ((wa.prototype = Object.create(wi.prototype)).constructor = wa),
        (wa.prototype.isShaderMaterial = !0),
        (wa.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = xa(e.uniforms)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.extensions = Object.assign({}, e.extensions)),
            this
          );
        }),
        (wa.prototype.toJSON = function (e) {
          var t = wi.prototype.toJSON.call(this, e);
          for (var n in ((t.uniforms = {}), this.uniforms)) {
            var r = this.uniforms[n].value;
            t.uniforms[n] =
              r && r.isTexture
                ? { type: "t", value: r.toJSON(e).uuid }
                : r && r.isColor
                ? { type: "c", value: r.getHex() }
                : r && r.isVector2
                ? { type: "v2", value: r.toArray() }
                : r && r.isVector3
                ? { type: "v3", value: r.toArray() }
                : r && r.isVector4
                ? { type: "v4", value: r.toArray() }
                : r && r.isMatrix3
                ? { type: "m3", value: r.toArray() }
                : r && r.isMatrix4
                ? { type: "m4", value: r.toArray() }
                : { value: r };
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader);
          var i = {};
          for (var a in this.extensions)
            !0 === this.extensions[a] && (i[a] = !0);
          return Object.keys(i).length > 0 && (t.extensions = i), t;
        }),
        (Ma.prototype = Object.assign(Object.create(Tr.prototype), {
          constructor: Ma,
          isCamera: !0,
          copy: function (e, t) {
            return (
              Tr.prototype.copy.call(this, e, t),
              this.matrixWorldInverse.copy(e.matrixWorldInverse),
              this.projectionMatrix.copy(e.projectionMatrix),
              this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
              this
            );
          },
          getWorldDirection: function (e) {
            void 0 === e &&
              (console.warn(
                "THREE.Camera: .getWorldDirection() target is now required"
              ),
              (e = new $n())),
              this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize();
          },
          updateMatrixWorld: function (e) {
            Tr.prototype.updateMatrixWorld.call(this, e),
              this.matrixWorldInverse.getInverse(this.matrixWorld);
          },
          updateWorldMatrix: function (e, t) {
            Tr.prototype.updateWorldMatrix.call(this, e, t),
              this.matrixWorldInverse.getInverse(this.matrixWorld);
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
        })),
        (Sa.prototype = Object.assign(Object.create(Ma.prototype), {
          constructor: Sa,
          isPerspectiveCamera: !0,
          copy: function (e, t) {
            return (
              Ma.prototype.copy.call(this, e, t),
              (this.fov = e.fov),
              (this.zoom = e.zoom),
              (this.near = e.near),
              (this.far = e.far),
              (this.focus = e.focus),
              (this.aspect = e.aspect),
              (this.view = null === e.view ? null : Object.assign({}, e.view)),
              (this.filmGauge = e.filmGauge),
              (this.filmOffset = e.filmOffset),
              this
            );
          },
          setFocalLength: function (e) {
            var t = (0.5 * this.getFilmHeight()) / e;
            (this.fov = 2 * kn.RAD2DEG * Math.atan(t)),
              this.updateProjectionMatrix();
          },
          getFocalLength: function () {
            var e = Math.tan(0.5 * kn.DEG2RAD * this.fov);
            return (0.5 * this.getFilmHeight()) / e;
          },
          getEffectiveFOV: function () {
            return (
              2 *
              kn.RAD2DEG *
              Math.atan(Math.tan(0.5 * kn.DEG2RAD * this.fov) / this.zoom)
            );
          },
          getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1);
          },
          getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1);
          },
          setViewOffset: function (e, t, n, r, i, a) {
            (this.aspect = e / t),
              null === this.view &&
                (this.view = {
                  enabled: !0,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1,
                }),
              (this.view.enabled = !0),
              (this.view.fullWidth = e),
              (this.view.fullHeight = t),
              (this.view.offsetX = n),
              (this.view.offsetY = r),
              (this.view.width = i),
              (this.view.height = a),
              this.updateProjectionMatrix();
          },
          clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          },
          updateProjectionMatrix: function () {
            var e = this.near,
              t = (e * Math.tan(0.5 * kn.DEG2RAD * this.fov)) / this.zoom,
              n = 2 * t,
              r = this.aspect * n,
              i = -0.5 * r,
              a = this.view;
            if (null !== this.view && this.view.enabled) {
              var o = a.fullWidth,
                s = a.fullHeight;
              (i += (a.offsetX * r) / o),
                (t -= (a.offsetY * n) / s),
                (r *= a.width / o),
                (n *= a.height / s);
            }
            var c = this.filmOffset;
            0 !== c && (i += (e * c) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(
                i,
                i + r,
                t,
                t - n,
                e,
                this.far
              ),
              this.projectionMatrixInverse.getInverse(this.projectionMatrix);
          },
          toJSON: function (e) {
            var t = Tr.prototype.toJSON.call(this, e);
            return (
              (t.object.fov = this.fov),
              (t.object.zoom = this.zoom),
              (t.object.near = this.near),
              (t.object.far = this.far),
              (t.object.focus = this.focus),
              (t.object.aspect = this.aspect),
              null !== this.view &&
                (t.object.view = Object.assign({}, this.view)),
              (t.object.filmGauge = this.filmGauge),
              (t.object.filmOffset = this.filmOffset),
              t
            );
          },
        })),
        ((Ta.prototype = Object.create(Tr.prototype)).constructor = Ta),
        ((Ea.prototype = Object.create(Yn.prototype)).constructor = Ea),
        (Ea.prototype.isWebGLCubeRenderTarget = !0),
        (Ea.prototype.fromEquirectangularTexture = function (e, t) {
          (this.texture.type = t.type),
            (this.texture.format = t.format),
            (this.texture.encoding = t.encoding);
          var n = new Er(),
            r = {
              uniforms: { tEquirect: { value: null } },
              vertexShader: [
                "varying vec3 vWorldDirection;",
                "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
                "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
                "}",
                "void main() {",
                "\tvWorldDirection = transformDirection( position, modelMatrix );",
                "\t#include <begin_vertex>",
                "\t#include <project_vertex>",
                "}",
              ].join("\n"),
              fragmentShader: [
                "uniform sampler2D tEquirect;",
                "varying vec3 vWorldDirection;",
                "#include <common>",
                "void main() {",
                "\tvec3 direction = normalize( vWorldDirection );",
                "\tvec2 sampleUV = equirectUv( direction );",
                "\tgl_FragColor = texture2D( tEquirect, sampleUV );",
                "}",
              ].join("\n"),
            },
            i = new wa({
              name: "CubemapFromEquirect",
              uniforms: xa(r.uniforms),
              vertexShader: r.vertexShader,
              fragmentShader: r.fragmentShader,
              side: y,
              blending: w,
            });
          i.uniforms.tEquirect.value = t;
          var a = new ua(new ya(5, 5, 5), i);
          return (
            n.add(a),
            new Ta(1, 10, this).update(e, n),
            a.geometry.dispose(),
            a.material.dispose(),
            this
          );
        }),
        ((Aa.prototype = Object.create(qn.prototype)).constructor = Aa),
        (Aa.prototype.isDataTexture = !0);
      var La = new jr(),
        Ca = new $n();
      function Ra(e, t, n, r, i, a) {
        this.planes = [
          void 0 !== e ? e : new ti(),
          void 0 !== t ? t : new ti(),
          void 0 !== n ? n : new ti(),
          void 0 !== r ? r : new ti(),
          void 0 !== i ? i : new ti(),
          void 0 !== a ? a : new ti(),
        ];
      }
      Object.assign(Ra.prototype, {
        set: function (e, t, n, r, i, a) {
          var o = this.planes;
          return (
            o[0].copy(e),
            o[1].copy(t),
            o[2].copy(n),
            o[3].copy(r),
            o[4].copy(i),
            o[5].copy(a),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (e) {
          for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
          return this;
        },
        setFromProjectionMatrix: function (e) {
          var t = this.planes,
            n = e.elements,
            r = n[0],
            i = n[1],
            a = n[2],
            o = n[3],
            s = n[4],
            c = n[5],
            u = n[6],
            l = n[7],
            h = n[8],
            d = n[9],
            p = n[10],
            f = n[11],
            m = n[12],
            v = n[13],
            g = n[14],
            y = n[15];
          return (
            t[0].setComponents(o - r, l - s, f - h, y - m).normalize(),
            t[1].setComponents(o + r, l + s, f + h, y + m).normalize(),
            t[2].setComponents(o + i, l + c, f + d, y + v).normalize(),
            t[3].setComponents(o - i, l - c, f - d, y - v).normalize(),
            t[4].setComponents(o - a, l - u, f - p, y - g).normalize(),
            t[5].setComponents(o + a, l + u, f + p, y + g).normalize(),
            this
          );
        },
        intersectsObject: function (e) {
          var t = e.geometry;
          return (
            null === t.boundingSphere && t.computeBoundingSphere(),
            La.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(La)
          );
        },
        intersectsSprite: function (e) {
          return (
            La.center.set(0, 0, 0),
            (La.radius = 0.7071067811865476),
            La.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(La)
          );
        },
        intersectsSphere: function (e) {
          for (
            var t = this.planes, n = e.center, r = -e.radius, i = 0;
            i < 6;
            i++
          )
            if (t[i].distanceToPoint(n) < r) return !1;
          return !0;
        },
        intersectsBox: function (e) {
          for (var t = this.planes, n = 0; n < 6; n++) {
            var r = t[n];
            if (
              ((Ca.x = r.normal.x > 0 ? e.max.x : e.min.x),
              (Ca.y = r.normal.y > 0 ? e.max.y : e.min.y),
              (Ca.z = r.normal.z > 0 ? e.max.z : e.min.z),
              r.distanceToPoint(Ca) < 0)
            )
              return !1;
          }
          return !0;
        },
        containsPoint: function (e) {
          for (var t = this.planes, n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
          return !0;
        },
      });
      var Pa = {
        common: {
          diffuse: { value: new vi(15658734) },
          opacity: { value: 1 },
          map: { value: null },
          uvTransform: { value: new jn() },
          uv2Transform: { value: new jn() },
          alphaMap: { value: null },
        },
        specularmap: { specularMap: { value: null } },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          refractionRatio: { value: 0.98 },
          maxMipLevel: { value: 0 },
        },
        aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
        lightmap: {
          lightMap: { value: null },
          lightMapIntensity: { value: 1 },
        },
        emissivemap: { emissiveMap: { value: null } },
        bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
        normalmap: {
          normalMap: { value: null },
          normalScale: { value: new Hn(1, 1) },
        },
        displacementmap: {
          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 },
        },
        roughnessmap: { roughnessMap: { value: null } },
        metalnessmap: { metalnessMap: { value: null } },
        gradientmap: { gradientMap: { value: null } },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: new vi(16777215) },
        },
        lights: {
          ambientLightColor: { value: [] },
          lightProbe: { value: [] },
          directionalLights: {
            value: [],
            properties: { direction: {}, color: {} },
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {},
            },
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          spotShadowMap: { value: [] },
          spotShadowMatrix: { value: [] },
          pointLights: {
            value: [],
            properties: { color: {}, position: {}, decay: {}, distance: {} },
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {},
            },
          },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: {
            value: [],
            properties: { direction: {}, skyColor: {}, groundColor: {} },
          },
          rectAreaLights: {
            value: [],
            properties: { color: {}, position: {}, width: {}, height: {} },
          },
        },
        points: {
          diffuse: { value: new vi(15658734) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          alphaMap: { value: null },
          uvTransform: { value: new jn() },
        },
        sprite: {
          diffuse: { value: new vi(15658734) },
          opacity: { value: 1 },
          center: { value: new Hn(0.5, 0.5) },
          rotation: { value: 0 },
          map: { value: null },
          alphaMap: { value: null },
          uvTransform: { value: new jn() },
        },
      };
      function Oa() {
        var e = null,
          t = !1,
          n = null,
          r = null;
        function i(t, a) {
          n(t, a), (r = e.requestAnimationFrame(i));
        }
        return {
          start: function () {
            !0 !== t &&
              null !== n &&
              ((r = e.requestAnimationFrame(i)), (t = !0));
          },
          stop: function () {
            e.cancelAnimationFrame(r), (t = !1);
          },
          setAnimationLoop: function (e) {
            n = e;
          },
          setContext: function (t) {
            e = t;
          },
        };
      }
      function Da(e, t) {
        var n = t.isWebGL2,
          r = new WeakMap();
        return {
          get: function (e) {
            return e.isInterleavedBufferAttribute && (e = e.data), r.get(e);
          },
          remove: function (t) {
            t.isInterleavedBufferAttribute && (t = t.data);
            var n = r.get(t);
            n && (e.deleteBuffer(n.buffer), r.delete(t));
          },
          update: function (t, i) {
            t.isInterleavedBufferAttribute && (t = t.data);
            var a = r.get(t);
            void 0 === a
              ? r.set(
                  t,
                  (function (t, n) {
                    var r = t.array,
                      i = t.usage,
                      a = e.createBuffer();
                    e.bindBuffer(n, a),
                      e.bufferData(n, r, i),
                      t.onUploadCallback();
                    var o = 5126;
                    return (
                      r instanceof Float32Array
                        ? (o = 5126)
                        : r instanceof Float64Array
                        ? console.warn(
                            "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                          )
                        : r instanceof Uint16Array
                        ? (o = 5123)
                        : r instanceof Int16Array
                        ? (o = 5122)
                        : r instanceof Uint32Array
                        ? (o = 5125)
                        : r instanceof Int32Array
                        ? (o = 5124)
                        : r instanceof Int8Array
                        ? (o = 5120)
                        : r instanceof Uint8Array && (o = 5121),
                      {
                        buffer: a,
                        type: o,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: t.version,
                      }
                    );
                  })(t, i)
                )
              : a.version < t.version &&
                ((function (t, r, i) {
                  var a = r.array,
                    o = r.updateRange;
                  e.bindBuffer(i, t),
                    -1 === o.count
                      ? e.bufferSubData(i, 0, a)
                      : (n
                          ? e.bufferSubData(
                              i,
                              o.offset * a.BYTES_PER_ELEMENT,
                              a,
                              o.offset,
                              o.count
                            )
                          : e.bufferSubData(
                              i,
                              o.offset * a.BYTES_PER_ELEMENT,
                              a.subarray(o.offset, o.offset + o.count)
                            ),
                        (o.count = -1));
                })(a.buffer, t, i),
                (a.version = t.version));
          },
        };
      }
      function Ia(e, t, n, r) {
        va.call(this),
          (this.type = "PlaneGeometry"),
          (this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: r,
          }),
          this.fromBufferGeometry(new Na(e, t, n, r)),
          this.mergeVertices();
      }
      function Na(e, t, n, r) {
        Wi.call(this),
          (this.type = "PlaneBufferGeometry"),
          (this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: r,
          });
        for (
          var i = (e = e || 1) / 2,
            a = (t = t || 1) / 2,
            o = Math.floor(n) || 1,
            s = Math.floor(r) || 1,
            c = o + 1,
            u = s + 1,
            l = e / o,
            h = t / s,
            d = [],
            p = [],
            f = [],
            m = [],
            v = 0;
          v < u;
          v++
        )
          for (var g = v * h - a, y = 0; y < c; y++)
            p.push(y * l - i, -g, 0),
              f.push(0, 0, 1),
              m.push(y / o),
              m.push(1 - v / s);
        for (var x = 0; x < s; x++)
          for (var b = 0; b < o; b++) {
            var _ = b + c * (x + 1),
              w = b + 1 + c * (x + 1),
              M = b + 1 + c * x;
            d.push(b + c * x, _, M), d.push(_, w, M);
          }
        this.setIndex(d),
          this.setAttribute("position", new Ii(p, 3)),
          this.setAttribute("normal", new Ii(f, 3)),
          this.setAttribute("uv", new Ii(m, 2));
      }
      ((Ia.prototype = Object.create(va.prototype)).constructor = Ia),
        ((Na.prototype = Object.create(Wi.prototype)).constructor = Na);
      var Ba = {
          alphamap_fragment:
            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
          alphamap_pars_fragment:
            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment:
            "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
          aomap_fragment:
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
          aomap_pars_fragment:
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          begin_vertex: "vec3 transformed = vec3( position );",
          beginnormal_vertex:
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs:
            "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
          bumpmap_pars_fragment:
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          clipping_planes_pars_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment:
            "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment:
            "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
          color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
          common:
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
          cube_uv_reflection_fragment:
            "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
          defaultnormal_vertex:
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          encodings_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          encodings_pars_fragment:
            "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
          envmap_fragment:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex:
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment:
            "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
          envmap_vertex:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
          fog_fragment:
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment:
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment:
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
          lightmap_fragment:
            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
          lightmap_pars_fragment:
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_vertex:
            "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
          lights_pars_begin:
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment:
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment:
            "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
          lights_phong_fragment:
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment:
            "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
          lights_physical_fragment:
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
          lights_physical_pars_fragment:
            "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin:
            "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps:
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
          lights_fragment_end:
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
          logdepthbuf_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          logdepthbuf_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          map_fragment:
            "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment:
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment:
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphnormal_vertex:
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
          morphtarget_pars_vertex:
            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
          morphtarget_vertex:
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
          normal_fragment_begin:
            "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
          normal_fragment_maps:
            "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
          normalmap_pars_fragment:
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
          clearcoat_normal_fragment_begin:
            "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
          clearcoat_normal_fragment_maps:
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
          clearcoat_pars_fragment:
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
          packing:
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
          premultiplied_alpha_fragment:
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex:
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment:
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment:
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment:
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment:
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          shadowmap_pars_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
          shadowmask_pars_fragment:
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex:
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex:
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
          skinning_vertex:
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex:
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment:
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment:
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment:
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment:
            "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          uv_pars_fragment:
            "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
          uv_pars_vertex:
            "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
          uv_vertex:
            "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
          uv2_pars_fragment:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
          uv2_pars_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
          uv2_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
          worldpos_vertex:
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_frag:
            "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          background_vert:
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          cube_frag:
            "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          cube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          depth_frag:
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          depth_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          distanceRGBA_frag:
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          distanceRGBA_vert:
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          equirect_frag:
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          equirect_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          linedashed_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          linedashed_vert:
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshbasic_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag:
            "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert:
            "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshmatcap_frag:
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert:
            "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshtoon_frag:
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert:
            "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag:
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphong_vert:
            "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphysical_frag:
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert:
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          normal_frag:
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
          normal_vert:
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          points_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          points_vert:
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag:
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          shadow_vert:
            "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert:
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        },
        za = {
          basic: {
            uniforms: ba([
              Pa.common,
              Pa.specularmap,
              Pa.envmap,
              Pa.aomap,
              Pa.lightmap,
              Pa.fog,
            ]),
            vertexShader: Ba.meshbasic_vert,
            fragmentShader: Ba.meshbasic_frag,
          },
          lambert: {
            uniforms: ba([
              Pa.common,
              Pa.specularmap,
              Pa.envmap,
              Pa.aomap,
              Pa.lightmap,
              Pa.emissivemap,
              Pa.fog,
              Pa.lights,
              { emissive: { value: new vi(0) } },
            ]),
            vertexShader: Ba.meshlambert_vert,
            fragmentShader: Ba.meshlambert_frag,
          },
          phong: {
            uniforms: ba([
              Pa.common,
              Pa.specularmap,
              Pa.envmap,
              Pa.aomap,
              Pa.lightmap,
              Pa.emissivemap,
              Pa.bumpmap,
              Pa.normalmap,
              Pa.displacementmap,
              Pa.fog,
              Pa.lights,
              {
                emissive: { value: new vi(0) },
                specular: { value: new vi(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: Ba.meshphong_vert,
            fragmentShader: Ba.meshphong_frag,
          },
          standard: {
            uniforms: ba([
              Pa.common,
              Pa.envmap,
              Pa.aomap,
              Pa.lightmap,
              Pa.emissivemap,
              Pa.bumpmap,
              Pa.normalmap,
              Pa.displacementmap,
              Pa.roughnessmap,
              Pa.metalnessmap,
              Pa.fog,
              Pa.lights,
              {
                emissive: { value: new vi(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Ba.meshphysical_vert,
            fragmentShader: Ba.meshphysical_frag,
          },
          toon: {
            uniforms: ba([
              Pa.common,
              Pa.aomap,
              Pa.lightmap,
              Pa.emissivemap,
              Pa.bumpmap,
              Pa.normalmap,
              Pa.displacementmap,
              Pa.gradientmap,
              Pa.fog,
              Pa.lights,
              { emissive: { value: new vi(0) } },
            ]),
            vertexShader: Ba.meshtoon_vert,
            fragmentShader: Ba.meshtoon_frag,
          },
          matcap: {
            uniforms: ba([
              Pa.common,
              Pa.bumpmap,
              Pa.normalmap,
              Pa.displacementmap,
              Pa.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Ba.meshmatcap_vert,
            fragmentShader: Ba.meshmatcap_frag,
          },
          points: {
            uniforms: ba([Pa.points, Pa.fog]),
            vertexShader: Ba.points_vert,
            fragmentShader: Ba.points_frag,
          },
          dashed: {
            uniforms: ba([
              Pa.common,
              Pa.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: Ba.linedashed_vert,
            fragmentShader: Ba.linedashed_frag,
          },
          depth: {
            uniforms: ba([Pa.common, Pa.displacementmap]),
            vertexShader: Ba.depth_vert,
            fragmentShader: Ba.depth_frag,
          },
          normal: {
            uniforms: ba([
              Pa.common,
              Pa.bumpmap,
              Pa.normalmap,
              Pa.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: Ba.normal_vert,
            fragmentShader: Ba.normal_frag,
          },
          sprite: {
            uniforms: ba([Pa.sprite, Pa.fog]),
            vertexShader: Ba.sprite_vert,
            fragmentShader: Ba.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new jn() },
              t2D: { value: null },
            },
            vertexShader: Ba.background_vert,
            fragmentShader: Ba.background_frag,
          },
          cube: {
            uniforms: ba([Pa.envmap, { opacity: { value: 1 } }]),
            vertexShader: Ba.cube_vert,
            fragmentShader: Ba.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Ba.equirect_vert,
            fragmentShader: Ba.equirect_frag,
          },
          distanceRGBA: {
            uniforms: ba([
              Pa.common,
              Pa.displacementmap,
              {
                referencePosition: { value: new $n() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: Ba.distanceRGBA_vert,
            fragmentShader: Ba.distanceRGBA_frag,
          },
          shadow: {
            uniforms: ba([
              Pa.lights,
              Pa.fog,
              { color: { value: new vi(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Ba.shadow_vert,
            fragmentShader: Ba.shadow_frag,
          },
        };
      function Fa(e, t, n, r) {
        var i,
          a,
          o = new vi(0),
          s = 0,
          c = null,
          u = 0,
          l = null;
        function h(e, n) {
          t.buffers.color.setClear(e.r, e.g, e.b, n, r);
        }
        return {
          getClearColor: function () {
            return o;
          },
          setClearColor: function (e, t) {
            o.set(e), h(o, (s = void 0 !== t ? t : 1));
          },
          getClearAlpha: function () {
            return s;
          },
          setClearAlpha: function (e) {
            h(o, (s = e));
          },
          render: function (t, r, d, p) {
            var f = !0 === r.isScene ? r.background : null,
              m = e.xr,
              v = m.getSession && m.getSession();
            if (
              (v && "additive" === v.environmentBlendMode && (f = null),
              null === f ? h(o, s) : f && f.isColor && (h(f, 1), (p = !0)),
              (e.autoClear || p) &&
                e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
              f &&
                (f.isCubeTexture ||
                  f.isWebGLCubeRenderTarget ||
                  f.mapping === de))
            ) {
              void 0 === a &&
                ((a = new ua(
                  new ya(1, 1, 1),
                  new wa({
                    name: "BackgroundCubeMaterial",
                    uniforms: xa(za.cube.uniforms),
                    vertexShader: za.cube.vertexShader,
                    fragmentShader: za.cube.fragmentShader,
                    side: y,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )).geometry.deleteAttribute("normal"),
                a.geometry.deleteAttribute("uv"),
                (a.onBeforeRender = function (e, t, n) {
                  this.matrixWorld.copyPosition(n.matrixWorld);
                }),
                Object.defineProperty(a.material, "envMap", {
                  get: function () {
                    return this.uniforms.envMap.value;
                  },
                }),
                n.update(a));
              var x = f.isWebGLCubeRenderTarget ? f.texture : f;
              (a.material.uniforms.envMap.value = x),
                (a.material.uniforms.flipEnvMap.value = x.isCubeTexture
                  ? -1
                  : 1),
                (c === f && u === x.version && l === e.toneMapping) ||
                  ((a.material.needsUpdate = !0),
                  (c = f),
                  (u = x.version),
                  (l = e.toneMapping)),
                t.unshift(a, a.geometry, a.material, 0, 0, null);
            } else
              f &&
                f.isTexture &&
                (void 0 === i &&
                  ((i = new ua(
                    new Na(2, 2),
                    new wa({
                      name: "BackgroundMaterial",
                      uniforms: xa(za.background.uniforms),
                      vertexShader: za.background.vertexShader,
                      fragmentShader: za.background.fragmentShader,
                      side: g,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )).geometry.deleteAttribute("normal"),
                  Object.defineProperty(i.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  n.update(i)),
                (i.material.uniforms.t2D.value = f),
                !0 === f.matrixAutoUpdate && f.updateMatrix(),
                i.material.uniforms.uvTransform.value.copy(f.matrix),
                (c === f && u === f.version && l === e.toneMapping) ||
                  ((i.material.needsUpdate = !0),
                  (c = f),
                  (u = f.version),
                  (l = e.toneMapping)),
                t.unshift(i, i.geometry, i.material, 0, 0, null));
          },
        };
      }
      function Ua(e, t, n, r) {
        var i = e.getParameter(34921),
          a = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
          o = r.isWebGL2 || null !== a,
          s = {},
          c = d(null),
          u = c;
        function l(t) {
          return r.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t);
        }
        function h(t) {
          return r.isWebGL2
            ? e.deleteVertexArray(t)
            : a.deleteVertexArrayOES(t);
        }
        function d(e) {
          for (var t = [], n = [], r = [], a = 0; a < i; a++)
            (t[a] = 0), (n[a] = 0), (r[a] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: t,
            enabledAttributes: n,
            attributeDivisors: r,
            object: e,
            attributes: {},
          };
        }
        function p() {
          for (var e = u.newAttributes, t = 0, n = e.length; t < n; t++)
            e[t] = 0;
        }
        function f(e) {
          m(e, 0);
        }
        function m(n, i) {
          var a = u.enabledAttributes,
            o = u.attributeDivisors;
          (u.newAttributes[n] = 1),
            0 === a[n] && (e.enableVertexAttribArray(n), (a[n] = 1)),
            o[n] !== i &&
              ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
                r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](n, i),
              (o[n] = i));
        }
        function v() {
          for (
            var t = u.newAttributes,
              n = u.enabledAttributes,
              r = 0,
              i = n.length;
            r < i;
            r++
          )
            n[r] !== t[r] && (e.disableVertexAttribArray(r), (n[r] = 0));
        }
        function g(t, n, i, a, o, s) {
          !0 !== r.isWebGL2 || (5124 !== i && 5125 !== i)
            ? e.vertexAttribPointer(t, n, i, a, o, s)
            : e.vertexAttribIPointer(t, n, i, a, o, s);
        }
        function y() {
          x(), u !== c && l((u = c).object);
        }
        function x() {
          (c.geometry = null), (c.program = null), (c.wireframe = !1);
        }
        return {
          setup: function (i, c, h, y, x) {
            var b = !1;
            if (o) {
              var _ = (function (t, n, i) {
                var o = !0 === i.wireframe,
                  c = s[t.id];
                void 0 === c && ((c = {}), (s[t.id] = c));
                var u = c[n.id];
                void 0 === u && ((u = {}), (c[n.id] = u));
                var l = u[o];
                return (
                  void 0 === l &&
                    ((l = d(
                      r.isWebGL2
                        ? e.createVertexArray()
                        : a.createVertexArrayOES()
                    )),
                    (u[o] = l)),
                  l
                );
              })(y, h, c);
              u !== _ && l((u = _).object),
                (b = (function (e) {
                  var t = u.attributes,
                    n = e.attributes;
                  if (Object.keys(t).length !== Object.keys(n).length)
                    return !0;
                  for (var r in n) {
                    var i = t[r],
                      a = n[r];
                    if (i.attribute !== a) return !0;
                    if (i.data !== a.data) return !0;
                  }
                  return !1;
                })(y)) &&
                  (function (e) {
                    var t = {},
                      n = e.attributes;
                    for (var r in n) {
                      var i = n[r],
                        a = {};
                      (a.attribute = i),
                        i.data && (a.data = i.data),
                        (t[r] = a);
                    }
                    u.attributes = t;
                  })(y);
            } else {
              var w = !0 === c.wireframe;
              (u.geometry === y.id &&
                u.program === h.id &&
                u.wireframe === w) ||
                ((u.geometry = y.id),
                (u.program = h.id),
                (u.wireframe = w),
                (b = !0));
            }
            !0 === i.isInstancedMesh && (b = !0),
              null !== x && n.update(x, 34963),
              b &&
                ((function (i, a, o, s) {
                  if (
                    !1 !== r.isWebGL2 ||
                    (!i.isInstancedMesh && !s.isInstancedBufferGeometry) ||
                    null !== t.get("ANGLE_instanced_arrays")
                  ) {
                    p();
                    var c = s.attributes,
                      u = o.getAttributes(),
                      l = a.defaultAttributeValues;
                    for (var h in u) {
                      var d = u[h];
                      if (d >= 0) {
                        var y = c[h];
                        if (void 0 !== y) {
                          var x = y.normalized,
                            b = y.itemSize,
                            _ = n.get(y);
                          if (void 0 === _) continue;
                          var w = _.buffer,
                            M = _.type,
                            S = _.bytesPerElement;
                          if (y.isInterleavedBufferAttribute) {
                            var T = y.data,
                              E = T.stride,
                              A = y.offset;
                            T && T.isInstancedInterleavedBuffer
                              ? (m(d, T.meshPerAttribute),
                                void 0 === s._maxInstanceCount &&
                                  (s._maxInstanceCount =
                                    T.meshPerAttribute * T.count))
                              : f(d),
                              e.bindBuffer(34962, w),
                              g(d, b, M, x, E * S, A * S);
                          } else
                            y.isInstancedBufferAttribute
                              ? (m(d, y.meshPerAttribute),
                                void 0 === s._maxInstanceCount &&
                                  (s._maxInstanceCount =
                                    y.meshPerAttribute * y.count))
                              : f(d),
                              e.bindBuffer(34962, w),
                              g(d, b, M, x, 0, 0);
                        } else if ("instanceMatrix" === h) {
                          var L = n.get(i.instanceMatrix);
                          if (void 0 === L) continue;
                          var C = L.buffer,
                            R = L.type;
                          m(d + 0, 1),
                            m(d + 1, 1),
                            m(d + 2, 1),
                            m(d + 3, 1),
                            e.bindBuffer(34962, C),
                            e.vertexAttribPointer(d + 0, 4, R, !1, 64, 0),
                            e.vertexAttribPointer(d + 1, 4, R, !1, 64, 16),
                            e.vertexAttribPointer(d + 2, 4, R, !1, 64, 32),
                            e.vertexAttribPointer(d + 3, 4, R, !1, 64, 48);
                        } else if (void 0 !== l) {
                          var P = l[h];
                          if (void 0 !== P)
                            switch (P.length) {
                              case 2:
                                e.vertexAttrib2fv(d, P);
                                break;
                              case 3:
                                e.vertexAttrib3fv(d, P);
                                break;
                              case 4:
                                e.vertexAttrib4fv(d, P);
                                break;
                              default:
                                e.vertexAttrib1fv(d, P);
                            }
                        }
                      }
                    }
                    v();
                  }
                })(i, c, h, y),
                null !== x && e.bindBuffer(34963, n.get(x).buffer));
          },
          reset: y,
          resetDefaultState: x,
          dispose: function () {
            for (var e in (y(), s)) {
              var t = s[e];
              for (var n in t) {
                var r = t[n];
                for (var i in r) h(r[i].object), delete r[i];
                delete t[n];
              }
              delete s[e];
            }
          },
          releaseStatesOfGeometry: function (e) {
            if (void 0 !== s[e.id]) {
              var t = s[e.id];
              for (var n in t) {
                var r = t[n];
                for (var i in r) h(r[i].object), delete r[i];
                delete t[n];
              }
              delete s[e.id];
            }
          },
          releaseStatesOfProgram: function (e) {
            for (var t in s) {
              var n = s[t];
              if (void 0 !== n[e.id]) {
                var r = n[e.id];
                for (var i in r) h(r[i].object), delete r[i];
                delete n[e.id];
              }
            }
          },
          initAttributes: p,
          enableAttribute: f,
          disableUnusedAttributes: v,
        };
      }
      function Ga(e, t, n, r) {
        var i,
          a = r.isWebGL2;
        (this.setMode = function (e) {
          i = e;
        }),
          (this.render = function (t, r) {
            e.drawArrays(i, t, r), n.update(r, i);
          }),
          (this.renderInstances = function (r, o, s, c) {
            if (0 !== c) {
              var u, l;
              if (a) (u = e), (l = "drawArraysInstanced");
              else if (
                ((l = "drawArraysInstancedANGLE"),
                null === (u = t.get("ANGLE_instanced_arrays")))
              )
                return void console.error(
                  "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              u[l](i, o, s, c), n.update(s, i, c);
            }
          });
      }
      function ka(e, t, n) {
        var r;
        function i(t) {
          if ("highp" === t) {
            if (
              e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              e.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            t = "mediump";
          }
          return "mediump" === t &&
            e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            e.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        var a =
            ("undefined" != typeof WebGL2RenderingContext &&
              e instanceof WebGL2RenderingContext) ||
            ("undefined" != typeof WebGL2ComputeRenderingContext &&
              e instanceof WebGL2ComputeRenderingContext),
          o = void 0 !== n.precision ? n.precision : "highp",
          s = i(o);
        s !== o &&
          (console.warn(
            "THREE.WebGLRenderer:",
            o,
            "not supported, using",
            s,
            "instead."
          ),
          (o = s));
        var c = !0 === n.logarithmicDepthBuffer,
          u = e.getParameter(34930),
          l = e.getParameter(35660),
          h = e.getParameter(3379),
          d = e.getParameter(34076),
          p = e.getParameter(34921),
          f = e.getParameter(36347),
          m = e.getParameter(36348),
          v = e.getParameter(36349),
          g = l > 0,
          y = a || !!t.get("OES_texture_float");
        return {
          isWebGL2: a,
          getMaxAnisotropy: function () {
            if (void 0 !== r) return r;
            var n = t.get("EXT_texture_filter_anisotropic");
            return (r =
              null !== n
                ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                : 0);
          },
          getMaxPrecision: i,
          precision: o,
          logarithmicDepthBuffer: c,
          maxTextures: u,
          maxVertexTextures: l,
          maxTextureSize: h,
          maxCubemapSize: d,
          maxAttributes: p,
          maxVertexUniforms: f,
          maxVaryings: m,
          maxFragmentUniforms: v,
          vertexTextures: g,
          floatFragmentTextures: y,
          floatVertexTextures: g && y,
          maxSamples: a ? e.getParameter(36183) : 0,
        };
      }
      function Ha() {
        var e = this,
          t = null,
          n = 0,
          r = !1,
          i = !1,
          a = new ti(),
          o = new jn(),
          s = { value: null, needsUpdate: !1 };
        function c() {
          s.value !== t && ((s.value = t), (s.needsUpdate = n > 0)),
            (e.numPlanes = n),
            (e.numIntersection = 0);
        }
        function u(t, n, r, i) {
          var c = null !== t ? t.length : 0,
            u = null;
          if (0 !== c) {
            if (((u = s.value), !0 !== i || null === u)) {
              var l = r + 4 * c,
                h = n.matrixWorldInverse;
              o.getNormalMatrix(h),
                (null === u || u.length < l) && (u = new Float32Array(l));
              for (var d = 0, p = r; d !== c; ++d, p += 4)
                a.copy(t[d]).applyMatrix4(h, o),
                  a.normal.toArray(u, p),
                  (u[p + 3] = a.constant);
            }
            (s.value = u), (s.needsUpdate = !0);
          }
          return (e.numPlanes = c), (e.numIntersection = 0), u;
        }
        (this.uniform = s),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (e, i, a) {
            var o = 0 !== e.length || i || 0 !== n || r;
            return (r = i), (t = u(e, a, 0)), (n = e.length), o;
          }),
          (this.beginShadows = function () {
            (i = !0), u(null);
          }),
          (this.endShadows = function () {
            (i = !1), c();
          }),
          (this.setState = function (e, a, o, l, h, d) {
            if (!r || null === e || 0 === e.length || (i && !o))
              i ? u(null) : c();
            else {
              var p = i ? 0 : n,
                f = 4 * p,
                m = h.clippingState || null;
              (s.value = m), (m = u(e, l, f, d));
              for (var v = 0; v !== f; ++v) m[v] = t[v];
              (h.clippingState = m),
                (this.numIntersection = a ? this.numPlanes : 0),
                (this.numPlanes += p);
            }
          });
      }
      function ja(e) {
        var t = {};
        return {
          get: function (n) {
            if (void 0 !== t[n]) return t[n];
            var r;
            switch (n) {
              case "WEBGL_depth_texture":
                r =
                  e.getExtension("WEBGL_depth_texture") ||
                  e.getExtension("MOZ_WEBGL_depth_texture") ||
                  e.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
              case "EXT_texture_filter_anisotropic":
                r =
                  e.getExtension("EXT_texture_filter_anisotropic") ||
                  e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                  e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
              case "WEBGL_compressed_texture_s3tc":
                r =
                  e.getExtension("WEBGL_compressed_texture_s3tc") ||
                  e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                  e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
              case "WEBGL_compressed_texture_pvrtc":
                r =
                  e.getExtension("WEBGL_compressed_texture_pvrtc") ||
                  e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
              default:
                r = e.getExtension(n);
            }
            return (
              null === r &&
                console.warn(
                  "THREE.WebGLRenderer: " + n + " extension not supported."
                ),
              (t[n] = r),
              r
            );
          },
        };
      }
      function Va(e, t, n, r) {
        var i = new WeakMap(),
          a = new WeakMap();
        function o(e) {
          var s = e.target,
            c = i.get(s);
          for (var u in (null !== c.index && t.remove(c.index), c.attributes))
            t.remove(c.attributes[u]);
          s.removeEventListener("dispose", o), i.delete(s);
          var l = a.get(c);
          l && (t.remove(l), a.delete(c)),
            r.releaseStatesOfGeometry(s),
            !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
            n.memory.geometries--;
        }
        function s(e) {
          var n = [],
            r = e.index,
            i = e.attributes.position,
            o = 0;
          if (null !== r) {
            var s = r.array;
            o = r.version;
            for (var c = 0, u = s.length; c < u; c += 3) {
              var l = s[c + 0],
                h = s[c + 1],
                d = s[c + 2];
              n.push(l, h, h, d, d, l);
            }
          } else {
            o = i.version;
            for (var p = 0, f = i.array.length / 3 - 1; p < f; p += 3) {
              var m = p + 0,
                v = p + 1,
                g = p + 2;
              n.push(m, v, v, g, g, m);
            }
          }
          var y = new (zi(n) > 65535 ? Di : Pi)(n, 1);
          y.version = o;
          var x = a.get(e);
          x && t.remove(x), a.set(e, y);
        }
        return {
          get: function (e, t) {
            var r = i.get(t);
            return (
              r ||
              (t.addEventListener("dispose", o),
              t.isBufferGeometry
                ? (r = t)
                : t.isGeometry &&
                  (void 0 === t._bufferGeometry &&
                    (t._bufferGeometry = new Wi().setFromObject(e)),
                  (r = t._bufferGeometry)),
              i.set(t, r),
              n.memory.geometries++,
              r)
            );
          },
          update: function (e) {
            var n = e.attributes;
            for (var r in n) t.update(n[r], 34962);
            var i = e.morphAttributes;
            for (var a in i)
              for (var o = i[a], s = 0, c = o.length; s < c; s++)
                t.update(o[s], 34962);
          },
          getWireframeAttribute: function (e) {
            var t = a.get(e);
            if (t) {
              var n = e.index;
              null !== n && t.version < n.version && s(e);
            } else s(e);
            return a.get(e);
          },
        };
      }
      function Wa(e, t, n, r) {
        var i,
          a,
          o,
          s = r.isWebGL2;
        (this.setMode = function (e) {
          i = e;
        }),
          (this.setIndex = function (e) {
            (a = e.type), (o = e.bytesPerElement);
          }),
          (this.render = function (t, r) {
            e.drawElements(i, r, a, t * o), n.update(r, i);
          }),
          (this.renderInstances = function (r, c, u, l) {
            if (0 !== l) {
              var h, d;
              if (s) (h = e), (d = "drawElementsInstanced");
              else if (
                ((d = "drawElementsInstancedANGLE"),
                null === (h = t.get("ANGLE_instanced_arrays")))
              )
                return void console.error(
                  "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              h[d](i, u, a, c * o, l), n.update(u, i, l);
            }
          });
      }
      function qa(e) {
        var t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: t,
          programs: null,
          autoReset: !0,
          reset: function () {
            t.frame++,
              (t.calls = 0),
              (t.triangles = 0),
              (t.points = 0),
              (t.lines = 0);
          },
          update: function (e, n, r) {
            switch (((r = r || 1), t.calls++, n)) {
              case 4:
                t.triangles += r * (e / 3);
                break;
              case 1:
                t.lines += r * (e / 2);
                break;
              case 3:
                t.lines += r * (e - 1);
                break;
              case 2:
                t.lines += r * e;
                break;
              case 0:
                t.points += r * e;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", n);
            }
          },
        };
      }
      function Xa(e, t) {
        return e[0] - t[0];
      }
      function Ya(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1]);
      }
      function Za(e) {
        for (var t = {}, n = new Float32Array(8), r = [], i = 0; i < 8; i++)
          r[i] = [i, 0];
        return {
          update: function (i, a, o, s) {
            var c = i.morphTargetInfluences,
              u = void 0 === c ? 0 : c.length,
              l = t[a.id];
            if (void 0 === l) {
              l = [];
              for (var h = 0; h < u; h++) l[h] = [h, 0];
              t[a.id] = l;
            }
            for (var d = 0; d < u; d++) {
              var p = l[d];
              (p[0] = d), (p[1] = c[d]);
            }
            l.sort(Ya);
            for (var f = 0; f < 8; f++)
              f < u && l[f][1]
                ? ((r[f][0] = l[f][0]), (r[f][1] = l[f][1]))
                : ((r[f][0] = Number.MAX_SAFE_INTEGER), (r[f][1] = 0));
            r.sort(Xa);
            for (
              var m = o.morphTargets && a.morphAttributes.position,
                v = o.morphNormals && a.morphAttributes.normal,
                g = 0,
                y = 0;
              y < 8;
              y++
            ) {
              var x = r[y],
                b = x[0],
                _ = x[1];
              b !== Number.MAX_SAFE_INTEGER && _
                ? (m &&
                    a.getAttribute("morphTarget" + y) !== m[b] &&
                    a.setAttribute("morphTarget" + y, m[b]),
                  v &&
                    a.getAttribute("morphNormal" + y) !== v[b] &&
                    a.setAttribute("morphNormal" + y, v[b]),
                  (n[y] = _),
                  (g += _))
                : (m &&
                    void 0 !== a.getAttribute("morphTarget" + y) &&
                    a.deleteAttribute("morphTarget" + y),
                  v &&
                    void 0 !== a.getAttribute("morphNormal" + y) &&
                    a.deleteAttribute("morphNormal" + y),
                  (n[y] = 0));
            }
            var w = a.morphTargetsRelative ? 1 : 1 - g;
            s.getUniforms().setValue(e, "morphTargetBaseInfluence", w),
              s.getUniforms().setValue(e, "morphTargetInfluences", n);
          },
        };
      }
      function Ja(e, t, n, r) {
        var i = new WeakMap();
        return {
          update: function (e) {
            var a = r.render.frame,
              o = e.geometry,
              s = t.get(e, o);
            return (
              i.get(s) !== a &&
                (o.isGeometry && s.updateFromObject(e),
                t.update(s),
                i.set(s, a)),
              e.isInstancedMesh && n.update(e.instanceMatrix, 34962),
              s
            );
          },
          dispose: function () {
            i = new WeakMap();
          },
        };
      }
      function Ka(e, t, n, r, i, a, o, s, c, u) {
        qn.call(
          this,
          (e = void 0 !== e ? e : []),
          (t = void 0 !== t ? t : ce),
          n,
          r,
          i,
          a,
          (o = void 0 !== o ? o : Ge),
          s,
          c,
          u
        ),
          (this.flipY = !1);
      }
      function Qa(e, t, n, r) {
        qn.call(this, null),
          (this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1,
            depth: r || 1,
          }),
          (this.magFilter = ge),
          (this.minFilter = ge),
          (this.wrapR = me),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.needsUpdate = !0);
      }
      function $a(e, t, n, r) {
        qn.call(this, null),
          (this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1,
            depth: r || 1,
          }),
          (this.magFilter = ge),
          (this.minFilter = ge),
          (this.wrapR = me),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.needsUpdate = !0);
      }
      (za.physical = {
        uniforms: ba([
          za.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new Hn(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: new vi(0) },
            transparency: { value: 0 },
          },
        ]),
        vertexShader: Ba.meshphysical_vert,
        fragmentShader: Ba.meshphysical_frag,
      }),
        ((Ka.prototype = Object.create(qn.prototype)).constructor = Ka),
        (Ka.prototype.isCubeTexture = !0),
        Object.defineProperty(Ka.prototype, "images", {
          get: function () {
            return this.image;
          },
          set: function (e) {
            this.image = e;
          },
        }),
        ((Qa.prototype = Object.create(qn.prototype)).constructor = Qa),
        (Qa.prototype.isDataTexture2DArray = !0),
        (($a.prototype = Object.create(qn.prototype)).constructor = $a),
        ($a.prototype.isDataTexture3D = !0);
      var eo = new qn(),
        to = new Qa(),
        no = new $a(),
        ro = new Ka(),
        io = [],
        ao = [],
        oo = new Float32Array(16),
        so = new Float32Array(9),
        co = new Float32Array(4);
      function uo(e, t, n) {
        var r = e[0];
        if (r <= 0 || r > 0) return e;
        var i = t * n,
          a = io[i];
        if (
          (void 0 === a && ((a = new Float32Array(i)), (io[i] = a)), 0 !== t)
        ) {
          r.toArray(a, 0);
          for (var o = 1, s = 0; o !== t; ++o) (s += n), e[o].toArray(a, s);
        }
        return a;
      }
      function lo(e, t) {
        if (e.length !== t.length) return !1;
        for (var n = 0, r = e.length; n < r; n++) if (e[n] !== t[n]) return !1;
        return !0;
      }
      function ho(e, t) {
        for (var n = 0, r = t.length; n < r; n++) e[n] = t[n];
      }
      function po(e, t) {
        var n = ao[t];
        void 0 === n && ((n = new Int32Array(t)), (ao[t] = n));
        for (var r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
        return n;
      }
      function fo(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
      }
      function mo(e, t) {
        var n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y) ||
            (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
        else {
          if (lo(n, t)) return;
          e.uniform2fv(this.addr, t), ho(n, t);
        }
      }
      function vo(e, t) {
        var n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
            (e.uniform3f(this.addr, t.x, t.y, t.z),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z));
        else if (void 0 !== t.r)
          (n[0] === t.r && n[1] === t.g && n[2] === t.b) ||
            (e.uniform3f(this.addr, t.r, t.g, t.b),
            (n[0] = t.r),
            (n[1] = t.g),
            (n[2] = t.b));
        else {
          if (lo(n, t)) return;
          e.uniform3fv(this.addr, t), ho(n, t);
        }
      }
      function go(e, t) {
        var n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
            (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z),
            (n[3] = t.w));
        else {
          if (lo(n, t)) return;
          e.uniform4fv(this.addr, t), ho(n, t);
        }
      }
      function yo(e, t) {
        var n = this.cache,
          r = t.elements;
        if (void 0 === r) {
          if (lo(n, t)) return;
          e.uniformMatrix2fv(this.addr, !1, t), ho(n, t);
        } else {
          if (lo(n, r)) return;
          co.set(r), e.uniformMatrix2fv(this.addr, !1, co), ho(n, r);
        }
      }
      function xo(e, t) {
        var n = this.cache,
          r = t.elements;
        if (void 0 === r) {
          if (lo(n, t)) return;
          e.uniformMatrix3fv(this.addr, !1, t), ho(n, t);
        } else {
          if (lo(n, r)) return;
          so.set(r), e.uniformMatrix3fv(this.addr, !1, so), ho(n, r);
        }
      }
      function bo(e, t) {
        var n = this.cache,
          r = t.elements;
        if (void 0 === r) {
          if (lo(n, t)) return;
          e.uniformMatrix4fv(this.addr, !1, t), ho(n, t);
        } else {
          if (lo(n, r)) return;
          oo.set(r), e.uniformMatrix4fv(this.addr, !1, oo), ho(n, r);
        }
      }
      function _o(e, t, n) {
        var r = this.cache,
          i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
          n.safeSetTexture2D(t || eo, i);
      }
      function wo(e, t, n) {
        var r = this.cache,
          i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
          n.setTexture2DArray(t || to, i);
      }
      function Mo(e, t, n) {
        var r = this.cache,
          i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
          n.setTexture3D(t || no, i);
      }
      function So(e, t, n) {
        var r = this.cache,
          i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
          n.safeSetTextureCube(t || ro, i);
      }
      function To(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
      }
      function Eo(e, t) {
        var n = this.cache;
        lo(n, t) || (e.uniform2iv(this.addr, t), ho(n, t));
      }
      function Ao(e, t) {
        var n = this.cache;
        lo(n, t) || (e.uniform3iv(this.addr, t), ho(n, t));
      }
      function Lo(e, t) {
        var n = this.cache;
        lo(n, t) || (e.uniform4iv(this.addr, t), ho(n, t));
      }
      function Co(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t));
      }
      function Ro(e, t) {
        e.uniform1fv(this.addr, t);
      }
      function Po(e, t) {
        e.uniform1iv(this.addr, t);
      }
      function Oo(e, t) {
        e.uniform2iv(this.addr, t);
      }
      function Do(e, t) {
        e.uniform3iv(this.addr, t);
      }
      function Io(e, t) {
        e.uniform4iv(this.addr, t);
      }
      function No(e, t) {
        var n = uo(t, this.size, 2);
        e.uniform2fv(this.addr, n);
      }
      function Bo(e, t) {
        var n = uo(t, this.size, 3);
        e.uniform3fv(this.addr, n);
      }
      function zo(e, t) {
        var n = uo(t, this.size, 4);
        e.uniform4fv(this.addr, n);
      }
      function Fo(e, t) {
        var n = uo(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n);
      }
      function Uo(e, t) {
        var n = uo(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n);
      }
      function Go(e, t) {
        var n = uo(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n);
      }
      function ko(e, t, n) {
        var r = t.length,
          i = po(n, r);
        e.uniform1iv(this.addr, i);
        for (var a = 0; a !== r; ++a) n.safeSetTexture2D(t[a] || eo, i[a]);
      }
      function Ho(e, t, n) {
        var r = t.length,
          i = po(n, r);
        e.uniform1iv(this.addr, i);
        for (var a = 0; a !== r; ++a) n.safeSetTextureCube(t[a] || ro, i[a]);
      }
      function jo(e, t, n) {
        (this.id = e),
          (this.addr = n),
          (this.cache = []),
          (this.setValue = (function (e) {
            switch (e) {
              case 5126:
                return fo;
              case 35664:
                return mo;
              case 35665:
                return vo;
              case 35666:
                return go;
              case 35674:
                return yo;
              case 35675:
                return xo;
              case 35676:
                return bo;
              case 5124:
              case 35670:
                return To;
              case 35667:
              case 35671:
                return Eo;
              case 35668:
              case 35672:
                return Ao;
              case 35669:
              case 35673:
                return Lo;
              case 5125:
                return Co;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return _o;
              case 35679:
              case 36299:
              case 36307:
                return Mo;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return So;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return wo;
            }
          })(t.type));
      }
      function Vo(e, t, n) {
        (this.id = e),
          (this.addr = n),
          (this.cache = []),
          (this.size = t.size),
          (this.setValue = (function (e) {
            switch (e) {
              case 5126:
                return Ro;
              case 35664:
                return No;
              case 35665:
                return Bo;
              case 35666:
                return zo;
              case 35674:
                return Fo;
              case 35675:
                return Uo;
              case 35676:
                return Go;
              case 5124:
              case 35670:
                return Po;
              case 35667:
              case 35671:
                return Oo;
              case 35668:
              case 35672:
                return Do;
              case 35669:
              case 35673:
                return Io;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return ko;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return Ho;
            }
          })(t.type));
      }
      function Wo(e) {
        (this.id = e), (this.seq = []), (this.map = {});
      }
      (Vo.prototype.updateCache = function (e) {
        var t = this.cache;
        e instanceof Float32Array &&
          t.length !== e.length &&
          (this.cache = new Float32Array(e.length)),
          ho(t, e);
      }),
        (Wo.prototype.setValue = function (e, t, n) {
          for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
            var o = r[i];
            o.setValue(e, t[o.id], n);
          }
        });
      var qo = /([\w\d_]+)(\])?(\[|\.)?/g;
      function Xo(e, t) {
        e.seq.push(t), (e.map[t.id] = t);
      }
      function Yo(e, t, n) {
        var r = e.name,
          i = r.length;
        for (qo.lastIndex = 0; ; ) {
          var a = qo.exec(r),
            o = qo.lastIndex,
            s = a[1],
            c = a[3];
          if (
            ("]" === a[2] && (s |= 0),
            void 0 === c || ("[" === c && o + 2 === i))
          ) {
            Xo(n, void 0 === c ? new jo(s, e, t) : new Vo(s, e, t));
            break;
          }
          var u = n.map[s];
          void 0 === u && Xo(n, (u = new Wo(s))), (n = u);
        }
      }
      function Zo(e, t) {
        (this.seq = []), (this.map = {});
        for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) {
          var i = e.getActiveUniform(t, r);
          Yo(i, e.getUniformLocation(t, i.name), this);
        }
      }
      function Jo(e, t, n) {
        var r = e.createShader(t);
        return e.shaderSource(r, n), e.compileShader(r), r;
      }
      (Zo.prototype.setValue = function (e, t, n, r) {
        var i = this.map[t];
        void 0 !== i && i.setValue(e, n, r);
      }),
        (Zo.prototype.setOptional = function (e, t, n) {
          var r = t[n];
          void 0 !== r && this.setValue(e, n, r);
        }),
        (Zo.upload = function (e, t, n, r) {
          for (var i = 0, a = t.length; i !== a; ++i) {
            var o = t[i],
              s = n[o.id];
            !1 !== s.needsUpdate && o.setValue(e, s.value, r);
          }
        }),
        (Zo.seqWithValue = function (e, t) {
          for (var n = [], r = 0, i = e.length; r !== i; ++r) {
            var a = e[r];
            a.id in t && n.push(a);
          }
          return n;
        });
      var Ko = 0;
      function Qo(e) {
        switch (e) {
          case $t:
            return ["Linear", "( value )"];
          case en:
            return ["sRGB", "( value )"];
          case nn:
            return ["RGBE", "( value )"];
          case an:
            return ["RGBM", "( value, 7.0 )"];
          case on:
            return ["RGBM", "( value, 16.0 )"];
          case sn:
            return ["RGBD", "( value, 256.0 )"];
          case tn:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          case rn:
            return ["LogLuv", "( value )"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
              ["Linear", "( value )"]
            );
        }
      }
      function $o(e, t, n) {
        var r = e.getShaderParameter(t, 35713),
          i = e.getShaderInfoLog(t).trim();
        return r && "" === i
          ? ""
          : "THREE.WebGLShader: gl.getShaderInfoLog() " +
              n +
              "\n" +
              i +
              (function (e) {
                for (var t = e.split("\n"), n = 0; n < t.length; n++)
                  t[n] = n + 1 + ": " + t[n];
                return t.join("\n");
              })(e.getShaderSource(t));
      }
      function es(e, t) {
        var n = Qo(t);
        return (
          "vec4 " +
          e +
          "( vec4 value ) { return " +
          n[0] +
          "ToLinear" +
          n[1] +
          "; }"
        );
      }
      function ts(e, t) {
        var n;
        switch (t) {
          case ne:
            n = "Linear";
            break;
          case re:
            n = "Reinhard";
            break;
          case ie:
            n = "OptimizedCineon";
            break;
          case ae:
            n = "ACESFilmic";
            break;
          case oe:
            n = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
              (n = "Linear");
        }
        return (
          "vec3 " +
          e +
          "( vec3 color ) { return " +
          n +
          "ToneMapping( color ); }"
        );
      }
      function ns(e) {
        return "" !== e;
      }
      function rs(e, t) {
        return e
          .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function is(e, t) {
        return e
          .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            t.numClippingPlanes - t.numClipIntersection
          );
      }
      var as = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function os(e) {
        return e.replace(as, ss);
      }
      function ss(e, t) {
        var n = Ba[t];
        if (void 0 === n)
          throw new Error("Can not resolve #include <" + t + ">");
        return os(n);
      }
      var cs = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        us = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
      function ls(e) {
        return e.replace(us, ds).replace(cs, hs);
      }
      function hs(e, t, n, r) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          ds(0, t, n, r)
        );
      }
      function ds(e, t, n, r) {
        for (var i = "", a = parseInt(t); a < parseInt(n); a++)
          i += r
            .replace(/\[ i \]/g, "[ " + a + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, a);
        return i;
      }
      function ps(e) {
        var t =
          "precision " +
          e.precision +
          " float;\nprecision " +
          e.precision +
          " int;";
        return (
          "highp" === e.precision
            ? (t += "\n#define HIGH_PRECISION")
            : "mediump" === e.precision
            ? (t += "\n#define MEDIUM_PRECISION")
            : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
          t
        );
      }
      function fs(e, t, n, r) {
        var i,
          a,
          o,
          s,
          c,
          u = e.getContext(),
          l = n.defines,
          h = n.vertexShader,
          d = n.fragmentShader,
          p = (function (e) {
            var t = "SHADOWMAP_TYPE_BASIC";
            return (
              e.shadowMapType === f
                ? (t = "SHADOWMAP_TYPE_PCF")
                : e.shadowMapType === m
                ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
                : e.shadowMapType === v && (t = "SHADOWMAP_TYPE_VSM"),
              t
            );
          })(n),
          g = (function (e) {
            var t = "ENVMAP_TYPE_CUBE";
            if (e.envMap)
              switch (e.envMapMode) {
                case ce:
                case ue:
                  t = "ENVMAP_TYPE_CUBE";
                  break;
                case de:
                case pe:
                  t = "ENVMAP_TYPE_CUBE_UV";
                  break;
                case le:
                case he:
                  t = "ENVMAP_TYPE_EQUIREC";
              }
            return t;
          })(n),
          y = (function (e) {
            var t = "ENVMAP_MODE_REFLECTION";
            if (e.envMap)
              switch (e.envMapMode) {
                case ue:
                case he:
                  t = "ENVMAP_MODE_REFRACTION";
              }
            return t;
          })(n),
          x = (function (e) {
            var t = "ENVMAP_BLENDING_NONE";
            if (e.envMap)
              switch (e.combine) {
                case Q:
                  t = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case $:
                  t = "ENVMAP_BLENDING_MIX";
                  break;
                case ee:
                  t = "ENVMAP_BLENDING_ADD";
              }
            return t;
          })(n),
          b = e.gammaFactor > 0 ? e.gammaFactor : 1,
          _ = n.isWebGL2
            ? ""
            : (function (e) {
                return [
                  e.extensionDerivatives ||
                  e.envMapCubeUV ||
                  e.bumpMap ||
                  e.tangentSpaceNormalMap ||
                  e.clearcoatNormalMap ||
                  e.flatShading ||
                  "physical" === e.shaderID
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
                  e.rendererExtensionFragDepth
                    ? "#extension GL_EXT_frag_depth : enable"
                    : "",
                  e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
                    ? "#extension GL_EXT_draw_buffers : require"
                    : "",
                  (e.extensionShaderTextureLOD || e.envMap) &&
                  e.rendererExtensionShaderTextureLod
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                ]
                  .filter(ns)
                  .join("\n");
              })(n),
          w = (function (e) {
            var t = [];
            for (var n in e) {
              var r = e[n];
              !1 !== r && t.push("#define " + n + " " + r);
            }
            return t.join("\n");
          })(l),
          M = u.createProgram();
        if (
          (n.isRawShaderMaterial
            ? ((i = [w].filter(ns).join("\n")).length > 0 && (i += "\n"),
              (a = [_, w].filter(ns).join("\n")).length > 0 && (a += "\n"))
            : ((i = [
                ps(n),
                "#define SHADER_NAME " + n.shaderName,
                w,
                n.instancing ? "#define USE_INSTANCING" : "",
                n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
                "#define GAMMA_FACTOR " + b,
                "#define MAX_BONES " + n.maxBones,
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + y : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMap && n.objectSpaceNormalMap
                  ? "#define OBJECTSPACE_NORMALMAP"
                  : "",
                n.normalMap && n.tangentSpaceNormalMap
                  ? "#define TANGENTSPACE_NORMALMAP"
                  : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap
                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                  : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.displacementMap && n.supportsVertexTextures
                  ? "#define USE_DISPLACEMENTMAP"
                  : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.vertexTangents ? "#define USE_TANGENT" : "",
                n.vertexColors ? "#define USE_COLOR" : "",
                n.vertexUvs ? "#define USE_UV" : "",
                n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.skinning ? "#define USE_SKINNING" : "",
                n.useVertexTexture ? "#define BONE_TEXTURE" : "",
                n.morphTargets ? "#define USE_MORPHTARGETS" : "",
                n.morphNormals && !1 === n.flatShading
                  ? "#define USE_MORPHNORMALS"
                  : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + p : "",
                n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                "uniform mat4 modelMatrix;",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                "#ifdef USE_INSTANCING",
                " attribute mat4 instanceMatrix;",
                "#endif",
                "attribute vec3 position;",
                "attribute vec3 normal;",
                "attribute vec2 uv;",
                "#ifdef USE_TANGENT",
                "\tattribute vec4 tangent;",
                "#endif",
                "#ifdef USE_COLOR",
                "\tattribute vec3 color;",
                "#endif",
                "#ifdef USE_MORPHTARGETS",
                "\tattribute vec3 morphTarget0;",
                "\tattribute vec3 morphTarget1;",
                "\tattribute vec3 morphTarget2;",
                "\tattribute vec3 morphTarget3;",
                "\t#ifdef USE_MORPHNORMALS",
                "\t\tattribute vec3 morphNormal0;",
                "\t\tattribute vec3 morphNormal1;",
                "\t\tattribute vec3 morphNormal2;",
                "\t\tattribute vec3 morphNormal3;",
                "\t#else",
                "\t\tattribute vec3 morphTarget4;",
                "\t\tattribute vec3 morphTarget5;",
                "\t\tattribute vec3 morphTarget6;",
                "\t\tattribute vec3 morphTarget7;",
                "\t#endif",
                "#endif",
                "#ifdef USE_SKINNING",
                "\tattribute vec4 skinIndex;",
                "\tattribute vec4 skinWeight;",
                "#endif",
                "\n",
              ]
                .filter(ns)
                .join("\n")),
              (a = [
                _,
                ps(n),
                "#define SHADER_NAME " + n.shaderName,
                w,
                n.alphaTest
                  ? "#define ALPHATEST " +
                    n.alphaTest +
                    (n.alphaTest % 1 ? "" : ".0")
                  : "",
                "#define GAMMA_FACTOR " + b,
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.matcap ? "#define USE_MATCAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + g : "",
                n.envMap ? "#define " + y : "",
                n.envMap ? "#define " + x : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMap && n.objectSpaceNormalMap
                  ? "#define OBJECTSPACE_NORMALMAP"
                  : "",
                n.normalMap && n.tangentSpaceNormalMap
                  ? "#define TANGENTSPACE_NORMALMAP"
                  : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap
                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                  : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.sheen ? "#define USE_SHEEN" : "",
                n.vertexTangents ? "#define USE_TANGENT" : "",
                n.vertexColors ? "#define USE_COLOR" : "",
                n.vertexUvs ? "#define USE_UV" : "",
                n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                n.gradientMap ? "#define USE_GRADIENTMAP" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + p : "",
                n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                n.physicallyCorrectLights
                  ? "#define PHYSICALLY_CORRECT_LIGHTS"
                  : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                (n.extensionShaderTextureLOD || n.envMap) &&
                n.rendererExtensionShaderTextureLod
                  ? "#define TEXTURE_LOD_EXT"
                  : "",
                "uniform mat4 viewMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                n.toneMapping !== te ? "#define TONE_MAPPING" : "",
                n.toneMapping !== te ? Ba.tonemapping_pars_fragment : "",
                n.toneMapping !== te ? ts("toneMapping", n.toneMapping) : "",
                n.dithering ? "#define DITHERING" : "",
                Ba.encodings_pars_fragment,
                n.map ? es("mapTexelToLinear", n.mapEncoding) : "",
                n.matcap ? es("matcapTexelToLinear", n.matcapEncoding) : "",
                n.envMap ? es("envMapTexelToLinear", n.envMapEncoding) : "",
                n.emissiveMap
                  ? es("emissiveMapTexelToLinear", n.emissiveMapEncoding)
                  : "",
                n.lightMap
                  ? es("lightMapTexelToLinear", n.lightMapEncoding)
                  : "",
                ((o = "linearToOutputTexel"),
                (s = n.outputEncoding),
                (c = Qo(s)),
                "vec4 " +
                  o +
                  "( vec4 value ) { return LinearTo" +
                  c[0] +
                  c[1] +
                  "; }"),
                n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
                "\n",
              ]
                .filter(ns)
                .join("\n"))),
          (h = is((h = rs((h = os(h)), n)), n)),
          (d = is((d = rs((d = os(d)), n)), n)),
          (h = ls(h)),
          (d = ls(d)),
          n.isWebGL2 && !n.isRawShaderMaterial)
        ) {
          var S = !1,
            T = /^\s*#version\s+300\s+es\s*\n/;
          n.isShaderMaterial &&
            null !== h.match(T) &&
            null !== d.match(T) &&
            ((S = !0), (h = h.replace(T, "")), (d = d.replace(T, ""))),
            (i =
              [
                "#version 300 es\n",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              i),
            (a =
              [
                "#version 300 es\n",
                "#define varying in",
                S ? "" : "out highp vec4 pc_fragColor;",
                S ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              a);
        }
        var E,
          A,
          L = a + d,
          C = Jo(u, 35633, i + h),
          R = Jo(u, 35632, L);
        if (
          (u.attachShader(M, C),
          u.attachShader(M, R),
          void 0 !== n.index0AttributeName
            ? u.bindAttribLocation(M, 0, n.index0AttributeName)
            : !0 === n.morphTargets && u.bindAttribLocation(M, 0, "position"),
          u.linkProgram(M),
          e.debug.checkShaderErrors)
        ) {
          var P = u.getProgramInfoLog(M).trim(),
            O = u.getShaderInfoLog(C).trim(),
            D = u.getShaderInfoLog(R).trim(),
            I = !0,
            N = !0;
          if (!1 === u.getProgramParameter(M, 35714)) {
            I = !1;
            var B = $o(u, C, "vertex"),
              z = $o(u, R, "fragment");
            console.error(
              "THREE.WebGLProgram: shader error: ",
              u.getError(),
              "35715",
              u.getProgramParameter(M, 35715),
              "gl.getProgramInfoLog",
              P,
              B,
              z
            );
          } else
            "" !== P
              ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", P)
              : ("" !== O && "" !== D) || (N = !1);
          N &&
            (this.diagnostics = {
              runnable: I,
              programLog: P,
              vertexShader: { log: O, prefix: i },
              fragmentShader: { log: D, prefix: a },
            });
        }
        return (
          u.deleteShader(C),
          u.deleteShader(R),
          (this.getUniforms = function () {
            return void 0 === E && (E = new Zo(u, M)), E;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === A &&
                (A = (function (e, t) {
                  for (
                    var n = {}, r = e.getProgramParameter(t, 35721), i = 0;
                    i < r;
                    i++
                  ) {
                    var a = e.getActiveAttrib(t, i).name;
                    n[a] = e.getAttribLocation(t, a);
                  }
                  return n;
                })(u, M)),
              A
            );
          }),
          (this.destroy = function () {
            r.releaseStatesOfProgram(this),
              u.deleteProgram(M),
              (this.program = void 0);
          }),
          (this.name = n.shaderName),
          (this.id = Ko++),
          (this.cacheKey = t),
          (this.usedTimes = 1),
          (this.program = M),
          (this.vertexShader = C),
          (this.fragmentShader = R),
          this
        );
      }
      function ms(e, t, n, r) {
        var i = [],
          a = n.isWebGL2,
          o = n.logarithmicDepthBuffer,
          s = n.floatVertexTextures,
          c = n.maxVertexUniforms,
          u = n.vertexTextures,
          l = n.precision,
          h = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          },
          d = [
            "precision",
            "isWebGL2",
            "supportsVertexTextures",
            "outputEncoding",
            "instancing",
            "map",
            "mapEncoding",
            "matcap",
            "matcapEncoding",
            "envMap",
            "envMapMode",
            "envMapEncoding",
            "envMapCubeUV",
            "lightMap",
            "lightMapEncoding",
            "aoMap",
            "emissiveMap",
            "emissiveMapEncoding",
            "bumpMap",
            "normalMap",
            "objectSpaceNormalMap",
            "tangentSpaceNormalMap",
            "clearcoatMap",
            "clearcoatRoughnessMap",
            "clearcoatNormalMap",
            "displacementMap",
            "specularMap",
            "roughnessMap",
            "metalnessMap",
            "gradientMap",
            "alphaMap",
            "combine",
            "vertexColors",
            "vertexTangents",
            "vertexUvs",
            "uvsVertexOnly",
            "fog",
            "useFog",
            "fogExp2",
            "flatShading",
            "sizeAttenuation",
            "logarithmicDepthBuffer",
            "skinning",
            "maxBones",
            "useVertexTexture",
            "morphTargets",
            "morphNormals",
            "maxMorphTargets",
            "maxMorphNormals",
            "premultipliedAlpha",
            "numDirLights",
            "numPointLights",
            "numSpotLights",
            "numHemiLights",
            "numRectAreaLights",
            "numDirLightShadows",
            "numPointLightShadows",
            "numSpotLightShadows",
            "shadowMapEnabled",
            "shadowMapType",
            "toneMapping",
            "physicallyCorrectLights",
            "alphaTest",
            "doubleSided",
            "flipSided",
            "numClippingPlanes",
            "numClipIntersection",
            "depthPacking",
            "dithering",
            "sheen",
          ];
        function p(e) {
          var t;
          return (
            e
              ? e.isTexture
                ? (t = e.encoding)
                : e.isWebGLRenderTarget &&
                  (console.warn(
                    "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                  ),
                  (t = e.texture.encoding))
              : (t = $t),
            t
          );
        }
        return {
          getParameters: function (r, i, d, f, m, v, g) {
            var b = f.fog,
              _ = r.envMap || (r.isMeshStandardMaterial ? f.environment : null),
              w = h[r.type],
              M = g.isSkinnedMesh
                ? (function (e) {
                    var t = e.skeleton.bones;
                    if (s) return 1024;
                    var n = Math.floor((c - 20) / 4),
                      r = Math.min(n, t.length);
                    return r < t.length
                      ? (console.warn(
                          "THREE.WebGLRenderer: Skeleton has " +
                            t.length +
                            " bones. This GPU supports " +
                            r +
                            "."
                        ),
                        0)
                      : r;
                  })(g)
                : 0;
            null !== r.precision &&
              (l = n.getMaxPrecision(r.precision)) !== r.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                r.precision,
                "not supported, using",
                l,
                "instead."
              );
            var S = (function (e, t) {
              var n;
              if (t) {
                var r = za[t];
                n = {
                  name: e.name || e.type,
                  uniforms: _a.clone(r.uniforms),
                  vertexShader: r.vertexShader,
                  fragmentShader: r.fragmentShader,
                };
              } else
                n = {
                  name: e.name || e.type,
                  uniforms: e.uniforms,
                  vertexShader: e.vertexShader,
                  fragmentShader: e.fragmentShader,
                };
              return n;
            })(r, w);
            r.onBeforeCompile(S, e);
            var T = e.getRenderTarget();
            return {
              isWebGL2: a,
              shaderID: w,
              shaderName: S.name,
              uniforms: S.uniforms,
              vertexShader: S.vertexShader,
              fragmentShader: S.fragmentShader,
              defines: r.defines,
              isRawShaderMaterial: r.isRawShaderMaterial,
              isShaderMaterial: r.isShaderMaterial,
              precision: l,
              instancing: !0 === g.isInstancedMesh,
              supportsVertexTextures: u,
              outputEncoding: null !== T ? p(T.texture) : e.outputEncoding,
              map: !!r.map,
              mapEncoding: p(r.map),
              matcap: !!r.matcap,
              matcapEncoding: p(r.matcap),
              envMap: !!_,
              envMapMode: _ && _.mapping,
              envMapEncoding: p(_),
              envMapCubeUV: !!_ && (_.mapping === de || _.mapping === pe),
              lightMap: !!r.lightMap,
              lightMapEncoding: p(r.lightMap),
              aoMap: !!r.aoMap,
              emissiveMap: !!r.emissiveMap,
              emissiveMapEncoding: p(r.emissiveMap),
              bumpMap: !!r.bumpMap,
              normalMap: !!r.normalMap,
              objectSpaceNormalMap: r.normalMapType === hn,
              tangentSpaceNormalMap: r.normalMapType === ln,
              clearcoatMap: !!r.clearcoatMap,
              clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
              clearcoatNormalMap: !!r.clearcoatNormalMap,
              displacementMap: !!r.displacementMap,
              roughnessMap: !!r.roughnessMap,
              metalnessMap: !!r.metalnessMap,
              specularMap: !!r.specularMap,
              alphaMap: !!r.alphaMap,
              gradientMap: !!r.gradientMap,
              sheen: !!r.sheen,
              combine: r.combine,
              vertexTangents: r.normalMap && r.vertexTangents,
              vertexColors: r.vertexColors,
              vertexUvs: !!(
                r.map ||
                r.bumpMap ||
                r.normalMap ||
                r.specularMap ||
                r.alphaMap ||
                r.emissiveMap ||
                r.roughnessMap ||
                r.metalnessMap ||
                r.clearcoatMap ||
                r.clearcoatRoughnessMap ||
                r.clearcoatNormalMap ||
                r.displacementMap
              ),
              uvsVertexOnly: !(
                r.map ||
                r.bumpMap ||
                r.normalMap ||
                r.specularMap ||
                r.alphaMap ||
                r.emissiveMap ||
                r.roughnessMap ||
                r.metalnessMap ||
                r.clearcoatNormalMap ||
                !r.displacementMap
              ),
              fog: !!b,
              useFog: r.fog,
              fogExp2: b && b.isFogExp2,
              flatShading: r.flatShading,
              sizeAttenuation: r.sizeAttenuation,
              logarithmicDepthBuffer: o,
              skinning: r.skinning && M > 0,
              maxBones: M,
              useVertexTexture: s,
              morphTargets: r.morphTargets,
              morphNormals: r.morphNormals,
              maxMorphTargets: e.maxMorphTargets,
              maxMorphNormals: e.maxMorphNormals,
              numDirLights: i.directional.length,
              numPointLights: i.point.length,
              numSpotLights: i.spot.length,
              numRectAreaLights: i.rectArea.length,
              numHemiLights: i.hemi.length,
              numDirLightShadows: i.directionalShadowMap.length,
              numPointLightShadows: i.pointShadowMap.length,
              numSpotLightShadows: i.spotShadowMap.length,
              numClippingPlanes: m,
              numClipIntersection: v,
              dithering: r.dithering,
              shadowMapEnabled: e.shadowMap.enabled && d.length > 0,
              shadowMapType: e.shadowMap.type,
              toneMapping: r.toneMapped ? e.toneMapping : te,
              physicallyCorrectLights: e.physicallyCorrectLights,
              premultipliedAlpha: r.premultipliedAlpha,
              alphaTest: r.alphaTest,
              doubleSided: r.side === x,
              flipSided: r.side === y,
              depthPacking: void 0 !== r.depthPacking && r.depthPacking,
              index0AttributeName: r.index0AttributeName,
              extensionDerivatives: r.extensions && r.extensions.derivatives,
              extensionFragDepth: r.extensions && r.extensions.fragDepth,
              extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
              extensionShaderTextureLOD:
                r.extensions && r.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: a || null !== t.get("EXT_frag_depth"),
              rendererExtensionDrawBuffers:
                a || null !== t.get("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod:
                a || null !== t.get("EXT_shader_texture_lod"),
              customProgramCacheKey: r.customProgramCacheKey(),
            };
          },
          getProgramCacheKey: function (t) {
            var n = [];
            if (
              (t.shaderID
                ? n.push(t.shaderID)
                : (n.push(t.fragmentShader), n.push(t.vertexShader)),
              void 0 !== t.defines)
            )
              for (var r in t.defines) n.push(r), n.push(t.defines[r]);
            if (void 0 === t.isRawShaderMaterial) {
              for (var i = 0; i < d.length; i++) n.push(t[d[i]]);
              n.push(e.outputEncoding), n.push(e.gammaFactor);
            }
            return n.push(t.customProgramCacheKey), n.join();
          },
          acquireProgram: function (t, n) {
            for (var a, o = 0, s = i.length; o < s; o++) {
              var c = i[o];
              if (c.cacheKey === n) {
                ++(a = c).usedTimes;
                break;
              }
            }
            return void 0 === a && ((a = new fs(e, n, t, r)), i.push(a)), a;
          },
          releaseProgram: function (e) {
            if (0 == --e.usedTimes) {
              var t = i.indexOf(e);
              (i[t] = i[i.length - 1]), i.pop(), e.destroy();
            }
          },
          programs: i,
        };
      }
      function vs() {
        var e = new WeakMap();
        return {
          get: function (t) {
            var n = e.get(t);
            return void 0 === n && ((n = {}), e.set(t, n)), n;
          },
          remove: function (t) {
            e.delete(t);
          },
          update: function (t, n, r) {
            e.get(t)[n] = r;
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function gs(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.program !== t.program
          ? e.program.id - t.program.id
          : e.material.id !== t.material.id
          ? e.material.id - t.material.id
          : e.z !== t.z
          ? e.z - t.z
          : e.id - t.id;
      }
      function ys(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.z !== t.z
          ? t.z - e.z
          : e.id - t.id;
      }
      function xs() {
        var e = [],
          t = 0,
          n = [],
          r = [],
          i = { id: -1 };
        function a(n, r, a, o, s, c) {
          var u = e[t];
          return (
            void 0 === u
              ? ((u = {
                  id: n.id,
                  object: n,
                  geometry: r,
                  material: a,
                  program: a.program || i,
                  groupOrder: o,
                  renderOrder: n.renderOrder,
                  z: s,
                  group: c,
                }),
                (e[t] = u))
              : ((u.id = n.id),
                (u.object = n),
                (u.geometry = r),
                (u.material = a),
                (u.program = a.program || i),
                (u.groupOrder = o),
                (u.renderOrder = n.renderOrder),
                (u.z = s),
                (u.group = c)),
            t++,
            u
          );
        }
        return {
          opaque: n,
          transparent: r,
          init: function () {
            (t = 0), (n.length = 0), (r.length = 0);
          },
          push: function (e, t, i, o, s, c) {
            var u = a(e, t, i, o, s, c);
            (!0 === i.transparent ? r : n).push(u);
          },
          unshift: function (e, t, i, o, s, c) {
            var u = a(e, t, i, o, s, c);
            (!0 === i.transparent ? r : n).unshift(u);
          },
          finish: function () {
            for (var n = t, r = e.length; n < r; n++) {
              var i = e[n];
              if (null === i.id) break;
              (i.id = null),
                (i.object = null),
                (i.geometry = null),
                (i.material = null),
                (i.program = null),
                (i.group = null);
            }
          },
          sort: function (e, t) {
            n.length > 1 && n.sort(e || gs), r.length > 1 && r.sort(t || ys);
          },
        };
      }
      function bs() {
        var e = new WeakMap();
        function t(n) {
          var r = n.target;
          r.removeEventListener("dispose", t), e.delete(r);
        }
        return {
          get: function (n, r) {
            var i,
              a = e.get(n);
            return (
              void 0 === a
                ? ((i = new xs()),
                  e.set(n, new WeakMap()),
                  e.get(n).set(r, i),
                  n.addEventListener("dispose", t))
                : void 0 === (i = a.get(r)) && ((i = new xs()), a.set(r, i)),
              i
            );
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function _s() {
        var e = {};
        return {
          get: function (t) {
            if (void 0 !== e[t.id]) return e[t.id];
            var n;
            switch (t.type) {
              case "DirectionalLight":
                n = { direction: new $n(), color: new vi() };
                break;
              case "SpotLight":
                n = {
                  position: new $n(),
                  direction: new $n(),
                  color: new vi(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                n = {
                  position: new $n(),
                  color: new vi(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                n = {
                  direction: new $n(),
                  skyColor: new vi(),
                  groundColor: new vi(),
                };
                break;
              case "RectAreaLight":
                n = {
                  color: new vi(),
                  position: new $n(),
                  halfWidth: new $n(),
                  halfHeight: new $n(),
                };
            }
            return (e[t.id] = n), n;
          },
        };
      }
      var ws = 0;
      function Ms(e, t) {
        return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
      }
      function Ss() {
        for (
          var e,
            t = new _s(),
            n =
              ((e = {}),
              {
                get: function (t) {
                  if (void 0 !== e[t.id]) return e[t.id];
                  var n;
                  switch (t.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Hn(),
                      };
                      break;
                    case "PointLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Hn(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                      };
                  }
                  return (e[t.id] = n), n;
                },
              }),
            r = {
              version: 0,
              hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
              },
              ambient: [0, 0, 0],
              probe: [],
              directional: [],
              directionalShadow: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotShadow: [],
              spotShadowMap: [],
              spotShadowMatrix: [],
              rectArea: [],
              point: [],
              pointShadow: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: [],
            },
            i = 0;
          i < 9;
          i++
        )
          r.probe.push(new $n());
        var a = new $n(),
          o = new sr(),
          s = new sr();
        return {
          setup: function (e, i, c) {
            for (var u = 0, l = 0, h = 0, d = 0; d < 9; d++)
              r.probe[d].set(0, 0, 0);
            var p = 0,
              f = 0,
              m = 0,
              v = 0,
              g = 0,
              y = 0,
              x = 0,
              b = 0,
              _ = c.matrixWorldInverse;
            e.sort(Ms);
            for (var w = 0, M = e.length; w < M; w++) {
              var S = e[w],
                T = S.color,
                E = S.intensity,
                A = S.distance,
                L = S.shadow && S.shadow.map ? S.shadow.map.texture : null;
              if (S.isAmbientLight)
                (u += T.r * E), (l += T.g * E), (h += T.b * E);
              else if (S.isLightProbe)
                for (var C = 0; C < 9; C++)
                  r.probe[C].addScaledVector(S.sh.coefficients[C], E);
              else if (S.isDirectionalLight) {
                var R = t.get(S);
                if (
                  (R.color.copy(S.color).multiplyScalar(S.intensity),
                  R.direction.setFromMatrixPosition(S.matrixWorld),
                  a.setFromMatrixPosition(S.target.matrixWorld),
                  R.direction.sub(a),
                  R.direction.transformDirection(_),
                  S.castShadow)
                ) {
                  var P = S.shadow,
                    O = n.get(S);
                  (O.shadowBias = P.bias),
                    (O.shadowNormalBias = P.normalBias),
                    (O.shadowRadius = P.radius),
                    (O.shadowMapSize = P.mapSize),
                    (r.directionalShadow[p] = O),
                    (r.directionalShadowMap[p] = L),
                    (r.directionalShadowMatrix[p] = S.shadow.matrix),
                    y++;
                }
                (r.directional[p] = R), p++;
              } else if (S.isSpotLight) {
                var D = t.get(S);
                if (
                  (D.position.setFromMatrixPosition(S.matrixWorld),
                  D.position.applyMatrix4(_),
                  D.color.copy(T).multiplyScalar(E),
                  (D.distance = A),
                  D.direction.setFromMatrixPosition(S.matrixWorld),
                  a.setFromMatrixPosition(S.target.matrixWorld),
                  D.direction.sub(a),
                  D.direction.transformDirection(_),
                  (D.coneCos = Math.cos(S.angle)),
                  (D.penumbraCos = Math.cos(S.angle * (1 - S.penumbra))),
                  (D.decay = S.decay),
                  S.castShadow)
                ) {
                  var I = S.shadow,
                    N = n.get(S);
                  (N.shadowBias = I.bias),
                    (N.shadowNormalBias = I.normalBias),
                    (N.shadowRadius = I.radius),
                    (N.shadowMapSize = I.mapSize),
                    (r.spotShadow[m] = N),
                    (r.spotShadowMap[m] = L),
                    (r.spotShadowMatrix[m] = S.shadow.matrix),
                    b++;
                }
                (r.spot[m] = D), m++;
              } else if (S.isRectAreaLight) {
                var B = t.get(S);
                B.color.copy(T).multiplyScalar(E),
                  B.position.setFromMatrixPosition(S.matrixWorld),
                  B.position.applyMatrix4(_),
                  s.identity(),
                  o.copy(S.matrixWorld),
                  o.premultiply(_),
                  s.extractRotation(o),
                  B.halfWidth.set(0.5 * S.width, 0, 0),
                  B.halfHeight.set(0, 0.5 * S.height, 0),
                  B.halfWidth.applyMatrix4(s),
                  B.halfHeight.applyMatrix4(s),
                  (r.rectArea[v] = B),
                  v++;
              } else if (S.isPointLight) {
                var z = t.get(S);
                if (
                  (z.position.setFromMatrixPosition(S.matrixWorld),
                  z.position.applyMatrix4(_),
                  z.color.copy(S.color).multiplyScalar(S.intensity),
                  (z.distance = S.distance),
                  (z.decay = S.decay),
                  S.castShadow)
                ) {
                  var F = S.shadow,
                    U = n.get(S);
                  (U.shadowBias = F.bias),
                    (U.shadowNormalBias = F.normalBias),
                    (U.shadowRadius = F.radius),
                    (U.shadowMapSize = F.mapSize),
                    (U.shadowCameraNear = F.camera.near),
                    (U.shadowCameraFar = F.camera.far),
                    (r.pointShadow[f] = U),
                    (r.pointShadowMap[f] = L),
                    (r.pointShadowMatrix[f] = S.shadow.matrix),
                    x++;
                }
                (r.point[f] = z), f++;
              } else if (S.isHemisphereLight) {
                var G = t.get(S);
                G.direction.setFromMatrixPosition(S.matrixWorld),
                  G.direction.transformDirection(_),
                  G.direction.normalize(),
                  G.skyColor.copy(S.color).multiplyScalar(E),
                  G.groundColor.copy(S.groundColor).multiplyScalar(E),
                  (r.hemi[g] = G),
                  g++;
              }
            }
            (r.ambient[0] = u), (r.ambient[1] = l), (r.ambient[2] = h);
            var k = r.hash;
            (k.directionalLength === p &&
              k.pointLength === f &&
              k.spotLength === m &&
              k.rectAreaLength === v &&
              k.hemiLength === g &&
              k.numDirectionalShadows === y &&
              k.numPointShadows === x &&
              k.numSpotShadows === b) ||
              ((r.directional.length = p),
              (r.spot.length = m),
              (r.rectArea.length = v),
              (r.point.length = f),
              (r.hemi.length = g),
              (r.directionalShadow.length = y),
              (r.directionalShadowMap.length = y),
              (r.pointShadow.length = x),
              (r.pointShadowMap.length = x),
              (r.spotShadow.length = b),
              (r.spotShadowMap.length = b),
              (r.directionalShadowMatrix.length = y),
              (r.pointShadowMatrix.length = x),
              (r.spotShadowMatrix.length = b),
              (k.directionalLength = p),
              (k.pointLength = f),
              (k.spotLength = m),
              (k.rectAreaLength = v),
              (k.hemiLength = g),
              (k.numDirectionalShadows = y),
              (k.numPointShadows = x),
              (k.numSpotShadows = b),
              (r.version = ws++));
          },
          state: r,
        };
      }
      function Ts() {
        var e = new Ss(),
          t = [],
          n = [];
        return {
          init: function () {
            (t.length = 0), (n.length = 0);
          },
          state: { lightsArray: t, shadowsArray: n, lights: e },
          setupLights: function (r) {
            e.setup(t, n, r);
          },
          pushLight: function (e) {
            t.push(e);
          },
          pushShadow: function (e) {
            n.push(e);
          },
        };
      }
      function Es() {
        var e = new WeakMap();
        function t(n) {
          var r = n.target;
          r.removeEventListener("dispose", t), e.delete(r);
        }
        return {
          get: function (n, r) {
            var i;
            return (
              !1 === e.has(n)
                ? ((i = new Ts()),
                  e.set(n, new WeakMap()),
                  e.get(n).set(r, i),
                  n.addEventListener("dispose", t))
                : !1 === e.get(n).has(r)
                ? ((i = new Ts()), e.get(n).set(r, i))
                : (i = e.get(n).get(r)),
              i
            );
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function As(e) {
        wi.call(this),
          (this.type = "MeshDepthMaterial"),
          (this.depthPacking = cn),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          this.setValues(e);
      }
      function Ls(e) {
        wi.call(this),
          (this.type = "MeshDistanceMaterial"),
          (this.referencePosition = new $n()),
          (this.nearDistance = 1),
          (this.farDistance = 1e3),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.fog = !1),
          this.setValues(e);
      }
      function Cs(e, t, n) {
        var r = new Ra(),
          i = new Hn(),
          a = new Hn(),
          o = new Xn(),
          s = [],
          c = [],
          u = {},
          l = { 0: y, 1: g, 2: x },
          h = new wa({
            defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new Hn() },
              radius: { value: 4 },
            },
            vertexShader:
              "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader:
              "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
          }),
          d = h.clone();
        d.defines.HORIZONAL_PASS = 1;
        var p = new Wi();
        p.setAttribute(
          "position",
          new Ei(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        var m = new ua(p, h),
          b = this;
        function _(n, r) {
          var i = t.update(m);
          (h.uniforms.shadow_pass.value = n.map.texture),
            (h.uniforms.resolution.value = n.mapSize),
            (h.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.mapPass),
            e.clear(),
            e.renderBufferDirect(r, null, i, h, m, null),
            (d.uniforms.shadow_pass.value = n.mapPass.texture),
            (d.uniforms.resolution.value = n.mapSize),
            (d.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.map),
            e.clear(),
            e.renderBufferDirect(r, null, i, d, m, null);
        }
        function M(e, t, n) {
          var r = (e << 0) | (t << 1) | (n << 2),
            i = s[r];
          return (
            void 0 === i &&
              ((i = new As({ depthPacking: un, morphTargets: e, skinning: t })),
              (s[r] = i)),
            i
          );
        }
        function S(e, t, n) {
          var r = (e << 0) | (t << 1) | (n << 2),
            i = c[r];
          return (
            void 0 === i &&
              ((i = new Ls({ morphTargets: e, skinning: t })), (c[r] = i)),
            i
          );
        }
        function T(t, n, r, i, a, o, s) {
          var c = null,
            h = M,
            d = t.customDepthMaterial;
          if (
            (!0 === i.isPointLight && ((h = S), (d = t.customDistanceMaterial)),
            void 0 === d)
          ) {
            var p = !1;
            !0 === r.morphTargets &&
              (p =
                n.morphAttributes &&
                n.morphAttributes.position &&
                n.morphAttributes.position.length > 0);
            var f = !1;
            !0 === t.isSkinnedMesh &&
              (!0 === r.skinning
                ? (f = !0)
                : console.warn(
                    "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                    t
                  )),
              (c = h(p, f, !0 === t.isInstancedMesh));
          } else c = d;
          if (
            e.localClippingEnabled &&
            !0 === r.clipShadows &&
            0 !== r.clippingPlanes.length
          ) {
            var m = c.uuid,
              g = r.uuid,
              y = u[m];
            void 0 === y && ((y = {}), (u[m] = y));
            var x = y[g];
            void 0 === x && ((x = c.clone()), (y[g] = x)), (c = x);
          }
          return (
            (c.visible = r.visible),
            (c.wireframe = r.wireframe),
            (c.side =
              s === v
                ? null !== r.shadowSide
                  ? r.shadowSide
                  : r.side
                : null !== r.shadowSide
                ? r.shadowSide
                : l[r.side]),
            (c.clipShadows = r.clipShadows),
            (c.clippingPlanes = r.clippingPlanes),
            (c.clipIntersection = r.clipIntersection),
            (c.wireframeLinewidth = r.wireframeLinewidth),
            (c.linewidth = r.linewidth),
            !0 === i.isPointLight &&
              !0 === c.isMeshDistanceMaterial &&
              (c.referencePosition.setFromMatrixPosition(i.matrixWorld),
              (c.nearDistance = a),
              (c.farDistance = o)),
            c
          );
        }
        function E(n, i, a, o, s) {
          if (!1 !== n.visible) {
            if (
              n.layers.test(i.layers) &&
              (n.isMesh || n.isLine || n.isPoints) &&
              (n.castShadow || (n.receiveShadow && s === v)) &&
              (!n.frustumCulled || r.intersectsObject(n))
            ) {
              n.modelViewMatrix.multiplyMatrices(
                a.matrixWorldInverse,
                n.matrixWorld
              );
              var c = t.update(n),
                u = n.material;
              if (Array.isArray(u))
                for (var l = c.groups, h = 0, d = l.length; h < d; h++) {
                  var p = l[h],
                    f = u[p.materialIndex];
                  if (f && f.visible) {
                    var m = T(n, c, f, o, a.near, a.far, s);
                    e.renderBufferDirect(a, null, c, m, n, p);
                  }
                }
              else if (u.visible) {
                var g = T(n, c, u, o, a.near, a.far, s);
                e.renderBufferDirect(a, null, c, g, n, null);
              }
            }
            for (var y = n.children, x = 0, b = y.length; x < b; x++)
              E(y[x], i, a, o, s);
          }
        }
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = f),
          (this.render = function (t, s, c) {
            if (
              !1 !== b.enabled &&
              (!1 !== b.autoUpdate || !1 !== b.needsUpdate) &&
              0 !== t.length
            ) {
              var u = e.getRenderTarget(),
                l = e.getActiveCubeFace(),
                h = e.getActiveMipmapLevel(),
                d = e.state;
              d.setBlending(w),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
              for (var p = 0, f = t.length; p < f; p++) {
                var m = t[p],
                  g = m.shadow;
                if (!1 !== g.autoUpdate || !1 !== g.needsUpdate)
                  if (void 0 !== g) {
                    i.copy(g.mapSize);
                    var y = g.getFrameExtents();
                    if (
                      (i.multiply(y),
                      a.copy(g.mapSize),
                      (i.x > n || i.y > n) &&
                        (i.x > n &&
                          ((a.x = Math.floor(n / y.x)),
                          (i.x = a.x * y.x),
                          (g.mapSize.x = a.x)),
                        i.y > n &&
                          ((a.y = Math.floor(n / y.y)),
                          (i.y = a.y * y.y),
                          (g.mapSize.y = a.y))),
                      null === g.map &&
                        !g.isPointLightShadow &&
                        this.type === v)
                    ) {
                      var x = { minFilter: we, magFilter: we, format: ke };
                      (g.map = new Yn(i.x, i.y, x)),
                        (g.map.texture.name = m.name + ".shadowMap"),
                        (g.mapPass = new Yn(i.x, i.y, x)),
                        g.camera.updateProjectionMatrix();
                    }
                    null === g.map &&
                      ((g.map = new Yn(i.x, i.y, {
                        minFilter: ge,
                        magFilter: ge,
                        format: ke,
                      })),
                      (g.map.texture.name = m.name + ".shadowMap"),
                      g.camera.updateProjectionMatrix()),
                      e.setRenderTarget(g.map),
                      e.clear();
                    for (var M = g.getViewportCount(), S = 0; S < M; S++) {
                      var T = g.getViewport(S);
                      o.set(a.x * T.x, a.y * T.y, a.x * T.z, a.y * T.w),
                        d.viewport(o),
                        g.updateMatrices(m, S),
                        (r = g.getFrustum()),
                        E(s, c, g.camera, m, this.type);
                    }
                    g.isPointLightShadow || this.type !== v || _(g, c),
                      (g.needsUpdate = !1);
                  } else
                    console.warn("THREE.WebGLShadowMap:", m, "has no shadow.");
              }
              (b.needsUpdate = !1), e.setRenderTarget(u, l, h);
            }
          });
      }
      function Rs(e, t, n) {
        var r,
          i,
          a = n.isWebGL2,
          o = new (function () {
            var t = !1,
              n = new Xn(),
              r = null,
              i = new Xn(0, 0, 0, 0);
            return {
              setMask: function (n) {
                r === n || t || (e.colorMask(n, n, n, n), (r = n));
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t, r, a, o, s) {
                !0 === s && ((t *= o), (r *= o), (a *= o)),
                  n.set(t, r, a, o),
                  !1 === i.equals(n) && (e.clearColor(t, r, a, o), i.copy(n));
              },
              reset: function () {
                (t = !1), (r = null), i.set(-1, 0, 0, 0);
              },
            };
          })(),
          l = new (function () {
            var t = !1,
              n = null,
              r = null,
              i = null;
            return {
              setTest: function (e) {
                e ? ve(2929) : ge(2929);
              },
              setMask: function (r) {
                n === r || t || (e.depthMask(r), (n = r));
              },
              setFunc: function (t) {
                if (r !== t) {
                  if (t)
                    switch (t) {
                      case V:
                        e.depthFunc(512);
                        break;
                      case W:
                        e.depthFunc(519);
                        break;
                      case q:
                        e.depthFunc(513);
                        break;
                      case X:
                        e.depthFunc(515);
                        break;
                      case Y:
                        e.depthFunc(514);
                        break;
                      case Z:
                        e.depthFunc(518);
                        break;
                      case J:
                        e.depthFunc(516);
                        break;
                      case K:
                        e.depthFunc(517);
                        break;
                      default:
                        e.depthFunc(515);
                    }
                  else e.depthFunc(515);
                  r = t;
                }
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t) {
                i !== t && (e.clearDepth(t), (i = t));
              },
              reset: function () {
                (t = !1), (n = null), (r = null), (i = null);
              },
            };
          })(),
          h = new (function () {
            var t = !1,
              n = null,
              r = null,
              i = null,
              a = null,
              o = null,
              s = null,
              c = null,
              u = null;
            return {
              setTest: function (e) {
                t || (e ? ve(2960) : ge(2960));
              },
              setMask: function (r) {
                n === r || t || (e.stencilMask(r), (n = r));
              },
              setFunc: function (t, n, o) {
                (r === t && i === n && a === o) ||
                  (e.stencilFunc(t, n, o), (r = t), (i = n), (a = o));
              },
              setOp: function (t, n, r) {
                (o === t && s === n && c === r) ||
                  (e.stencilOp(t, n, r), (o = t), (s = n), (c = r));
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t) {
                u !== t && (e.clearStencil(t), (u = t));
              },
              reset: function () {
                (t = !1),
                  (n = null),
                  (r = null),
                  (i = null),
                  (a = null),
                  (o = null),
                  (s = null),
                  (c = null),
                  (u = null);
              },
            };
          })(),
          d = {},
          p = null,
          f = null,
          m = null,
          v = null,
          g = null,
          b = null,
          _ = null,
          Q = null,
          $ = null,
          ee = !1,
          te = null,
          ne = null,
          re = null,
          ie = null,
          ae = null,
          oe = e.getParameter(35661),
          se = !1,
          ce = 0,
          ue = e.getParameter(7938);
        -1 !== ue.indexOf("WebGL")
          ? ((ce = parseFloat(/^WebGL\ ([0-9])/.exec(ue)[1])), (se = ce >= 1))
          : -1 !== ue.indexOf("OpenGL ES") &&
            ((ce = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(ue)[1])),
            (se = ce >= 2));
        var le = null,
          he = {},
          de = new Xn(),
          pe = new Xn();
        function fe(t, n, r) {
          var i = new Uint8Array(4),
            a = e.createTexture();
          e.bindTexture(t, a),
            e.texParameteri(t, 10241, 9728),
            e.texParameteri(t, 10240, 9728);
          for (var o = 0; o < r; o++)
            e.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, i);
          return a;
        }
        var me = {};
        function ve(t) {
          !0 !== d[t] && (e.enable(t), (d[t] = !0));
        }
        function ge(t) {
          !1 !== d[t] && (e.disable(t), (d[t] = !1));
        }
        (me[3553] = fe(3553, 3553, 1)),
          (me[34067] = fe(34067, 34069, 6)),
          o.setClear(0, 0, 0, 1),
          l.setClear(1),
          h.setClear(0),
          ve(2929),
          l.setFunc(X),
          we(!1),
          Me(c),
          ve(2884),
          _e(w);
        var ye =
          (_defineProperty((r = {}), L, 32774),
          _defineProperty(r, C, 32778),
          _defineProperty(r, R, 32779),
          r);
        if (a) (ye[P] = 32775), (ye[O] = 32776);
        else {
          var xe = t.get("EXT_blend_minmax");
          null !== xe && ((ye[P] = xe.MIN_EXT), (ye[O] = xe.MAX_EXT));
        }
        var be =
          (_defineProperty((i = {}), D, 0),
          _defineProperty(i, I, 1),
          _defineProperty(i, N, 768),
          _defineProperty(i, z, 770),
          _defineProperty(i, j, 776),
          _defineProperty(i, k, 774),
          _defineProperty(i, U, 772),
          _defineProperty(i, B, 769),
          _defineProperty(i, F, 771),
          _defineProperty(i, H, 775),
          _defineProperty(i, G, 773),
          i);
        function _e(t, n, r, i, a, o, s, c) {
          if (t !== w) {
            if ((f || (ve(3042), (f = !0)), t === A))
              (a = a || n),
                (o = o || r),
                (s = s || i),
                (n === v && a === _) ||
                  (e.blendEquationSeparate(ye[n], ye[a]), (v = n), (_ = a)),
                (r === g && i === b && o === Q && s === $) ||
                  (e.blendFuncSeparate(be[r], be[i], be[o], be[s]),
                  (g = r),
                  (b = i),
                  (Q = o),
                  ($ = s)),
                (m = t),
                (ee = null);
            else if (t !== m || c !== ee) {
              if (
                ((v === L && _ === L) ||
                  (e.blendEquation(32774), (v = L), (_ = L)),
                c)
              )
                switch (t) {
                  case M:
                    e.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case S:
                    e.blendFunc(1, 1);
                    break;
                  case T:
                    e.blendFuncSeparate(0, 0, 769, 771);
                    break;
                  case E:
                    e.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              else
                switch (t) {
                  case M:
                    e.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case S:
                    e.blendFunc(770, 1);
                    break;
                  case T:
                    e.blendFunc(0, 769);
                    break;
                  case E:
                    e.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              (g = null), (b = null), (Q = null), ($ = null), (m = t), (ee = c);
            }
          } else f && (ge(3042), (f = !1));
        }
        function we(t) {
          te !== t && (e.frontFace(t ? 2304 : 2305), (te = t));
        }
        function Me(t) {
          t !== s
            ? (ve(2884),
              t !== ne && e.cullFace(t === c ? 1029 : t === u ? 1028 : 1032))
            : ge(2884),
            (ne = t);
        }
        function Se(t, n, r) {
          t
            ? (ve(32823),
              (ie === n && ae === r) ||
                (e.polygonOffset(n, r), (ie = n), (ae = r)))
            : ge(32823);
        }
        function Te(t) {
          void 0 === t && (t = 33984 + oe - 1),
            le !== t && (e.activeTexture(t), (le = t));
        }
        return {
          buffers: { color: o, depth: l, stencil: h },
          enable: ve,
          disable: ge,
          useProgram: function (t) {
            return p !== t && (e.useProgram(t), (p = t), !0);
          },
          setBlending: _e,
          setMaterial: function (e, t) {
            e.side === x ? ge(2884) : ve(2884);
            var n = e.side === y;
            t && (n = !n),
              we(n),
              e.blending === M && !1 === e.transparent
                ? _e(w)
                : _e(
                    e.blending,
                    e.blendEquation,
                    e.blendSrc,
                    e.blendDst,
                    e.blendEquationAlpha,
                    e.blendSrcAlpha,
                    e.blendDstAlpha,
                    e.premultipliedAlpha
                  ),
              l.setFunc(e.depthFunc),
              l.setTest(e.depthTest),
              l.setMask(e.depthWrite),
              o.setMask(e.colorWrite);
            var r = e.stencilWrite;
            h.setTest(r),
              r &&
                (h.setMask(e.stencilWriteMask),
                h.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                h.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
              Se(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits);
          },
          setFlipSided: we,
          setCullFace: Me,
          setLineWidth: function (t) {
            t !== re && (se && e.lineWidth(t), (re = t));
          },
          setPolygonOffset: Se,
          setScissorTest: function (e) {
            e ? ve(3089) : ge(3089);
          },
          activeTexture: Te,
          bindTexture: function (t, n) {
            null === le && Te();
            var r = he[le];
            void 0 === r &&
              ((r = { type: void 0, texture: void 0 }), (he[le] = r)),
              (r.type === t && r.texture === n) ||
                (e.bindTexture(t, n || me[t]), (r.type = t), (r.texture = n));
          },
          unbindTexture: function () {
            var t = he[le];
            void 0 !== t &&
              void 0 !== t.type &&
              (e.bindTexture(t.type, null),
              (t.type = void 0),
              (t.texture = void 0));
          },
          compressedTexImage2D: function () {
            try {
              e.compressedTexImage2D.apply(e, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage2D: function () {
            try {
              e.texImage2D.apply(e, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage3D: function () {
            try {
              e.texImage3D.apply(e, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          scissor: function (t) {
            !1 === de.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), de.copy(t));
          },
          viewport: function (t) {
            !1 === pe.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), pe.copy(t));
          },
          reset: function () {
            (d = {}),
              (le = null),
              (he = {}),
              (p = null),
              (m = null),
              (te = null),
              (ne = null),
              o.reset(),
              l.reset(),
              h.reset();
          },
        };
      }
      function Ps(e, t, n, r, i, a, o) {
        var s,
          c,
          u,
          l = i.isWebGL2,
          h = i.maxTextures,
          d = i.maxCubemapSize,
          p = i.maxTextureSize,
          f = i.maxSamples,
          m = new WeakMap(),
          v = !1;
        try {
          v =
            "undefined" != typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (G) {}
        function g(e, t) {
          return v
            ? new OffscreenCanvas(e, t)
            : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              );
        }
        function y(e, t, n, r) {
          var i = 1;
          if (
            ((e.width > r || e.height > r) &&
              (i = r / Math.max(e.width, e.height)),
            i < 1 || !0 === t)
          ) {
            if (
              ("undefined" != typeof HTMLImageElement &&
                e instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement &&
                e instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
            ) {
              var a = t ? kn.floorPowerOfTwo : Math.floor,
                o = a(i * e.width),
                s = a(i * e.height);
              void 0 === u && (u = g(o, s));
              var c = n ? g(o, s) : u;
              return (
                (c.width = o),
                (c.height = s),
                c.getContext("2d").drawImage(e, 0, 0, o, s),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    e.width +
                    "x" +
                    e.height +
                    ") to (" +
                    o +
                    "x" +
                    s +
                    ")."
                ),
                c
              );
            }
            return (
              "data" in e &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    e.width +
                    "x" +
                    e.height +
                    ")."
                ),
              e
            );
          }
          return e;
        }
        function x(e) {
          return kn.isPowerOfTwo(e.width) && kn.isPowerOfTwo(e.height);
        }
        function b(e, t) {
          return (
            e.generateMipmaps && t && e.minFilter !== ge && e.minFilter !== we
          );
        }
        function _(t, n, i, a) {
          e.generateMipmap(t),
            (r.get(n).__maxMipLevel = Math.log(Math.max(i, a)) * Math.LOG2E);
        }
        function w(n, r, i) {
          if (!1 === l) return r;
          if (null !== n) {
            if (void 0 !== e[n]) return e[n];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                n +
                "'"
            );
          }
          var a = r;
          return (
            6403 === r &&
              (5126 === i && (a = 33326),
              5131 === i && (a = 33325),
              5121 === i && (a = 33321)),
            6407 === r &&
              (5126 === i && (a = 34837),
              5131 === i && (a = 34843),
              5121 === i && (a = 32849)),
            6408 === r &&
              (5126 === i && (a = 34836),
              5131 === i && (a = 34842),
              5121 === i && (a = 32856)),
            (33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a) ||
              t.get("EXT_color_buffer_float"),
            a
          );
        }
        function M(e) {
          return e === ge || e === ye || e === be ? 9728 : 9729;
        }
        function S(t) {
          var n = t.target;
          n.removeEventListener("dispose", S),
            (function (t) {
              var n = r.get(t);
              void 0 !== n.__webglInit &&
                (e.deleteTexture(n.__webglTexture), r.remove(t));
            })(n),
            n.isVideoTexture && m.delete(n),
            o.memory.textures--;
        }
        function T(t) {
          var n = t.target;
          n.removeEventListener("dispose", T),
            (function (t) {
              var n = r.get(t),
                i = r.get(t.texture);
              if (t) {
                if (
                  (void 0 !== i.__webglTexture &&
                    e.deleteTexture(i.__webglTexture),
                  t.depthTexture && t.depthTexture.dispose(),
                  t.isWebGLCubeRenderTarget)
                )
                  for (var a = 0; a < 6; a++)
                    e.deleteFramebuffer(n.__webglFramebuffer[a]),
                      n.__webglDepthbuffer &&
                        e.deleteRenderbuffer(n.__webglDepthbuffer[a]);
                else
                  e.deleteFramebuffer(n.__webglFramebuffer),
                    n.__webglDepthbuffer &&
                      e.deleteRenderbuffer(n.__webglDepthbuffer),
                    n.__webglMultisampledFramebuffer &&
                      e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                    n.__webglColorRenderbuffer &&
                      e.deleteRenderbuffer(n.__webglColorRenderbuffer),
                    n.__webglDepthRenderbuffer &&
                      e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                r.remove(t.texture), r.remove(t);
              }
            })(n),
            o.memory.textures--;
        }
        var E = 0;
        function A(e, t) {
          var i = r.get(e);
          if (
            (e.isVideoTexture &&
              (function (e) {
                var t = o.render.frame;
                m.get(e) !== t && (m.set(e, t), e.update());
              })(e),
            e.version > 0 && i.__version !== e.version)
          ) {
            var a = e.image;
            if (void 0 === a)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is undefined"
              );
            else {
              if (!1 !== a.complete) return void I(i, e, t);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            }
          }
          n.activeTexture(33984 + t), n.bindTexture(3553, i.__webglTexture);
        }
        function L(t, i) {
          if (6 === t.image.length) {
            var o = r.get(t);
            if (t.version > 0 && o.__version !== t.version) {
              D(o, t),
                n.activeTexture(33984 + i),
                n.bindTexture(34067, o.__webglTexture),
                e.pixelStorei(37440, t.flipY);
              for (
                var s =
                    t &&
                    (t.isCompressedTexture || t.image[0].isCompressedTexture),
                  c = t.image[0] && t.image[0].isDataTexture,
                  u = [],
                  h = 0;
                h < 6;
                h++
              )
                u[h] =
                  s || c
                    ? c
                      ? t.image[h].image
                      : t.image[h]
                    : y(t.image[h], !1, !0, d);
              var p,
                f = u[0],
                m = x(f) || l,
                v = a.convert(t.format),
                g = a.convert(t.type),
                M = w(t.internalFormat, v, g);
              if ((O(34067, t, m), s)) {
                for (var S = 0; S < 6; S++) {
                  p = u[S].mipmaps;
                  for (var T = 0; T < p.length; T++) {
                    var E = p[T];
                    t.format !== ke && t.format !== Ge
                      ? null !== v
                        ? n.compressedTexImage2D(
                            34069 + S,
                            T,
                            M,
                            E.width,
                            E.height,
                            0,
                            E.data
                          )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                          )
                      : n.texImage2D(
                          34069 + S,
                          T,
                          M,
                          E.width,
                          E.height,
                          0,
                          v,
                          g,
                          E.data
                        );
                  }
                }
                o.__maxMipLevel = p.length - 1;
              } else {
                p = t.mipmaps;
                for (var A = 0; A < 6; A++)
                  if (c) {
                    n.texImage2D(
                      34069 + A,
                      0,
                      M,
                      u[A].width,
                      u[A].height,
                      0,
                      v,
                      g,
                      u[A].data
                    );
                    for (var L = 0; L < p.length; L++) {
                      var C = p[L].image[A].image;
                      n.texImage2D(
                        34069 + A,
                        L + 1,
                        M,
                        C.width,
                        C.height,
                        0,
                        v,
                        g,
                        C.data
                      );
                    }
                  } else {
                    n.texImage2D(34069 + A, 0, M, v, g, u[A]);
                    for (var R = 0; R < p.length; R++)
                      n.texImage2D(34069 + A, R + 1, M, v, g, p[R].image[A]);
                  }
                o.__maxMipLevel = p.length;
              }
              b(t, m) && _(34067, t, f.width, f.height),
                (o.__version = t.version),
                t.onUpdate && t.onUpdate(t);
            } else
              n.activeTexture(33984 + i),
                n.bindTexture(34067, o.__webglTexture);
          }
        }
        function C(e, t) {
          n.activeTexture(33984 + t),
            n.bindTexture(34067, r.get(e).__webglTexture);
        }
        var R =
            (_defineProperty((s = {}), fe, 10497),
            _defineProperty(s, me, 33071),
            _defineProperty(s, ve, 33648),
            s),
          P =
            (_defineProperty((c = {}), ge, 9728),
            _defineProperty(c, ye, 9984),
            _defineProperty(c, be, 9986),
            _defineProperty(c, we, 9729),
            _defineProperty(c, Me, 9985),
            _defineProperty(c, Te, 9987),
            c);
        function O(n, a, o) {
          o
            ? (e.texParameteri(n, 10242, R[a.wrapS]),
              e.texParameteri(n, 10243, R[a.wrapT]),
              (32879 !== n && 35866 !== n) ||
                e.texParameteri(n, 32882, R[a.wrapR]),
              e.texParameteri(n, 10240, P[a.magFilter]),
              e.texParameteri(n, 10241, P[a.minFilter]))
            : (e.texParameteri(n, 10242, 33071),
              e.texParameteri(n, 10243, 33071),
              (32879 !== n && 35866 !== n) || e.texParameteri(n, 32882, 33071),
              (a.wrapS === me && a.wrapT === me) ||
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                ),
              e.texParameteri(n, 10240, M(a.magFilter)),
              e.texParameteri(n, 10241, M(a.minFilter)),
              a.minFilter !== ge &&
                a.minFilter !== we &&
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                ));
          var s = t.get("EXT_texture_filter_anisotropic");
          if (s) {
            if (a.type === De && null === t.get("OES_texture_float_linear"))
              return;
            if (
              a.type === Ie &&
              null === (l || t.get("OES_texture_half_float_linear"))
            )
              return;
            (a.anisotropy > 1 || r.get(a).__currentAnisotropy) &&
              (e.texParameterf(
                n,
                s.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(a.anisotropy, i.getMaxAnisotropy())
              ),
              (r.get(a).__currentAnisotropy = a.anisotropy));
          }
        }
        function D(t, n) {
          void 0 === t.__webglInit &&
            ((t.__webglInit = !0),
            n.addEventListener("dispose", S),
            (t.__webglTexture = e.createTexture()),
            o.memory.textures++);
        }
        function I(t, r, i) {
          var o = 3553;
          r.isDataTexture2DArray && (o = 35866),
            r.isDataTexture3D && (o = 32879),
            D(t, r),
            n.activeTexture(33984 + i),
            n.bindTexture(o, t.__webglTexture),
            e.pixelStorei(37440, r.flipY),
            e.pixelStorei(37441, r.premultiplyAlpha),
            e.pixelStorei(3317, r.unpackAlignment);
          var s,
            c =
              (function (e) {
                return (
                  !l &&
                  (e.wrapS !== me ||
                    e.wrapT !== me ||
                    (e.minFilter !== ge && e.minFilter !== we))
                );
              })(r) && !1 === x(r.image),
            u = y(r.image, c, !1, p),
            h = x(u) || l,
            d = a.convert(r.format),
            f = a.convert(r.type),
            m = w(r.internalFormat, d, f);
          O(o, r, h);
          var v = r.mipmaps;
          if (r.isDepthTexture)
            (m = 6402),
              l
                ? (m =
                    r.type === De
                      ? 36012
                      : r.type === Oe
                      ? 33190
                      : r.type === Fe
                      ? 35056
                      : 33189)
                : r.type === De &&
                  console.error(
                    "WebGLRenderer: Floating point depth texture requires WebGL2."
                  ),
              r.format === We &&
                6402 === m &&
                r.type !== Re &&
                r.type !== Oe &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                ),
                (r.type = Re),
                (f = a.convert(r.type))),
              r.format === qe &&
                6402 === m &&
                ((m = 34041),
                r.type !== Fe &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                  (r.type = Fe),
                  (f = a.convert(r.type)))),
              n.texImage2D(3553, 0, m, u.width, u.height, 0, d, f, null);
          else if (r.isDataTexture)
            if (v.length > 0 && h) {
              for (var g = 0, M = v.length; g < M; g++)
                (s = v[g]),
                  n.texImage2D(3553, g, m, s.width, s.height, 0, d, f, s.data);
              (r.generateMipmaps = !1), (t.__maxMipLevel = v.length - 1);
            } else
              n.texImage2D(3553, 0, m, u.width, u.height, 0, d, f, u.data),
                (t.__maxMipLevel = 0);
          else if (r.isCompressedTexture) {
            for (var S = 0, T = v.length; S < T; S++)
              (s = v[S]),
                r.format !== ke && r.format !== Ge
                  ? null !== d
                    ? n.compressedTexImage2D(
                        3553,
                        S,
                        m,
                        s.width,
                        s.height,
                        0,
                        s.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : n.texImage2D(
                      3553,
                      S,
                      m,
                      s.width,
                      s.height,
                      0,
                      d,
                      f,
                      s.data
                    );
            t.__maxMipLevel = v.length - 1;
          } else if (r.isDataTexture2DArray)
            n.texImage3D(
              35866,
              0,
              m,
              u.width,
              u.height,
              u.depth,
              0,
              d,
              f,
              u.data
            ),
              (t.__maxMipLevel = 0);
          else if (r.isDataTexture3D)
            n.texImage3D(
              32879,
              0,
              m,
              u.width,
              u.height,
              u.depth,
              0,
              d,
              f,
              u.data
            ),
              (t.__maxMipLevel = 0);
          else if (v.length > 0 && h) {
            for (var E = 0, A = v.length; E < A; E++)
              (s = v[E]), n.texImage2D(3553, E, m, d, f, s);
            (r.generateMipmaps = !1), (t.__maxMipLevel = v.length - 1);
          } else n.texImage2D(3553, 0, m, d, f, u), (t.__maxMipLevel = 0);
          b(r, h) && _(o, r, u.width, u.height),
            (t.__version = r.version),
            r.onUpdate && r.onUpdate(r);
        }
        function N(t, i, o, s) {
          var c = a.convert(i.texture.format),
            u = a.convert(i.texture.type),
            l = w(i.texture.internalFormat, c, u);
          n.texImage2D(s, 0, l, i.width, i.height, 0, c, u, null),
            e.bindFramebuffer(36160, t),
            e.framebufferTexture2D(
              36160,
              o,
              s,
              r.get(i.texture).__webglTexture,
              0
            ),
            e.bindFramebuffer(36160, null);
        }
        function B(t, n, r) {
          if (
            (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer)
          ) {
            var i = 33189;
            if (r) {
              var o = n.depthTexture;
              o &&
                o.isDepthTexture &&
                (o.type === De ? (i = 36012) : o.type === Oe && (i = 33190));
              var s = z(n);
              e.renderbufferStorageMultisample(36161, s, i, n.width, n.height);
            } else e.renderbufferStorage(36161, i, n.width, n.height);
            e.framebufferRenderbuffer(36160, 36096, 36161, t);
          } else if (n.depthBuffer && n.stencilBuffer) {
            if (r) {
              var c = z(n);
              e.renderbufferStorageMultisample(
                36161,
                c,
                35056,
                n.width,
                n.height
              );
            } else e.renderbufferStorage(36161, 34041, n.width, n.height);
            e.framebufferRenderbuffer(36160, 33306, 36161, t);
          } else {
            var u = a.convert(n.texture.format),
              l = a.convert(n.texture.type),
              h = w(n.texture.internalFormat, u, l);
            if (r) {
              var d = z(n);
              e.renderbufferStorageMultisample(36161, d, h, n.width, n.height);
            } else e.renderbufferStorage(36161, h, n.width, n.height);
          }
          e.bindRenderbuffer(36161, null);
        }
        function z(e) {
          return l && e.isWebGLMultisampleRenderTarget
            ? Math.min(f, e.samples)
            : 0;
        }
        var F = !1,
          U = !1;
        (this.allocateTextureUnit = function () {
          var e = E;
          return (
            e >= h &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  e +
                  " texture units while this GPU supports only " +
                  h
              ),
            (E += 1),
            e
          );
        }),
          (this.resetTextureUnits = function () {
            E = 0;
          }),
          (this.setTexture2D = A),
          (this.setTexture2DArray = function (e, t) {
            var i = r.get(e);
            e.version > 0 && i.__version !== e.version
              ? I(i, e, t)
              : (n.activeTexture(33984 + t),
                n.bindTexture(35866, i.__webglTexture));
          }),
          (this.setTexture3D = function (e, t) {
            var i = r.get(e);
            e.version > 0 && i.__version !== e.version
              ? I(i, e, t)
              : (n.activeTexture(33984 + t),
                n.bindTexture(32879, i.__webglTexture));
          }),
          (this.setTextureCube = L),
          (this.setTextureCubeDynamic = C),
          (this.setupRenderTarget = function (t) {
            var i = r.get(t),
              s = r.get(t.texture);
            t.addEventListener("dispose", T),
              (s.__webglTexture = e.createTexture()),
              o.memory.textures++;
            var c = !0 === t.isWebGLCubeRenderTarget,
              u = !0 === t.isWebGLMultisampleRenderTarget,
              h = x(t) || l;
            if (
              (!l ||
                t.texture.format !== Ge ||
                (t.texture.type !== De && t.texture.type !== Ie) ||
                ((t.texture.format = ke),
                console.warn(
                  "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
                )),
              c)
            ) {
              i.__webglFramebuffer = [];
              for (var d = 0; d < 6; d++)
                i.__webglFramebuffer[d] = e.createFramebuffer();
            } else if (((i.__webglFramebuffer = e.createFramebuffer()), u))
              if (l) {
                (i.__webglMultisampledFramebuffer = e.createFramebuffer()),
                  (i.__webglColorRenderbuffer = e.createRenderbuffer()),
                  e.bindRenderbuffer(36161, i.__webglColorRenderbuffer);
                var p = a.convert(t.texture.format),
                  f = a.convert(t.texture.type),
                  m = w(t.texture.internalFormat, p, f),
                  v = z(t);
                e.renderbufferStorageMultisample(
                  36161,
                  v,
                  m,
                  t.width,
                  t.height
                ),
                  e.bindFramebuffer(36160, i.__webglMultisampledFramebuffer),
                  e.framebufferRenderbuffer(
                    36160,
                    36064,
                    36161,
                    i.__webglColorRenderbuffer
                  ),
                  e.bindRenderbuffer(36161, null),
                  t.depthBuffer &&
                    ((i.__webglDepthRenderbuffer = e.createRenderbuffer()),
                    B(i.__webglDepthRenderbuffer, t, !0)),
                  e.bindFramebuffer(36160, null);
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
            if (c) {
              n.bindTexture(34067, s.__webglTexture), O(34067, t.texture, h);
              for (var g = 0; g < 6; g++)
                N(i.__webglFramebuffer[g], t, 36064, 34069 + g);
              b(t.texture, h) && _(34067, t.texture, t.width, t.height),
                n.bindTexture(34067, null);
            } else
              n.bindTexture(3553, s.__webglTexture),
                O(3553, t.texture, h),
                N(i.__webglFramebuffer, t, 36064, 3553),
                b(t.texture, h) && _(3553, t.texture, t.width, t.height),
                n.bindTexture(3553, null);
            t.depthBuffer &&
              (function (t) {
                var n = r.get(t),
                  i = !0 === t.isWebGLCubeRenderTarget;
                if (t.depthTexture) {
                  if (i)
                    throw new Error(
                      "target.depthTexture not supported in Cube render targets"
                    );
                  !(function (t, n) {
                    if (n && n.isWebGLCubeRenderTarget)
                      throw new Error(
                        "Depth Texture with cube render targets is not supported"
                      );
                    if (
                      (e.bindFramebuffer(36160, t),
                      !n.depthTexture || !n.depthTexture.isDepthTexture)
                    )
                      throw new Error(
                        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                      );
                    (r.get(n.depthTexture).__webglTexture &&
                      n.depthTexture.image.width === n.width &&
                      n.depthTexture.image.height === n.height) ||
                      ((n.depthTexture.image.width = n.width),
                      (n.depthTexture.image.height = n.height),
                      (n.depthTexture.needsUpdate = !0)),
                      A(n.depthTexture, 0);
                    var i = r.get(n.depthTexture).__webglTexture;
                    if (n.depthTexture.format === We)
                      e.framebufferTexture2D(36160, 36096, 3553, i, 0);
                    else {
                      if (n.depthTexture.format !== qe)
                        throw new Error("Unknown depthTexture format");
                      e.framebufferTexture2D(36160, 33306, 3553, i, 0);
                    }
                  })(n.__webglFramebuffer, t);
                } else if (i) {
                  n.__webglDepthbuffer = [];
                  for (var a = 0; a < 6; a++)
                    e.bindFramebuffer(36160, n.__webglFramebuffer[a]),
                      (n.__webglDepthbuffer[a] = e.createRenderbuffer()),
                      B(n.__webglDepthbuffer[a], t, !1);
                } else
                  e.bindFramebuffer(36160, n.__webglFramebuffer),
                    (n.__webglDepthbuffer = e.createRenderbuffer()),
                    B(n.__webglDepthbuffer, t, !1);
                e.bindFramebuffer(36160, null);
              })(t);
          }),
          (this.updateRenderTargetMipmap = function (e) {
            var t = e.texture;
            if (b(t, x(e) || l)) {
              var i = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                a = r.get(t).__webglTexture;
              n.bindTexture(i, a),
                _(i, t, e.width, e.height),
                n.bindTexture(i, null);
            }
          }),
          (this.updateMultisampleRenderTarget = function (t) {
            if (t.isWebGLMultisampleRenderTarget)
              if (l) {
                var n = r.get(t);
                e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
                  e.bindFramebuffer(36009, n.__webglFramebuffer);
                var i = t.width,
                  a = t.height,
                  o = 16384;
                t.depthBuffer && (o |= 256),
                  t.stencilBuffer && (o |= 1024),
                  e.blitFramebuffer(0, 0, i, a, 0, 0, i, a, o, 9728),
                  e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer);
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
          }),
          (this.safeSetTexture2D = function (e, t) {
            e &&
              e.isWebGLRenderTarget &&
              (!1 === F &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
                ),
                (F = !0)),
              (e = e.texture)),
              A(e, t);
          }),
          (this.safeSetTextureCube = function (e, t) {
            e &&
              e.isWebGLCubeRenderTarget &&
              (!1 === U &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                ),
                (U = !0)),
              (e = e.texture)),
              (e && e.isCubeTexture) ||
              (Array.isArray(e.image) && 6 === e.image.length)
                ? L(e, t)
                : C(e, t);
          });
      }
      function Os(e, t, n) {
        var r = n.isWebGL2;
        return {
          convert: function (e) {
            var n;
            if (e === Ae) return 5121;
            if (e === Ne) return 32819;
            if (e === Be) return 32820;
            if (e === ze) return 33635;
            if (e === Le) return 5120;
            if (e === Ce) return 5122;
            if (e === Re) return 5123;
            if (e === Pe) return 5124;
            if (e === Oe) return 5125;
            if (e === De) return 5126;
            if (e === Ie)
              return r
                ? 5131
                : null !== (n = t.get("OES_texture_half_float"))
                ? n.HALF_FLOAT_OES
                : null;
            if (e === Ue) return 6406;
            if (e === Ge) return 6407;
            if (e === ke) return 6408;
            if (e === He) return 6409;
            if (e === je) return 6410;
            if (e === We) return 6402;
            if (e === qe) return 34041;
            if (e === Xe) return 6403;
            if (e === Ye) return 36244;
            if (e === Ze) return 33319;
            if (e === Je) return 33320;
            if (e === Ke) return 36248;
            if (e === Qe) return 36249;
            if (e === $e || e === et || e === tt || e === nt) {
              if (null === (n = t.get("WEBGL_compressed_texture_s3tc")))
                return null;
              if (e === $e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (e === et) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (e === tt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (e === nt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
            if (e === rt || e === it || e === at || e === ot) {
              if (null === (n = t.get("WEBGL_compressed_texture_pvrtc")))
                return null;
              if (e === rt) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (e === it) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (e === at) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (e === ot) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (e === st)
              return null !== (n = t.get("WEBGL_compressed_texture_etc1"))
                ? n.COMPRESSED_RGB_ETC1_WEBGL
                : null;
            if (
              (e === ct || e === ut) &&
              null !== (n = t.get("WEBGL_compressed_texture_etc"))
            ) {
              if (e === ct) return n.COMPRESSED_RGB8_ETC2;
              if (e === ut) return n.COMPRESSED_RGBA8_ETC2_EAC;
            }
            return e === lt ||
              e === ht ||
              e === dt ||
              e === pt ||
              e === ft ||
              e === mt ||
              e === vt ||
              e === gt ||
              e === yt ||
              e === xt ||
              e === bt ||
              e === _t ||
              e === wt ||
              e === Mt ||
              e === Tt ||
              e === Et ||
              e === At ||
              e === Lt ||
              e === Ct ||
              e === Rt ||
              e === Pt ||
              e === Ot ||
              e === Dt ||
              e === It ||
              e === Nt ||
              e === Bt ||
              e === zt ||
              e === Ft
              ? null !== (n = t.get("WEBGL_compressed_texture_astc"))
                ? e
                : null
              : e === St
              ? null !== (n = t.get("EXT_texture_compression_bptc"))
                ? e
                : null
              : e === Fe
              ? r
                ? 34042
                : null !== (n = t.get("WEBGL_depth_texture"))
                ? n.UNSIGNED_INT_24_8_WEBGL
                : null
              : void 0;
          },
        };
      }
      function Ds(e) {
        Sa.call(this), (this.cameras = e || []);
      }
      function Is() {
        Tr.call(this), (this.type = "Group");
      }
      function Ns() {
        (this._targetRay = null), (this._grip = null);
      }
      function Bs(e, t) {
        var n = this,
          r = null,
          i = 1,
          a = null,
          o = "local-floor",
          s = null,
          c = [],
          u = new Map(),
          l = new Sa();
        l.layers.enable(1), (l.viewport = new Xn());
        var h = new Sa();
        h.layers.enable(2), (h.viewport = new Xn());
        var d = [l, h],
          p = new Ds();
        p.layers.enable(1), p.layers.enable(2);
        var f = null,
          m = null;
        function v(e) {
          var t = u.get(e.inputSource);
          t && t.dispatchEvent({ type: e.type });
        }
        function g() {
          u.forEach(function (e, t) {
            e.disconnect(t);
          }),
            u.clear(),
            e.setFramebuffer(null),
            e.setRenderTarget(e.getRenderTarget()),
            S.stop(),
            (n.isPresenting = !1),
            n.dispatchEvent({ type: "sessionend" });
        }
        function y(e) {
          (a = e),
            S.setContext(r),
            S.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
        function x(e) {
          for (var t = r.inputSources, n = 0; n < c.length; n++)
            u.set(t[n], c[n]);
          for (var i = 0; i < e.removed.length; i++) {
            var a = e.removed[i],
              o = u.get(a);
            o &&
              (o.dispatchEvent({ type: "disconnected", data: a }), u.delete(a));
          }
          for (var s = 0; s < e.added.length; s++) {
            var l = e.added[s],
              h = u.get(l);
            h && h.dispatchEvent({ type: "connected", data: l });
          }
        }
        (this.enabled = !1),
          (this.isPresenting = !1),
          (this.getController = function (e) {
            var t = c[e];
            return (
              void 0 === t && ((t = new Ns()), (c[e] = t)),
              t.getTargetRaySpace()
            );
          }),
          (this.getControllerGrip = function (e) {
            var t = c[e];
            return (
              void 0 === t && ((t = new Ns()), (c[e] = t)), t.getGripSpace()
            );
          }),
          (this.setFramebufferScaleFactor = function (e) {
            (i = e),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
          (this.setReferenceSpaceType = function (e) {
            (o = e),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change reference space type while presenting."
                );
          }),
          (this.getReferenceSpace = function () {
            return a;
          }),
          (this.getSession = function () {
            return r;
          }),
          (this.setSession = function (e) {
            if (null !== (r = e)) {
              r.addEventListener("select", v),
                r.addEventListener("selectstart", v),
                r.addEventListener("selectend", v),
                r.addEventListener("squeeze", v),
                r.addEventListener("squeezestart", v),
                r.addEventListener("squeezeend", v),
                r.addEventListener("end", g);
              var n = t.getContextAttributes();
              !0 !== n.xrCompatible && t.makeXRCompatible();
              var a = new XRWebGLLayer(r, t, {
                antialias: n.antialias,
                alpha: n.alpha,
                depth: n.depth,
                stencil: n.stencil,
                framebufferScaleFactor: i,
              });
              r.updateRenderState({ baseLayer: a }),
                r.requestReferenceSpace(o).then(y),
                r.addEventListener("inputsourceschange", x);
            }
          });
        var b = new $n(),
          _ = new $n();
        function w(e, t) {
          null === t
            ? e.matrixWorld.copy(e.matrix)
            : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.getInverse(e.matrixWorld);
        }
        this.getCamera = function (e) {
          (p.near = h.near = l.near = e.near),
            (p.far = h.far = l.far = e.far),
            (f === p.near && m === p.far) ||
              (r.updateRenderState({ depthNear: p.near, depthFar: p.far }),
              (f = p.near),
              (m = p.far));
          var t = e.parent,
            n = p.cameras;
          w(p, t);
          for (var i = 0; i < n.length; i++) w(n[i], t);
          e.matrixWorld.copy(p.matrixWorld);
          for (var a = e.children, o = 0, s = a.length; o < s; o++)
            a[o].updateMatrixWorld(!0);
          return (
            2 === n.length
              ? (function (e, t, n) {
                  b.setFromMatrixPosition(t.matrixWorld),
                    _.setFromMatrixPosition(n.matrixWorld);
                  var r = b.distanceTo(_),
                    i = t.projectionMatrix.elements,
                    a = n.projectionMatrix.elements,
                    o = i[14] / (i[10] - 1),
                    s = i[14] / (i[10] + 1),
                    c = (i[9] + 1) / i[5],
                    u = (i[9] - 1) / i[5],
                    l = (i[8] - 1) / i[0],
                    h = (a[8] + 1) / a[0],
                    d = o * l,
                    p = o * h,
                    f = r / (-l + h),
                    m = f * -l;
                  t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                    e.translateX(m),
                    e.translateZ(f),
                    e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                    e.matrixWorldInverse.getInverse(e.matrixWorld);
                  var v = o + f,
                    g = s + f;
                  e.projectionMatrix.makePerspective(
                    d - m,
                    p + (r - m),
                    ((c * s) / g) * v,
                    ((u * s) / g) * v,
                    v,
                    g
                  );
                })(p, l, h)
              : p.projectionMatrix.copy(l.projectionMatrix),
            p
          );
        };
        var M = null,
          S = new Oa();
        S.setAnimationLoop(function (t, n) {
          if (null !== (s = n.getViewerPose(a))) {
            var i = s.views,
              o = r.renderState.baseLayer;
            e.setFramebuffer(o.framebuffer);
            var u = !1;
            i.length !== p.cameras.length && ((p.cameras.length = 0), (u = !0));
            for (var l = 0; l < i.length; l++) {
              var h = i[l],
                f = o.getViewport(h),
                m = d[l];
              m.matrix.fromArray(h.transform.matrix),
                m.projectionMatrix.fromArray(h.projectionMatrix),
                m.viewport.set(f.x, f.y, f.width, f.height),
                0 === l && p.matrix.copy(m.matrix),
                !0 === u && p.cameras.push(m);
            }
          }
          for (var v = r.inputSources, g = 0; g < c.length; g++)
            c[g].update(v[g], n, a);
          M && M(t, n);
        }),
          (this.setAnimationLoop = function (e) {
            M = e;
          }),
          (this.dispose = function () {});
      }
      function zs(e) {
        function t(t, n, r) {
          (t.opacity.value = n.opacity),
            n.color && t.diffuse.value.copy(n.color),
            n.emissive &&
              t.emissive.value
                .copy(n.emissive)
                .multiplyScalar(n.emissiveIntensity),
            n.map && (t.map.value = n.map),
            n.alphaMap && (t.alphaMap.value = n.alphaMap),
            n.specularMap && (t.specularMap.value = n.specularMap);
          var i,
            a,
            o = n.envMap || r;
          o &&
            ((t.envMap.value = o),
            (t.flipEnvMap.value = o.isCubeTexture ? -1 : 1),
            (t.reflectivity.value = n.reflectivity),
            (t.refractionRatio.value = n.refractionRatio),
            (t.maxMipLevel.value = e.get(o).__maxMipLevel)),
            n.lightMap &&
              ((t.lightMap.value = n.lightMap),
              (t.lightMapIntensity.value = n.lightMapIntensity)),
            n.aoMap &&
              ((t.aoMap.value = n.aoMap),
              (t.aoMapIntensity.value = n.aoMapIntensity)),
            n.map
              ? (i = n.map)
              : n.specularMap
              ? (i = n.specularMap)
              : n.displacementMap
              ? (i = n.displacementMap)
              : n.normalMap
              ? (i = n.normalMap)
              : n.bumpMap
              ? (i = n.bumpMap)
              : n.roughnessMap
              ? (i = n.roughnessMap)
              : n.metalnessMap
              ? (i = n.metalnessMap)
              : n.alphaMap
              ? (i = n.alphaMap)
              : n.emissiveMap && (i = n.emissiveMap),
            void 0 !== i &&
              (i.isWebGLRenderTarget && (i = i.texture),
              !0 === i.matrixAutoUpdate && i.updateMatrix(),
              t.uvTransform.value.copy(i.matrix)),
            n.aoMap ? (a = n.aoMap) : n.lightMap && (a = n.lightMap),
            void 0 !== a &&
              (a.isWebGLRenderTarget && (a = a.texture),
              !0 === a.matrixAutoUpdate && a.updateMatrix(),
              t.uv2Transform.value.copy(a.matrix));
        }
        function n(e, t, n) {
          (e.roughness.value = t.roughness),
            (e.metalness.value = t.metalness),
            t.roughnessMap && (e.roughnessMap.value = t.roughnessMap),
            t.metalnessMap && (e.metalnessMap.value = t.metalnessMap),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap &&
              ((e.bumpMap.value = t.bumpMap),
              (e.bumpScale.value = t.bumpScale),
              t.side === y && (e.bumpScale.value *= -1)),
            t.normalMap &&
              ((e.normalMap.value = t.normalMap),
              e.normalScale.value.copy(t.normalScale),
              t.side === y && e.normalScale.value.negate()),
            t.displacementMap &&
              ((e.displacementMap.value = t.displacementMap),
              (e.displacementScale.value = t.displacementScale),
              (e.displacementBias.value = t.displacementBias)),
            (t.envMap || n) && (e.envMapIntensity.value = t.envMapIntensity);
        }
        return {
          refreshFogUniforms: function (e, t) {
            e.fogColor.value.copy(t.color),
              t.isFog
                ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
                : t.isFogExp2 && (e.fogDensity.value = t.density);
          },
          refreshMaterialUniforms: function (e, r, i, a, o) {
            r.isMeshBasicMaterial
              ? t(e, r)
              : r.isMeshLambertMaterial
              ? (t(e, r),
                (function (e, t) {
                  t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                })(e, r))
              : r.isMeshToonMaterial
              ? (t(e, r),
                (function (e, t) {
                  t.gradientMap && (e.gradientMap.value = t.gradientMap),
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                    t.bumpMap &&
                      ((e.bumpMap.value = t.bumpMap),
                      (e.bumpScale.value = t.bumpScale),
                      t.side === y && (e.bumpScale.value *= -1)),
                    t.normalMap &&
                      ((e.normalMap.value = t.normalMap),
                      e.normalScale.value.copy(t.normalScale),
                      t.side === y && e.normalScale.value.negate()),
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                })(e, r))
              : r.isMeshPhongMaterial
              ? (t(e, r),
                (function (e, t) {
                  e.specular.value.copy(t.specular),
                    (e.shininess.value = Math.max(t.shininess, 1e-4)),
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                    t.bumpMap &&
                      ((e.bumpMap.value = t.bumpMap),
                      (e.bumpScale.value = t.bumpScale),
                      t.side === y && (e.bumpScale.value *= -1)),
                    t.normalMap &&
                      ((e.normalMap.value = t.normalMap),
                      e.normalScale.value.copy(t.normalScale),
                      t.side === y && e.normalScale.value.negate()),
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                })(e, r))
              : r.isMeshStandardMaterial
              ? (t(e, r, i),
                r.isMeshPhysicalMaterial
                  ? (function (e, t, r) {
                      n(e, t, r),
                        (e.reflectivity.value = t.reflectivity),
                        (e.clearcoat.value = t.clearcoat),
                        (e.clearcoatRoughness.value = t.clearcoatRoughness),
                        t.sheen && e.sheen.value.copy(t.sheen),
                        t.clearcoatMap &&
                          (e.clearcoatMap.value = t.clearcoatMap),
                        t.clearcoatRoughnessMap &&
                          (e.clearcoatRoughnessMap.value =
                            t.clearcoatRoughnessMap),
                        t.clearcoatNormalMap &&
                          (e.clearcoatNormalScale.value.copy(
                            t.clearcoatNormalScale
                          ),
                          (e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                          t.side === y &&
                            e.clearcoatNormalScale.value.negate()),
                        (e.transparency.value = t.transparency);
                    })(e, r, i)
                  : n(e, r, i))
              : r.isMeshMatcapMaterial
              ? (t(e, r),
                (function (e, t) {
                  t.matcap && (e.matcap.value = t.matcap),
                    t.bumpMap &&
                      ((e.bumpMap.value = t.bumpMap),
                      (e.bumpScale.value = t.bumpScale),
                      t.side === y && (e.bumpScale.value *= -1)),
                    t.normalMap &&
                      ((e.normalMap.value = t.normalMap),
                      e.normalScale.value.copy(t.normalScale),
                      t.side === y && e.normalScale.value.negate()),
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                })(e, r))
              : r.isMeshDepthMaterial
              ? (t(e, r),
                (function (e, t) {
                  t.displacementMap &&
                    ((e.displacementMap.value = t.displacementMap),
                    (e.displacementScale.value = t.displacementScale),
                    (e.displacementBias.value = t.displacementBias));
                })(e, r))
              : r.isMeshDistanceMaterial
              ? (t(e, r),
                (function (e, t) {
                  t.displacementMap &&
                    ((e.displacementMap.value = t.displacementMap),
                    (e.displacementScale.value = t.displacementScale),
                    (e.displacementBias.value = t.displacementBias)),
                    e.referencePosition.value.copy(t.referencePosition),
                    (e.nearDistance.value = t.nearDistance),
                    (e.farDistance.value = t.farDistance);
                })(e, r))
              : r.isMeshNormalMaterial
              ? (t(e, r),
                (function (e, t) {
                  t.bumpMap &&
                    ((e.bumpMap.value = t.bumpMap),
                    (e.bumpScale.value = t.bumpScale),
                    t.side === y && (e.bumpScale.value *= -1)),
                    t.normalMap &&
                      ((e.normalMap.value = t.normalMap),
                      e.normalScale.value.copy(t.normalScale),
                      t.side === y && e.normalScale.value.negate()),
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                })(e, r))
              : r.isLineBasicMaterial
              ? ((function (e, t) {
                  e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity);
                })(e, r),
                r.isLineDashedMaterial &&
                  (function (e, t) {
                    (e.dashSize.value = t.dashSize),
                      (e.totalSize.value = t.dashSize + t.gapSize),
                      (e.scale.value = t.scale);
                  })(e, r))
              : r.isPointsMaterial
              ? (function (e, t, n, r) {
                  var i;
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.size.value = t.size * n),
                    (e.scale.value = 0.5 * r),
                    t.map && (e.map.value = t.map),
                    t.alphaMap && (e.alphaMap.value = t.alphaMap),
                    t.map ? (i = t.map) : t.alphaMap && (i = t.alphaMap),
                    void 0 !== i &&
                      (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                      e.uvTransform.value.copy(i.matrix));
                })(e, r, a, o)
              : r.isSpriteMaterial
              ? (function (e, t) {
                  var n;
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.rotation.value = t.rotation),
                    t.map && (e.map.value = t.map),
                    t.alphaMap && (e.alphaMap.value = t.alphaMap),
                    t.map ? (n = t.map) : t.alphaMap && (n = t.alphaMap),
                    void 0 !== n &&
                      (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                      e.uvTransform.value.copy(n.matrix));
                })(e, r)
              : r.isShadowMaterial
              ? (e.color.value.copy(r.color), (e.opacity.value = r.opacity))
              : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
          },
        };
      }
      function Fs(e) {
        var t =
            void 0 !== (e = e || {}).canvas
              ? e.canvas
              : document.createElementNS(
                  "http://www.w3.org/1999/xhtml",
                  "canvas"
                ),
          n = void 0 !== e.context ? e.context : null,
          r = void 0 !== e.alpha && e.alpha,
          i = void 0 === e.depth || e.depth,
          a = void 0 === e.stencil || e.stencil,
          o = void 0 !== e.antialias && e.antialias,
          s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
          c = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
          u = void 0 !== e.powerPreference ? e.powerPreference : "default",
          l =
            void 0 !== e.failIfMajorPerformanceCaveat &&
            e.failIfMajorPerformanceCaveat,
          h = null,
          d = null;
        (this.domElement = t),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.gammaFactor = 2),
          (this.outputEncoding = $t),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = te),
          (this.toneMappingExposure = 1),
          (this.maxMorphTargets = 8),
          (this.maxMorphNormals = 4);
        var p = this,
          f = !1,
          m = null,
          v = 0,
          g = 0,
          y = null,
          x = null,
          b = -1,
          _ = null,
          w = null,
          M = new Xn(),
          S = new Xn(),
          T = null,
          E = t.width,
          A = t.height,
          L = 1,
          C = null,
          R = null,
          P = new Xn(0, 0, E, A),
          O = new Xn(0, 0, E, A),
          D = !1,
          I = new Ra(),
          N = new Ha(),
          B = !1,
          z = !1,
          F = new sr(),
          U = new $n(),
          G = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function k() {
          return null === y ? L : 1;
        }
        var H,
          j,
          V,
          W,
          q,
          X,
          Y,
          Z,
          J,
          K,
          Q,
          $,
          ee,
          ne,
          re,
          ie,
          ae,
          oe,
          se,
          ce = n;
        function ue(e, n) {
          for (var r = 0; r < e.length; r++) {
            var i = t.getContext(e[r], n);
            if (null !== i) return i;
          }
          return null;
        }
        try {
          var le = {
            alpha: r,
            depth: i,
            stencil: a,
            antialias: o,
            premultipliedAlpha: s,
            preserveDrawingBuffer: c,
            powerPreference: u,
            failIfMajorPerformanceCaveat: l,
          };
          if (
            (t.addEventListener("webglcontextlost", me, !1),
            t.addEventListener("webglcontextrestored", ve, !1),
            null === ce)
          ) {
            var he = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (!0 === p.isWebGL1Renderer && he.shift(),
              null === (ce = ue(he, le)))
            )
              throw ue(he)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          void 0 === ce.getShaderPrecisionFormat &&
            (ce.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (Ee) {
          throw (console.error("THREE.WebGLRenderer: " + Ee.message), Ee);
        }
        function de() {
          (H = new ja(ce)),
            !1 === (j = new ka(ce, H, e)).isWebGL2 &&
              (H.get("WEBGL_depth_texture"),
              H.get("OES_texture_float"),
              H.get("OES_texture_half_float"),
              H.get("OES_texture_half_float_linear"),
              H.get("OES_standard_derivatives"),
              H.get("OES_element_index_uint"),
              H.get("OES_vertex_array_object"),
              H.get("ANGLE_instanced_arrays")),
            H.get("OES_texture_float_linear"),
            (oe = new Os(ce, H, j)),
            (V = new Rs(ce, H, j)).scissor(S.copy(O).multiplyScalar(L).floor()),
            V.viewport(M.copy(P).multiplyScalar(L).floor()),
            (W = new qa(ce)),
            (q = new vs()),
            (X = new Ps(ce, H, V, q, j, oe, W)),
            (Y = new Da(ce, j)),
            (se = new Ua(ce, H, Y, j)),
            (Z = new Va(ce, Y, W, se)),
            (J = new Ja(ce, Z, Y, W)),
            (re = new Za(ce)),
            (K = new ms(p, H, j, se)),
            (Q = new zs(q)),
            ($ = new bs()),
            (ee = new Es()),
            (ne = new Fa(p, V, J, s)),
            (ie = new Ga(ce, H, W, j)),
            (ae = new Wa(ce, H, W, j)),
            (W.programs = K.programs),
            (p.capabilities = j),
            (p.extensions = H),
            (p.properties = q),
            (p.renderLists = $),
            (p.state = V),
            (p.info = W);
        }
        de();
        var pe = new Bs(p, ce);
        this.xr = pe;
        var fe = new Cs(p, J, j.maxTextureSize);
        function me(e) {
          e.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (f = !0);
        }
        function ve() {
          console.log("THREE.WebGLRenderer: Context Restored."), (f = !1), de();
        }
        function ge(e) {
          var t = e.target;
          t.removeEventListener("dispose", ge),
            (function (e) {
              ye(e), q.remove(e);
            })(t);
        }
        function ye(e) {
          var t = q.get(e).program;
          (e.program = void 0), void 0 !== t && K.releaseProgram(t);
        }
        (this.shadowMap = fe),
          (this.getContext = function () {
            return ce;
          }),
          (this.getContextAttributes = function () {
            return ce.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            var e = H.get("WEBGL_lose_context");
            e && e.loseContext();
          }),
          (this.forceContextRestore = function () {
            var e = H.get("WEBGL_lose_context");
            e && e.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return L;
          }),
          (this.setPixelRatio = function (e) {
            void 0 !== e && ((L = e), this.setSize(E, A, !1));
          }),
          (this.getSize = function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
                ),
                (e = new Hn())),
              e.set(E, A)
            );
          }),
          (this.setSize = function (e, n, r) {
            pe.isPresenting
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                )
              : ((E = e),
                (A = n),
                (t.width = Math.floor(e * L)),
                (t.height = Math.floor(n * L)),
                !1 !== r &&
                  ((t.style.width = e + "px"), (t.style.height = n + "px")),
                this.setViewport(0, 0, e, n));
          }),
          (this.getDrawingBufferSize = function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
                ),
                (e = new Hn())),
              e.set(E * L, A * L).floor()
            );
          }),
          (this.setDrawingBufferSize = function (e, n, r) {
            (E = e),
              (A = n),
              (L = r),
              (t.width = Math.floor(e * r)),
              (t.height = Math.floor(n * r)),
              this.setViewport(0, 0, e, n);
          }),
          (this.getCurrentViewport = function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
                ),
                (e = new Xn())),
              e.copy(M)
            );
          }),
          (this.getViewport = function (e) {
            return e.copy(P);
          }),
          (this.setViewport = function (e, t, n, r) {
            e.isVector4 ? P.set(e.x, e.y, e.z, e.w) : P.set(e, t, n, r),
              V.viewport(M.copy(P).multiplyScalar(L).floor());
          }),
          (this.getScissor = function (e) {
            return e.copy(O);
          }),
          (this.setScissor = function (e, t, n, r) {
            e.isVector4 ? O.set(e.x, e.y, e.z, e.w) : O.set(e, t, n, r),
              V.scissor(S.copy(O).multiplyScalar(L).floor());
          }),
          (this.getScissorTest = function () {
            return D;
          }),
          (this.setScissorTest = function (e) {
            V.setScissorTest((D = e));
          }),
          (this.setOpaqueSort = function (e) {
            C = e;
          }),
          (this.setTransparentSort = function (e) {
            R = e;
          }),
          (this.getClearColor = function () {
            return ne.getClearColor();
          }),
          (this.setClearColor = function () {
            ne.setClearColor.apply(ne, arguments);
          }),
          (this.getClearAlpha = function () {
            return ne.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            ne.setClearAlpha.apply(ne, arguments);
          }),
          (this.clear = function (e, t, n) {
            var r = 0;
            (void 0 === e || e) && (r |= 16384),
              (void 0 === t || t) && (r |= 256),
              (void 0 === n || n) && (r |= 1024),
              ce.clear(r);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            t.removeEventListener("webglcontextlost", me, !1),
              t.removeEventListener("webglcontextrestored", ve, !1),
              $.dispose(),
              ee.dispose(),
              q.dispose(),
              J.dispose(),
              se.dispose(),
              pe.dispose(),
              be.stop();
          }),
          (this.renderBufferImmediate = function (e, t) {
            se.initAttributes();
            var n = q.get(e);
            e.hasPositions && !n.position && (n.position = ce.createBuffer()),
              e.hasNormals && !n.normal && (n.normal = ce.createBuffer()),
              e.hasUvs && !n.uv && (n.uv = ce.createBuffer()),
              e.hasColors && !n.color && (n.color = ce.createBuffer());
            var r = t.getAttributes();
            e.hasPositions &&
              (ce.bindBuffer(34962, n.position),
              ce.bufferData(34962, e.positionArray, 35048),
              se.enableAttribute(r.position),
              ce.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)),
              e.hasNormals &&
                (ce.bindBuffer(34962, n.normal),
                ce.bufferData(34962, e.normalArray, 35048),
                se.enableAttribute(r.normal),
                ce.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)),
              e.hasUvs &&
                (ce.bindBuffer(34962, n.uv),
                ce.bufferData(34962, e.uvArray, 35048),
                se.enableAttribute(r.uv),
                ce.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)),
              e.hasColors &&
                (ce.bindBuffer(34962, n.color),
                ce.bufferData(34962, e.colorArray, 35048),
                se.enableAttribute(r.color),
                ce.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)),
              se.disableUnusedAttributes(),
              ce.drawArrays(4, 0, e.count),
              (e.count = 0);
          }),
          (this.renderBufferDirect = function (e, t, n, r, i, a) {
            null === t && (t = G);
            var o = i.isMesh && i.matrixWorld.determinant() < 0,
              s = Te(e, t, r, i);
            V.setMaterial(r, o);
            var c = n.index,
              u = n.attributes.position;
            if (null === c) {
              if (void 0 === u || 0 === u.count) return;
            } else if (0 === c.count) return;
            var l,
              h = 1;
            !0 === r.wireframe && ((c = Z.getWireframeAttribute(n)), (h = 2)),
              (r.morphTargets || r.morphNormals) && re.update(i, n, r, s),
              se.setup(i, r, s, n, c);
            var d = ie;
            null !== c && ((l = Y.get(c)), (d = ae).setIndex(l));
            var p = null !== c ? c.count : u.count,
              f = n.drawRange.start * h,
              m = n.drawRange.count * h,
              v = null !== a ? a.start * h : 0,
              g = null !== a ? a.count * h : 1 / 0,
              y = Math.max(f, v),
              x = Math.min(p, f + m, v + g) - 1,
              b = Math.max(0, x - y + 1);
            if (0 !== b) {
              if (i.isMesh)
                !0 === r.wireframe
                  ? (V.setLineWidth(r.wireframeLinewidth * k()), d.setMode(1))
                  : d.setMode(4);
              else if (i.isLine) {
                var _ = r.linewidth;
                void 0 === _ && (_ = 1),
                  V.setLineWidth(_ * k()),
                  d.setMode(i.isLineSegments ? 1 : i.isLineLoop ? 2 : 3);
              } else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4);
              if (i.isInstancedMesh) d.renderInstances(n, y, b, i.count);
              else if (n.isInstancedBufferGeometry) {
                var w = Math.min(n.instanceCount, n._maxInstanceCount);
                d.renderInstances(n, y, b, w);
              } else d.render(y, b);
            }
          }),
          (this.compile = function (e, t) {
            (d = ee.get(e, t)).init(),
              e.traverse(function (e) {
                e.isLight && (d.pushLight(e), e.castShadow && d.pushShadow(e));
              }),
              d.setupLights(t);
            var n = new WeakMap();
            e.traverse(function (t) {
              var r = t.material;
              if (r)
                if (Array.isArray(r))
                  for (var i = 0; i < r.length; i++) {
                    var a = r[i];
                    !1 === n.has(a) && (Se(a, e, t), n.set(a));
                  }
                else !1 === n.has(r) && (Se(r, e, t), n.set(r));
            });
          });
        var xe = null,
          be = new Oa();
        function _e(e, t, n, r) {
          if (!1 !== e.visible) {
            if (e.layers.test(t.layers))
              if (e.isGroup) n = e.renderOrder;
              else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
              else if (e.isLight)
                d.pushLight(e), e.castShadow && d.pushShadow(e);
              else if (e.isSprite) {
                if (!e.frustumCulled || I.intersectsSprite(e)) {
                  r && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F);
                  var i = J.update(e),
                    a = e.material;
                  a.visible && h.push(e, i, a, n, U.z, null);
                }
              } else if (e.isImmediateRenderObject)
                r && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F),
                  h.push(e, null, e.material, n, U.z, null);
              else if (
                (e.isMesh || e.isLine || e.isPoints) &&
                (e.isSkinnedMesh &&
                  e.skeleton.frame !== W.render.frame &&
                  (e.skeleton.update(), (e.skeleton.frame = W.render.frame)),
                !e.frustumCulled || I.intersectsObject(e))
              ) {
                r && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F);
                var o = J.update(e),
                  s = e.material;
                if (Array.isArray(s))
                  for (var c = o.groups, u = 0, l = c.length; u < l; u++) {
                    var p = c[u],
                      f = s[p.materialIndex];
                    f && f.visible && h.push(e, o, f, n, U.z, p);
                  }
                else s.visible && h.push(e, o, s, n, U.z, null);
              }
            for (var m = e.children, v = 0, g = m.length; v < g; v++)
              _e(m[v], t, n, r);
          }
        }
        function we(e, t, n) {
          for (
            var r = !0 === t.isScene ? t.overrideMaterial : null,
              i = 0,
              a = e.length;
            i < a;
            i++
          ) {
            var o = e[i],
              s = o.object,
              c = o.geometry,
              u = null === r ? o.material : r,
              l = o.group;
            if (n.isArrayCamera) {
              w = n;
              for (var h = n.cameras, p = 0, f = h.length; p < f; p++) {
                var m = h[p];
                s.layers.test(m.layers) &&
                  (V.viewport(M.copy(m.viewport)),
                  d.setupLights(m),
                  Me(s, t, m, c, u, l));
              }
            } else (w = null), Me(s, t, n, c, u, l);
          }
        }
        function Me(e, t, n, r, i, a) {
          if (
            (e.onBeforeRender(p, t, n, r, i, a),
            (d = ee.get(t, w || n)),
            e.modelViewMatrix.multiplyMatrices(
              n.matrixWorldInverse,
              e.matrixWorld
            ),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            e.isImmediateRenderObject)
          ) {
            var o = Te(n, t, i, e);
            V.setMaterial(i),
              se.reset(),
              (function (e, t) {
                e.render(function (e) {
                  p.renderBufferImmediate(e, t);
                });
              })(e, o);
          } else p.renderBufferDirect(n, t, r, i, e, a);
          e.onAfterRender(p, t, n, r, i, a), (d = ee.get(t, w || n));
        }
        function Se(e, t, n) {
          !0 !== t.isScene && (t = G);
          var r = q.get(e),
            i = d.state.lights,
            a = i.state.version,
            o = K.getParameters(
              e,
              i.state,
              d.state.shadowsArray,
              t,
              N.numPlanes,
              N.numIntersection,
              n
            ),
            s = K.getProgramCacheKey(o),
            c = r.program,
            u = !0;
          if (void 0 === c) e.addEventListener("dispose", ge);
          else if (c.cacheKey !== s) ye(e);
          else if (r.lightsStateVersion !== a)
            (r.lightsStateVersion = a), (u = !1);
          else {
            if (void 0 !== o.shaderID) return;
            u = !1;
          }
          u &&
            ((c = K.acquireProgram(o, s)),
            (r.program = c),
            (r.uniforms = o.uniforms),
            (r.outputEncoding = o.outputEncoding),
            (e.program = c));
          var l = c.getAttributes();
          if (e.morphTargets) {
            e.numSupportedMorphTargets = 0;
            for (var h = 0; h < p.maxMorphTargets; h++)
              l["morphTarget" + h] >= 0 && e.numSupportedMorphTargets++;
          }
          if (e.morphNormals) {
            e.numSupportedMorphNormals = 0;
            for (var f = 0; f < p.maxMorphNormals; f++)
              l["morphNormal" + f] >= 0 && e.numSupportedMorphNormals++;
          }
          var m = r.uniforms;
          ((e.isShaderMaterial || e.isRawShaderMaterial) &&
            !0 !== e.clipping) ||
            ((r.numClippingPlanes = N.numPlanes),
            (r.numIntersection = N.numIntersection),
            (m.clippingPlanes = N.uniform)),
            (r.environment = e.isMeshStandardMaterial ? t.environment : null),
            (r.fog = t.fog),
            (r.needsLights = (function (e) {
              return (
                e.isMeshLambertMaterial ||
                e.isMeshToonMaterial ||
                e.isMeshPhongMaterial ||
                e.isMeshStandardMaterial ||
                e.isShadowMaterial ||
                (e.isShaderMaterial && !0 === e.lights)
              );
            })(e)),
            (r.lightsStateVersion = a),
            r.needsLights &&
              ((m.ambientLightColor.value = i.state.ambient),
              (m.lightProbe.value = i.state.probe),
              (m.directionalLights.value = i.state.directional),
              (m.directionalLightShadows.value = i.state.directionalShadow),
              (m.spotLights.value = i.state.spot),
              (m.spotLightShadows.value = i.state.spotShadow),
              (m.rectAreaLights.value = i.state.rectArea),
              (m.pointLights.value = i.state.point),
              (m.pointLightShadows.value = i.state.pointShadow),
              (m.hemisphereLights.value = i.state.hemi),
              (m.directionalShadowMap.value = i.state.directionalShadowMap),
              (m.directionalShadowMatrix.value =
                i.state.directionalShadowMatrix),
              (m.spotShadowMap.value = i.state.spotShadowMap),
              (m.spotShadowMatrix.value = i.state.spotShadowMatrix),
              (m.pointShadowMap.value = i.state.pointShadowMap),
              (m.pointShadowMatrix.value = i.state.pointShadowMatrix));
          var v = r.program.getUniforms(),
            g = Zo.seqWithValue(v.seq, m);
          r.uniformsList = g;
        }
        function Te(e, t, n, r) {
          !0 !== t.isScene && (t = G), X.resetTextureUnits();
          var i = t.fog,
            a = n.isMeshStandardMaterial ? t.environment : null,
            o = null === y ? p.outputEncoding : y.texture.encoding,
            s = q.get(n),
            c = d.state.lights;
          !0 !== B ||
            (!0 !== z && e === _) ||
            N.setState(
              n.clippingPlanes,
              n.clipIntersection,
              n.clipShadows,
              e,
              s,
              e === _ && n.id === b
            ),
            n.version === s.__version
              ? void 0 === s.program ||
                (n.fog && s.fog !== i) ||
                s.environment !== a ||
                (s.needsLights && s.lightsStateVersion !== c.state.version)
                ? Se(n, t, r)
                : void 0 === s.numClippingPlanes ||
                  (s.numClippingPlanes === N.numPlanes &&
                    s.numIntersection === N.numIntersection)
                ? s.outputEncoding !== o && Se(n, t, r)
                : Se(n, t, r)
              : (Se(n, t, r), (s.__version = n.version));
          var u,
            l,
            h = !1,
            f = !1,
            m = !1,
            v = s.program,
            g = v.getUniforms(),
            x = s.uniforms;
          if (
            (V.useProgram(v.program) && ((h = !0), (f = !0), (m = !0)),
            n.id !== b && ((b = n.id), (f = !0)),
            h || _ !== e)
          ) {
            if (
              (g.setValue(ce, "projectionMatrix", e.projectionMatrix),
              j.logarithmicDepthBuffer &&
                g.setValue(
                  ce,
                  "logDepthBufFC",
                  2 / (Math.log(e.far + 1) / Math.LN2)
                ),
              _ !== e && ((_ = e), (f = !0), (m = !0)),
              n.isShaderMaterial ||
                n.isMeshPhongMaterial ||
                n.isMeshToonMaterial ||
                n.isMeshStandardMaterial ||
                n.envMap)
            ) {
              var w = g.map.cameraPosition;
              void 0 !== w &&
                w.setValue(ce, U.setFromMatrixPosition(e.matrixWorld));
            }
            (n.isMeshPhongMaterial ||
              n.isMeshToonMaterial ||
              n.isMeshLambertMaterial ||
              n.isMeshBasicMaterial ||
              n.isMeshStandardMaterial ||
              n.isShaderMaterial) &&
              g.setValue(ce, "isOrthographic", !0 === e.isOrthographicCamera),
              (n.isMeshPhongMaterial ||
                n.isMeshToonMaterial ||
                n.isMeshLambertMaterial ||
                n.isMeshBasicMaterial ||
                n.isMeshStandardMaterial ||
                n.isShaderMaterial ||
                n.isShadowMaterial ||
                n.skinning) &&
                g.setValue(ce, "viewMatrix", e.matrixWorldInverse);
          }
          if (n.skinning) {
            g.setOptional(ce, r, "bindMatrix"),
              g.setOptional(ce, r, "bindMatrixInverse");
            var M = r.skeleton;
            if (M) {
              var S = M.bones;
              if (j.floatVertexTextures) {
                if (void 0 === M.boneTexture) {
                  var T = Math.sqrt(4 * S.length);
                  (T = kn.ceilPowerOfTwo(T)), (T = Math.max(T, 4));
                  var E = new Float32Array(T * T * 4);
                  E.set(M.boneMatrices);
                  var C = new Aa(E, T, T, ke, De);
                  (M.boneMatrices = E),
                    (M.boneTexture = C),
                    (M.boneTextureSize = T);
                }
                g.setValue(ce, "boneTexture", M.boneTexture, X),
                  g.setValue(ce, "boneTextureSize", M.boneTextureSize);
              } else g.setOptional(ce, M, "boneMatrices");
            }
          }
          return (
            (f || s.receiveShadow !== r.receiveShadow) &&
              ((s.receiveShadow = r.receiveShadow),
              g.setValue(ce, "receiveShadow", r.receiveShadow)),
            f &&
              (g.setValue(ce, "toneMappingExposure", p.toneMappingExposure),
              s.needsLights &&
                (((u = x).ambientLightColor.needsUpdate = l = m),
                (u.lightProbe.needsUpdate = l),
                (u.directionalLights.needsUpdate = l),
                (u.directionalLightShadows.needsUpdate = l),
                (u.pointLights.needsUpdate = l),
                (u.pointLightShadows.needsUpdate = l),
                (u.spotLights.needsUpdate = l),
                (u.spotLightShadows.needsUpdate = l),
                (u.rectAreaLights.needsUpdate = l),
                (u.hemisphereLights.needsUpdate = l)),
              i && n.fog && Q.refreshFogUniforms(x, i),
              Q.refreshMaterialUniforms(x, n, a, L, A),
              void 0 !== x.ltc_1 && (x.ltc_1.value = Pa.LTC_1),
              void 0 !== x.ltc_2 && (x.ltc_2.value = Pa.LTC_2),
              Zo.upload(ce, s.uniformsList, x, X)),
            n.isShaderMaterial &&
              !0 === n.uniformsNeedUpdate &&
              (Zo.upload(ce, s.uniformsList, x, X),
              (n.uniformsNeedUpdate = !1)),
            n.isSpriteMaterial && g.setValue(ce, "center", r.center),
            g.setValue(ce, "modelViewMatrix", r.modelViewMatrix),
            g.setValue(ce, "normalMatrix", r.normalMatrix),
            g.setValue(ce, "modelMatrix", r.matrixWorld),
            v
          );
        }
        be.setAnimationLoop(function (e) {
          pe.isPresenting || (xe && xe(e));
        }),
          "undefined" != typeof window && be.setContext(window),
          (this.setAnimationLoop = function (e) {
            (xe = e),
              pe.setAnimationLoop(e),
              null === e ? be.stop() : be.start();
          }),
          (this.render = function (e, t) {
            var n, r;
            if (
              (void 0 !== arguments[2] &&
                (console.warn(
                  "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
                ),
                (n = arguments[2])),
              void 0 !== arguments[3] &&
                (console.warn(
                  "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
                ),
                (r = arguments[3])),
              void 0 === t || !0 === t.isCamera)
            ) {
              if (!0 !== f) {
                se.resetDefaultState(),
                  (b = -1),
                  (_ = null),
                  !0 === e.autoUpdate && e.updateMatrixWorld(),
                  null === t.parent && t.updateMatrixWorld(),
                  !0 === pe.enabled &&
                    !0 === pe.isPresenting &&
                    (t = pe.getCamera(t)),
                  !0 === e.isScene && e.onBeforeRender(p, e, t, n || y),
                  (d = ee.get(e, t)).init(),
                  F.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                  I.setFromProjectionMatrix(F),
                  (z = this.localClippingEnabled),
                  (B = N.init(this.clippingPlanes, z, t)),
                  (h = $.get(e, t)).init(),
                  _e(e, t, 0, p.sortObjects),
                  h.finish(),
                  !0 === p.sortObjects && h.sort(C, R),
                  !0 === B && N.beginShadows();
                var i = d.state.shadowsArray;
                fe.render(i, e, t),
                  d.setupLights(t),
                  !0 === B && N.endShadows(),
                  !0 === this.info.autoReset && this.info.reset(),
                  void 0 !== n && this.setRenderTarget(n),
                  ne.render(h, e, t, r);
                var a = h.opaque,
                  o = h.transparent;
                a.length > 0 && we(a, e, t),
                  o.length > 0 && we(o, e, t),
                  !0 === e.isScene && e.onAfterRender(p, e, t),
                  null !== y &&
                    (X.updateRenderTargetMipmap(y),
                    X.updateMultisampleRenderTarget(y)),
                  V.buffers.depth.setTest(!0),
                  V.buffers.depth.setMask(!0),
                  V.buffers.color.setMask(!0),
                  V.setPolygonOffset(!1),
                  (h = null),
                  (d = null);
              }
            } else
              console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
          }),
          (this.setFramebuffer = function (e) {
            m !== e && null === y && ce.bindFramebuffer(36160, e), (m = e);
          }),
          (this.getActiveCubeFace = function () {
            return v;
          }),
          (this.getActiveMipmapLevel = function () {
            return g;
          }),
          (this.getRenderTarget = function () {
            return y;
          }),
          (this.setRenderTarget = function (e, t, n) {
            (y = e),
              (v = t),
              (g = n),
              e &&
                void 0 === q.get(e).__webglFramebuffer &&
                X.setupRenderTarget(e);
            var r = m,
              i = !1;
            if (e) {
              var a = q.get(e).__webglFramebuffer;
              e.isWebGLCubeRenderTarget
                ? ((r = a[t || 0]), (i = !0))
                : (r = e.isWebGLMultisampleRenderTarget
                    ? q.get(e).__webglMultisampledFramebuffer
                    : a),
                M.copy(e.viewport),
                S.copy(e.scissor),
                (T = e.scissorTest);
            } else
              M.copy(P).multiplyScalar(L).floor(),
                S.copy(O).multiplyScalar(L).floor(),
                (T = D);
            if (
              (x !== r && (ce.bindFramebuffer(36160, r), (x = r)),
              V.viewport(M),
              V.scissor(S),
              V.setScissorTest(T),
              i)
            ) {
              var o = q.get(e.texture);
              ce.framebufferTexture2D(
                36160,
                36064,
                34069 + (t || 0),
                o.__webglTexture,
                n || 0
              );
            }
          }),
          (this.readRenderTargetPixels = function (e, t, n, r, i, a, o) {
            if (e && e.isWebGLRenderTarget) {
              var s = q.get(e).__webglFramebuffer;
              if (
                (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s)
              ) {
                var c = !1;
                s !== x && (ce.bindFramebuffer(36160, s), (c = !0));
                try {
                  var u = e.texture,
                    l = u.format,
                    h = u.type;
                  if (l !== ke && oe.convert(l) !== ce.getParameter(35739))
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    );
                  if (
                    !(
                      h === Ae ||
                      oe.convert(h) === ce.getParameter(35738) ||
                      (h === De &&
                        (j.isWebGL2 ||
                          H.get("OES_texture_float") ||
                          H.get("WEBGL_color_buffer_float"))) ||
                      (h === Ie &&
                        H.get(
                          j.isWebGL2
                            ? "EXT_color_buffer_float"
                            : "EXT_color_buffer_half_float"
                        ))
                    )
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
                  36053 === ce.checkFramebufferStatus(36160)
                    ? t >= 0 &&
                      t <= e.width - r &&
                      n >= 0 &&
                      n <= e.height - i &&
                      ce.readPixels(t, n, r, i, oe.convert(l), oe.convert(h), a)
                    : console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                      );
                } finally {
                  c && ce.bindFramebuffer(36160, x);
                }
              }
            } else
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
          }),
          (this.copyFramebufferToTexture = function (e, t, n) {
            void 0 === n && (n = 0);
            var r = Math.pow(2, -n),
              i = Math.floor(t.image.width * r),
              a = Math.floor(t.image.height * r),
              o = oe.convert(t.format);
            X.setTexture2D(t, 0),
              ce.copyTexImage2D(3553, n, o, e.x, e.y, i, a, 0),
              V.unbindTexture();
          }),
          (this.copyTextureToTexture = function (e, t, n, r) {
            void 0 === r && (r = 0);
            var i = t.image.width,
              a = t.image.height,
              o = oe.convert(n.format),
              s = oe.convert(n.type);
            X.setTexture2D(n, 0),
              ce.pixelStorei(37440, n.flipY),
              ce.pixelStorei(37441, n.premultiplyAlpha),
              ce.pixelStorei(3317, n.unpackAlignment),
              t.isDataTexture
                ? ce.texSubImage2D(3553, r, e.x, e.y, i, a, o, s, t.image.data)
                : t.isCompressedTexture
                ? ce.compressedTexSubImage2D(
                    3553,
                    r,
                    e.x,
                    e.y,
                    t.mipmaps[0].width,
                    t.mipmaps[0].height,
                    o,
                    t.mipmaps[0].data
                  )
                : ce.texSubImage2D(3553, r, e.x, e.y, o, s, t.image),
              0 === r && n.generateMipmaps && ce.generateMipmap(3553),
              V.unbindTexture();
          }),
          (this.initTexture = function (e) {
            X.setTexture2D(e, 0), V.unbindTexture();
          }),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      function Us(e) {
        Fs.call(this, e);
      }
      function Gs(e, t) {
        (this.name = ""),
          (this.color = new vi(e)),
          (this.density = void 0 !== t ? t : 25e-5);
      }
      function ks(e, t, n) {
        (this.name = ""),
          (this.color = new vi(e)),
          (this.near = void 0 !== t ? t : 1),
          (this.far = void 0 !== n ? n : 1e3);
      }
      function Hs(e, t) {
        (this.array = e),
          (this.stride = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.usage = Ln),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0),
          (this.uuid = kn.generateUUID());
      }
      ((As.prototype = Object.create(wi.prototype)).constructor = As),
        (As.prototype.isMeshDepthMaterial = !0),
        (As.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            (this.depthPacking = e.depthPacking),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }),
        ((Ls.prototype = Object.create(wi.prototype)).constructor = Ls),
        (Ls.prototype.isMeshDistanceMaterial = !0),
        (Ls.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            this.referencePosition.copy(e.referencePosition),
            (this.nearDistance = e.nearDistance),
            (this.farDistance = e.farDistance),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }),
        (Ds.prototype = Object.assign(Object.create(Sa.prototype), {
          constructor: Ds,
          isArrayCamera: !0,
        })),
        (Is.prototype = Object.assign(Object.create(Tr.prototype), {
          constructor: Is,
          isGroup: !0,
        })),
        Object.assign(Ns.prototype, {
          constructor: Ns,
          getTargetRaySpace: function () {
            return (
              null === this._targetRay &&
                ((this._targetRay = new Is()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1)),
              this._targetRay
            );
          },
          getGripSpace: function () {
            return (
              null === this._grip &&
                ((this._grip = new Is()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1)),
              this._grip
            );
          },
          dispatchEvent: function (e) {
            return (
              null !== this._targetRay && this._targetRay.dispatchEvent(e),
              null !== this._grip && this._grip.dispatchEvent(e),
              this
            );
          },
          disconnect: function (e) {
            return (
              this.dispatchEvent({ type: "disconnected", data: e }),
              null !== this._targetRay && (this._targetRay.visible = !1),
              null !== this._grip && (this._grip.visible = !1),
              this
            );
          },
          update: function (e, t, n) {
            var r = null,
              i = null,
              a = this._targetRay,
              o = this._grip;
            return (
              e &&
                (null !== a &&
                  null !== (r = t.getPose(e.targetRaySpace, n)) &&
                  (a.matrix.fromArray(r.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale)),
                null !== o &&
                  e.gripSpace &&
                  null !== (i = t.getPose(e.gripSpace, n)) &&
                  (o.matrix.fromArray(i.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale))),
              null !== a && (a.visible = null !== r),
              null !== o && (o.visible = null !== i),
              this
            );
          },
        }),
        Object.assign(Bs.prototype, zn.prototype),
        (Us.prototype = Object.assign(Object.create(Fs.prototype), {
          constructor: Us,
          isWebGL1Renderer: !0,
        })),
        Object.assign(Gs.prototype, {
          isFogExp2: !0,
          clone: function () {
            return new Gs(this.color, this.density);
          },
          toJSON: function () {
            return {
              type: "FogExp2",
              color: this.color.getHex(),
              density: this.density,
            };
          },
        }),
        Object.assign(ks.prototype, {
          isFog: !0,
          clone: function () {
            return new ks(this.color, this.near, this.far);
          },
          toJSON: function () {
            return {
              type: "Fog",
              color: this.color.getHex(),
              near: this.near,
              far: this.far,
            };
          },
        }),
        Object.defineProperty(Hs.prototype, "needsUpdate", {
          set: function (e) {
            !0 === e && this.version++;
          },
        }),
        Object.assign(Hs.prototype, {
          isInterleavedBuffer: !0,
          onUploadCallback: function () {},
          setUsage: function (e) {
            return (this.usage = e), this;
          },
          copy: function (e) {
            return (
              (this.array = new e.array.constructor(e.array)),
              (this.count = e.count),
              (this.stride = e.stride),
              (this.usage = e.usage),
              this
            );
          },
          copyAt: function (e, t, n) {
            (e *= this.stride), (n *= t.stride);
            for (var r = 0, i = this.stride; r < i; r++)
              this.array[e + r] = t.array[n + r];
            return this;
          },
          set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this;
          },
          clone: function (e) {
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = kn.generateUUID()),
              void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
                (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(
                  0
                ).buffer);
            var t = new Hs(
              new this.array.constructor(
                e.arrayBuffers[this.array.buffer._uuid]
              ),
              this.stride
            );
            return t.setUsage(this.usage), t;
          },
          onUpload: function (e) {
            return (this.onUploadCallback = e), this;
          },
          toJSON: function (e) {
            return (
              void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = kn.generateUUID()),
              void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
                (e.arrayBuffers[
                  this.array.buffer._uuid
                ] = Array.prototype.slice.call(
                  new Uint32Array(this.array.buffer)
                )),
              {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
              }
            );
          },
        });
      var js,
        Vs = new $n();
      function Ws(e, t, n, r) {
        (this.name = ""),
          (this.data = e),
          (this.itemSize = t),
          (this.offset = n),
          (this.normalized = !0 === r);
      }
      function qs(e) {
        wi.call(this),
          (this.type = "SpriteMaterial"),
          (this.color = new vi(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.rotation = 0),
          (this.sizeAttenuation = !0),
          (this.transparent = !0),
          this.setValues(e);
      }
      Object.defineProperties(Ws.prototype, {
        count: {
          get: function () {
            return this.data.count;
          },
        },
        array: {
          get: function () {
            return this.data.array;
          },
        },
      }),
        Object.assign(Ws.prototype, {
          isInterleavedBufferAttribute: !0,
          applyMatrix4: function (e) {
            for (var t = 0, n = this.data.count; t < n; t++)
              (Vs.x = this.getX(t)),
                (Vs.y = this.getY(t)),
                (Vs.z = this.getZ(t)),
                Vs.applyMatrix4(e),
                this.setXYZ(t, Vs.x, Vs.y, Vs.z);
            return this;
          },
          setX: function (e, t) {
            return (
              (this.data.array[e * this.data.stride + this.offset] = t), this
            );
          },
          setY: function (e, t) {
            return (
              (this.data.array[e * this.data.stride + this.offset + 1] = t),
              this
            );
          },
          setZ: function (e, t) {
            return (
              (this.data.array[e * this.data.stride + this.offset + 2] = t),
              this
            );
          },
          setW: function (e, t) {
            return (
              (this.data.array[e * this.data.stride + this.offset + 3] = t),
              this
            );
          },
          getX: function (e) {
            return this.data.array[e * this.data.stride + this.offset];
          },
          getY: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 1];
          },
          getZ: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 2];
          },
          getW: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 3];
          },
          setXY: function (e, t, n) {
            return (
              (this.data.array[
                (e = e * this.data.stride + this.offset) + 0
              ] = t),
              (this.data.array[e + 1] = n),
              this
            );
          },
          setXYZ: function (e, t, n, r) {
            return (
              (this.data.array[
                (e = e * this.data.stride + this.offset) + 0
              ] = t),
              (this.data.array[e + 1] = n),
              (this.data.array[e + 2] = r),
              this
            );
          },
          setXYZW: function (e, t, n, r, i) {
            return (
              (this.data.array[
                (e = e * this.data.stride + this.offset) + 0
              ] = t),
              (this.data.array[e + 1] = n),
              (this.data.array[e + 2] = r),
              (this.data.array[e + 3] = i),
              this
            );
          },
          clone: function (e) {
            if (void 0 === e) {
              console.log(
                "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
              );
              for (var t = [], n = 0; n < this.count; n++)
                for (
                  var r = n * this.data.stride + this.offset, i = 0;
                  i < this.itemSize;
                  i++
                )
                  t.push(this.data.array[r + i]);
              return new Ei(
                new this.array.constructor(t),
                this.itemSize,
                this.normalized
              );
            }
            return (
              void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
              void 0 === e.interleavedBuffers[this.data.uuid] &&
                (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
              new Ws(
                e.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
          },
          toJSON: function (e) {
            if (void 0 === e) {
              console.log(
                "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
              );
              for (var t = [], n = 0; n < this.count; n++)
                for (
                  var r = n * this.data.stride + this.offset, i = 0;
                  i < this.itemSize;
                  i++
                )
                  t.push(this.data.array[r + i]);
              return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized,
              };
            }
            return (
              void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
              void 0 === e.interleavedBuffers[this.data.uuid] &&
                (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
          },
        }),
        ((qs.prototype = Object.create(wi.prototype)).constructor = qs),
        (qs.prototype.isSpriteMaterial = !0),
        (qs.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            this
          );
        });
      var Xs = new $n(),
        Ys = new $n(),
        Zs = new $n(),
        Js = new Hn(),
        Ks = new Hn(),
        Qs = new sr(),
        $s = new $n(),
        ec = new $n(),
        tc = new $n(),
        nc = new Hn(),
        rc = new Hn(),
        ic = new Hn();
      function ac(e) {
        if ((Tr.call(this), (this.type = "Sprite"), void 0 === js)) {
          js = new Wi();
          var t = new Hs(
            new Float32Array([
              -0.5,
              -0.5,
              0,
              0,
              0,
              0.5,
              -0.5,
              0,
              1,
              0,
              0.5,
              0.5,
              0,
              1,
              1,
              -0.5,
              0.5,
              0,
              0,
              1,
            ]),
            5
          );
          js.setIndex([0, 1, 2, 0, 2, 3]),
            js.setAttribute("position", new Ws(t, 3, 0, !1)),
            js.setAttribute("uv", new Ws(t, 2, 3, !1));
        }
        (this.geometry = js),
          (this.material = void 0 !== e ? e : new qs()),
          (this.center = new Hn(0.5, 0.5));
      }
      function oc(e, t, n, r, i, a) {
        Js.subVectors(e, n).addScalar(0.5).multiply(r),
          void 0 !== i
            ? ((Ks.x = a * Js.x - i * Js.y), (Ks.y = i * Js.x + a * Js.y))
            : Ks.copy(Js),
          e.copy(t),
          (e.x += Ks.x),
          (e.y += Ks.y),
          e.applyMatrix4(Qs);
      }
      ac.prototype = Object.assign(Object.create(Tr.prototype), {
        constructor: ac,
        isSprite: !0,
        raycast: function (e, t) {
          null === e.camera &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            Ys.setFromMatrixScale(this.matrixWorld),
            Qs.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              e.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            Zs.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera &&
              !1 === this.material.sizeAttenuation &&
              Ys.multiplyScalar(-Zs.z);
          var n,
            r,
            i = this.material.rotation;
          0 !== i && ((r = Math.cos(i)), (n = Math.sin(i)));
          var a = this.center;
          oc($s.set(-0.5, -0.5, 0), Zs, a, Ys, n, r),
            oc(ec.set(0.5, -0.5, 0), Zs, a, Ys, n, r),
            oc(tc.set(0.5, 0.5, 0), Zs, a, Ys, n, r),
            nc.set(0, 0),
            rc.set(1, 0),
            ic.set(1, 1);
          var o = e.ray.intersectTriangle($s, ec, tc, !1, Xs);
          if (
            null !== o ||
            (oc(ec.set(-0.5, 0.5, 0), Zs, a, Ys, n, r),
            rc.set(0, 1),
            null !== (o = e.ray.intersectTriangle($s, tc, ec, !1, Xs)))
          ) {
            var s = e.ray.origin.distanceTo(Xs);
            s < e.near ||
              s > e.far ||
              t.push({
                distance: s,
                point: Xs.clone(),
                uv: di.getUV(Xs, $s, ec, tc, nc, rc, ic, new Hn()),
                face: null,
                object: this,
              });
          }
        },
        copy: function (e) {
          return (
            Tr.prototype.copy.call(this, e),
            void 0 !== e.center && this.center.copy(e.center),
            (this.material = e.material),
            this
          );
        },
      });
      var sc,
        cc,
        uc,
        lc,
        hc,
        dc = new $n(),
        pc = new $n();
      function fc() {
        Tr.call(this),
          (this._currentLevel = 0),
          (this.type = "LOD"),
          Object.defineProperties(this, {
            levels: { enumerable: !0, value: [] },
          }),
          (this.autoUpdate = !0);
      }
      function mc(e, t) {
        e &&
          e.isGeometry &&
          console.error(
            "THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          ),
          ua.call(this, e, t),
          (this.type = "SkinnedMesh"),
          (this.bindMode = "attached"),
          (this.bindMatrix = new sr()),
          (this.bindMatrixInverse = new sr());
      }
      (fc.prototype = Object.assign(Object.create(Tr.prototype), {
        constructor: fc,
        isLOD: !0,
        copy: function (e) {
          Tr.prototype.copy.call(this, e, !1);
          for (var t = e.levels, n = 0, r = t.length; n < r; n++) {
            var i = t[n];
            this.addLevel(i.object.clone(), i.distance);
          }
          return (this.autoUpdate = e.autoUpdate), this;
        },
        addLevel: function (e, t) {
          void 0 === t && (t = 0), (t = Math.abs(t));
          var n,
            r = this.levels;
          for (n = 0; n < r.length && !(t < r[n].distance); n++);
          return r.splice(n, 0, { distance: t, object: e }), this.add(e), this;
        },
        getCurrentLevel: function () {
          return this._currentLevel;
        },
        getObjectForDistance: function (e) {
          var t = this.levels;
          if (t.length > 0) {
            var n, r;
            for (n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
            return t[n - 1].object;
          }
          return null;
        },
        raycast: function (e, t) {
          if (this.levels.length > 0) {
            dc.setFromMatrixPosition(this.matrixWorld);
            var n = e.ray.origin.distanceTo(dc);
            this.getObjectForDistance(n).raycast(e, t);
          }
        },
        update: function (e) {
          var t = this.levels;
          if (t.length > 1) {
            dc.setFromMatrixPosition(e.matrixWorld),
              pc.setFromMatrixPosition(this.matrixWorld);
            var n,
              r,
              i = dc.distanceTo(pc) / e.zoom;
            for (
              t[0].object.visible = !0, n = 1, r = t.length;
              n < r && i >= t[n].distance;
              n++
            )
              (t[n - 1].object.visible = !1), (t[n].object.visible = !0);
            for (this._currentLevel = n - 1; n < r; n++)
              t[n].object.visible = !1;
          }
        },
        toJSON: function (e) {
          var t = Tr.prototype.toJSON.call(this, e);
          !1 === this.autoUpdate && (t.object.autoUpdate = !1),
            (t.object.levels = []);
          for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
            var a = n[r];
            t.object.levels.push({
              object: a.object.uuid,
              distance: a.distance,
            });
          }
          return t;
        },
      })),
        (mc.prototype = Object.assign(Object.create(ua.prototype), {
          constructor: mc,
          isSkinnedMesh: !0,
          copy: function (e) {
            return (
              ua.prototype.copy.call(this, e),
              (this.bindMode = e.bindMode),
              this.bindMatrix.copy(e.bindMatrix),
              this.bindMatrixInverse.copy(e.bindMatrixInverse),
              (this.skeleton = e.skeleton),
              this
            );
          },
          bind: function (e, t) {
            (this.skeleton = e),
              void 0 === t &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (t = this.matrixWorld)),
              this.bindMatrix.copy(t),
              this.bindMatrixInverse.getInverse(t);
          },
          pose: function () {
            this.skeleton.pose();
          },
          normalizeSkinWeights: function () {
            for (
              var e = new Xn(),
                t = this.geometry.attributes.skinWeight,
                n = 0,
                r = t.count;
              n < r;
              n++
            ) {
              (e.x = t.getX(n)),
                (e.y = t.getY(n)),
                (e.z = t.getZ(n)),
                (e.w = t.getW(n));
              var i = 1 / e.manhattanLength();
              i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
                t.setXYZW(n, e.x, e.y, e.z, e.w);
            }
          },
          updateMatrixWorld: function (e) {
            ua.prototype.updateMatrixWorld.call(this, e),
              "attached" === this.bindMode
                ? this.bindMatrixInverse.getInverse(this.matrixWorld)
                : "detached" === this.bindMode
                ? this.bindMatrixInverse.getInverse(this.bindMatrix)
                : console.warn(
                    "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                  );
          },
          boneTransform:
            ((sc = new $n()),
            (cc = new Xn()),
            (uc = new Xn()),
            (lc = new $n()),
            (hc = new sr()),
            function (e, t) {
              var n = this.skeleton,
                r = this.geometry;
              cc.fromBufferAttribute(r.attributes.skinIndex, e),
                uc.fromBufferAttribute(r.attributes.skinWeight, e),
                sc
                  .fromBufferAttribute(r.attributes.position, e)
                  .applyMatrix4(this.bindMatrix),
                t.set(0, 0, 0);
              for (var i = 0; i < 4; i++) {
                var a = uc.getComponent(i);
                if (0 !== a) {
                  var o = cc.getComponent(i);
                  hc.multiplyMatrices(
                    n.bones[o].matrixWorld,
                    n.boneInverses[o]
                  ),
                    t.addScaledVector(lc.copy(sc).applyMatrix4(hc), a);
                }
              }
              return t.applyMatrix4(this.bindMatrixInverse);
            }),
        }));
      var vc = new sr(),
        gc = new sr();
      function yc(e, t) {
        if (
          ((this.bones = (e = e || []).slice(0)),
          (this.boneMatrices = new Float32Array(16 * this.bones.length)),
          (this.frame = -1),
          void 0 === t)
        )
          this.calculateInverses();
        else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
        else {
          console.warn("THREE.Skeleton boneInverses is the wrong length."),
            (this.boneInverses = []);
          for (var n = 0, r = this.bones.length; n < r; n++)
            this.boneInverses.push(new sr());
        }
      }
      function xc() {
        Tr.call(this), (this.type = "Bone");
      }
      Object.assign(yc.prototype, {
        calculateInverses: function () {
          this.boneInverses = [];
          for (var e = 0, t = this.bones.length; e < t; e++) {
            var n = new sr();
            this.bones[e] && n.getInverse(this.bones[e].matrixWorld),
              this.boneInverses.push(n);
          }
        },
        pose: function () {
          for (var e = 0, t = this.bones.length; e < t; e++) {
            var n = this.bones[e];
            n && n.matrixWorld.getInverse(this.boneInverses[e]);
          }
          for (var r = 0, i = this.bones.length; r < i; r++) {
            var a = this.bones[r];
            a &&
              (a.parent && a.parent.isBone
                ? (a.matrix.getInverse(a.parent.matrixWorld),
                  a.matrix.multiply(a.matrixWorld))
                : a.matrix.copy(a.matrixWorld),
              a.matrix.decompose(a.position, a.quaternion, a.scale));
          }
        },
        update: function () {
          for (
            var e = this.bones,
              t = this.boneInverses,
              n = this.boneMatrices,
              r = this.boneTexture,
              i = 0,
              a = e.length;
            i < a;
            i++
          )
            vc.multiplyMatrices(e[i] ? e[i].matrixWorld : gc, t[i]),
              vc.toArray(n, 16 * i);
          void 0 !== r && (r.needsUpdate = !0);
        },
        clone: function () {
          return new yc(this.bones, this.boneInverses);
        },
        getBoneByName: function (e) {
          for (var t = 0, n = this.bones.length; t < n; t++) {
            var r = this.bones[t];
            if (r.name === e) return r;
          }
        },
        dispose: function () {
          this.boneTexture &&
            (this.boneTexture.dispose(), (this.boneTexture = void 0));
        },
      }),
        (xc.prototype = Object.assign(Object.create(Tr.prototype), {
          constructor: xc,
          isBone: !0,
        }));
      var bc = new sr(),
        _c = new sr(),
        wc = [],
        Mc = new ua();
      function Sc(e, t, n) {
        ua.call(this, e, t),
          (this.instanceMatrix = new Ei(new Float32Array(16 * n), 16)),
          (this.count = n),
          (this.frustumCulled = !1);
      }
      function Tc(e) {
        wi.call(this),
          (this.type = "LineBasicMaterial"),
          (this.color = new vi(16777215)),
          (this.linewidth = 1),
          (this.linecap = "round"),
          (this.linejoin = "round"),
          (this.morphTargets = !1),
          this.setValues(e);
      }
      (Sc.prototype = Object.assign(Object.create(ua.prototype), {
        constructor: Sc,
        isInstancedMesh: !0,
        copy: function (e) {
          return (
            ua.prototype.copy.call(this, e),
            this.instanceMatrix.copy(e.instanceMatrix),
            (this.count = e.count),
            this
          );
        },
        getMatrixAt: function (e, t) {
          t.fromArray(this.instanceMatrix.array, 16 * e);
        },
        raycast: function (e, t) {
          var n = this.matrixWorld,
            r = this.count;
          if (
            ((Mc.geometry = this.geometry),
            (Mc.material = this.material),
            void 0 !== Mc.material)
          )
            for (var i = 0; i < r; i++) {
              this.getMatrixAt(i, bc),
                _c.multiplyMatrices(n, bc),
                (Mc.matrixWorld = _c),
                Mc.raycast(e, wc);
              for (var a = 0, o = wc.length; a < o; a++) {
                var s = wc[a];
                (s.instanceId = i), (s.object = this), t.push(s);
              }
              wc.length = 0;
            }
        },
        setMatrixAt: function (e, t) {
          t.toArray(this.instanceMatrix.array, 16 * e);
        },
        updateMorphTargets: function () {},
      })),
        ((Tc.prototype = Object.create(wi.prototype)).constructor = Tc),
        (Tc.prototype.isLineBasicMaterial = !0),
        (Tc.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.morphTargets = e.morphTargets),
            this
          );
        });
      var Ec = new $n(),
        Ac = new $n(),
        Lc = new sr(),
        Cc = new Kr(),
        Rc = new jr();
      function Pc(e, t, n) {
        1 === n &&
          console.error(
            "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
          ),
          Tr.call(this),
          (this.type = "Line"),
          (this.geometry = void 0 !== e ? e : new Wi()),
          (this.material = void 0 !== t ? t : new Tc()),
          this.updateMorphTargets();
      }
      Pc.prototype = Object.assign(Object.create(Tr.prototype), {
        constructor: Pc,
        isLine: !0,
        copy: function (e) {
          return (
            Tr.prototype.copy.call(this, e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        },
        computeLineDistances: function () {
          var e = this.geometry;
          if (e.isBufferGeometry)
            if (null === e.index) {
              for (
                var t = e.attributes.position, n = [0], r = 1, i = t.count;
                r < i;
                r++
              )
                Ec.fromBufferAttribute(t, r - 1),
                  Ac.fromBufferAttribute(t, r),
                  (n[r] = n[r - 1]),
                  (n[r] += Ec.distanceTo(Ac));
              e.setAttribute("lineDistance", new Ii(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else if (e.isGeometry) {
            var a = e.vertices,
              o = e.lineDistances;
            o[0] = 0;
            for (var s = 1, c = a.length; s < c; s++)
              (o[s] = o[s - 1]), (o[s] += a[s - 1].distanceTo(a[s]));
          }
          return this;
        },
        raycast: function (e, t) {
          var n = this.geometry,
            r = this.matrixWorld,
            i = e.params.Line.threshold;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            Rc.copy(n.boundingSphere),
            Rc.applyMatrix4(r),
            (Rc.radius += i),
            !1 !== e.ray.intersectsSphere(Rc))
          ) {
            Lc.getInverse(r), Cc.copy(e.ray).applyMatrix4(Lc);
            var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              o = a * a,
              s = new $n(),
              c = new $n(),
              u = new $n(),
              l = new $n(),
              h = this && this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
              var d = n.index,
                p = n.attributes.position.array;
              if (null !== d)
                for (var f = d.array, m = 0, v = f.length - 1; m < v; m += h) {
                  var g = f[m + 1];
                  if (
                    (s.fromArray(p, 3 * f[m]),
                    c.fromArray(p, 3 * g),
                    !(Cc.distanceSqToSegment(s, c, l, u) > o))
                  ) {
                    l.applyMatrix4(this.matrixWorld);
                    var y = e.ray.origin.distanceTo(l);
                    y < e.near ||
                      y > e.far ||
                      t.push({
                        distance: y,
                        point: u.clone().applyMatrix4(this.matrixWorld),
                        index: m,
                        face: null,
                        faceIndex: null,
                        object: this,
                      });
                  }
                }
              else
                for (var x = 0, b = p.length / 3 - 1; x < b; x += h)
                  if (
                    (s.fromArray(p, 3 * x),
                    c.fromArray(p, 3 * x + 3),
                    !(Cc.distanceSqToSegment(s, c, l, u) > o))
                  ) {
                    l.applyMatrix4(this.matrixWorld);
                    var _ = e.ray.origin.distanceTo(l);
                    _ < e.near ||
                      _ > e.far ||
                      t.push({
                        distance: _,
                        point: u.clone().applyMatrix4(this.matrixWorld),
                        index: x,
                        face: null,
                        faceIndex: null,
                        object: this,
                      });
                  }
            } else if (n.isGeometry)
              for (var w = n.vertices, M = w.length, S = 0; S < M - 1; S += h)
                if (!(Cc.distanceSqToSegment(w[S], w[S + 1], l, u) > o)) {
                  l.applyMatrix4(this.matrixWorld);
                  var T = e.ray.origin.distanceTo(l);
                  T < e.near ||
                    T > e.far ||
                    t.push({
                      distance: T,
                      point: u.clone().applyMatrix4(this.matrixWorld),
                      index: S,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
                }
          }
        },
        updateMorphTargets: function () {
          var e = this.geometry;
          if (e.isBufferGeometry) {
            var t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              var r = t[n[0]];
              if (void 0 !== r) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (var i = 0, a = r.length; i < a; i++) {
                  var o = r[i].name || String(i);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[o] = i);
                }
              }
            }
          } else {
            var s = e.morphTargets;
            void 0 !== s &&
              s.length > 0 &&
              console.error(
                "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        },
      });
      var Oc = new $n(),
        Dc = new $n();
      function Ic(e, t) {
        Pc.call(this, e, t), (this.type = "LineSegments");
      }
      function Nc(e, t) {
        Pc.call(this, e, t), (this.type = "LineLoop");
      }
      function Bc(e) {
        wi.call(this),
          (this.type = "PointsMaterial"),
          (this.color = new vi(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.size = 1),
          (this.sizeAttenuation = !0),
          (this.morphTargets = !1),
          this.setValues(e);
      }
      (Ic.prototype = Object.assign(Object.create(Pc.prototype), {
        constructor: Ic,
        isLineSegments: !0,
        computeLineDistances: function () {
          var e = this.geometry;
          if (e.isBufferGeometry)
            if (null === e.index) {
              for (
                var t = e.attributes.position, n = [], r = 0, i = t.count;
                r < i;
                r += 2
              )
                Oc.fromBufferAttribute(t, r),
                  Dc.fromBufferAttribute(t, r + 1),
                  (n[r] = 0 === r ? 0 : n[r - 1]),
                  (n[r + 1] = n[r] + Oc.distanceTo(Dc));
              e.setAttribute("lineDistance", new Ii(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else if (e.isGeometry)
            for (
              var a = e.vertices, o = e.lineDistances, s = 0, c = a.length;
              s < c;
              s += 2
            )
              Oc.copy(a[s]),
                Dc.copy(a[s + 1]),
                (o[s] = 0 === s ? 0 : o[s - 1]),
                (o[s + 1] = o[s] + Oc.distanceTo(Dc));
          return this;
        },
      })),
        (Nc.prototype = Object.assign(Object.create(Pc.prototype), {
          constructor: Nc,
          isLineLoop: !0,
        })),
        ((Bc.prototype = Object.create(wi.prototype)).constructor = Bc),
        (Bc.prototype.isPointsMaterial = !0),
        (Bc.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.morphTargets = e.morphTargets),
            this
          );
        });
      var zc = new sr(),
        Fc = new Kr(),
        Uc = new jr(),
        Gc = new $n();
      function kc(e, t) {
        Tr.call(this),
          (this.type = "Points"),
          (this.geometry = void 0 !== e ? e : new Wi()),
          (this.material = void 0 !== t ? t : new Bc()),
          this.updateMorphTargets();
      }
      function Hc(e, t, n, r, i, a, o) {
        var s = Fc.distanceSqToPoint(e);
        if (s < n) {
          var c = new $n();
          Fc.closestPointToPoint(e, c), c.applyMatrix4(r);
          var u = i.ray.origin.distanceTo(c);
          if (u < i.near || u > i.far) return;
          a.push({
            distance: u,
            distanceToRay: Math.sqrt(s),
            point: c,
            index: t,
            face: null,
            object: o,
          });
        }
      }
      function jc(e, t, n, r, i, a, o, s, c) {
        qn.call(this, e, t, n, r, i, a, o, s, c),
          (this.format = void 0 !== o ? o : Ge),
          (this.minFilter = void 0 !== a ? a : we),
          (this.magFilter = void 0 !== i ? i : we),
          (this.generateMipmaps = !1);
      }
      function Vc(e, t, n, r, i, a, o, s, c, u, l, h) {
        qn.call(this, null, a, o, s, c, u, r, i, l, h),
          (this.image = { width: t, height: n }),
          (this.mipmaps = e),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
      function Wc(e, t, n, r, i, a, o, s, c) {
        qn.call(this, e, t, n, r, i, a, o, s, c), (this.needsUpdate = !0);
      }
      function qc(e, t, n, r, i, a, o, s, c, u) {
        if ((u = void 0 !== u ? u : We) !== We && u !== qe)
          throw new Error(
            "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
          );
        void 0 === n && u === We && (n = Re),
          void 0 === n && u === qe && (n = Fe),
          qn.call(this, null, r, i, a, o, s, u, n, c),
          (this.image = { width: e, height: t }),
          (this.magFilter = void 0 !== o ? o : ge),
          (this.minFilter = void 0 !== s ? s : ge),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
      function Xc(e) {
        Wi.call(this), (this.type = "WireframeGeometry");
        var t = [],
          n = [0, 0],
          r = {},
          i = ["a", "b", "c"];
        if (e && e.isGeometry) {
          for (var a = e.faces, o = 0, s = a.length; o < s; o++)
            for (var c = a[o], u = 0; u < 3; u++) {
              var l = c[i[u]],
                h = c[i[(u + 1) % 3]];
              (n[0] = Math.min(l, h)), (n[1] = Math.max(l, h));
              var d = n[0] + "," + n[1];
              void 0 === r[d] && (r[d] = { index1: n[0], index2: n[1] });
            }
          for (var p in r) {
            var f = r[p],
              m = e.vertices[f.index1];
            t.push(m.x, m.y, m.z),
              (m = e.vertices[f.index2]),
              t.push(m.x, m.y, m.z);
          }
        } else if (e && e.isBufferGeometry) {
          var v = new $n();
          if (null !== e.index) {
            var g = e.attributes.position,
              y = e.index,
              x = e.groups;
            0 === x.length &&
              (x = [{ start: 0, count: y.count, materialIndex: 0 }]);
            for (var b = 0, _ = x.length; b < _; ++b)
              for (
                var w = x[b], M = w.start, S = M, T = M + w.count;
                S < T;
                S += 3
              )
                for (var E = 0; E < 3; E++) {
                  var A = y.getX(S + E),
                    L = y.getX(S + ((E + 1) % 3));
                  (n[0] = Math.min(A, L)), (n[1] = Math.max(A, L));
                  var C = n[0] + "," + n[1];
                  void 0 === r[C] && (r[C] = { index1: n[0], index2: n[1] });
                }
            for (var R in r) {
              var P = r[R];
              v.fromBufferAttribute(g, P.index1),
                t.push(v.x, v.y, v.z),
                v.fromBufferAttribute(g, P.index2),
                t.push(v.x, v.y, v.z);
            }
          } else
            for (
              var O = e.attributes.position, D = 0, I = O.count / 3;
              D < I;
              D++
            )
              for (var N = 0; N < 3; N++)
                v.fromBufferAttribute(O, 3 * D + N),
                  t.push(v.x, v.y, v.z),
                  v.fromBufferAttribute(O, 3 * D + ((N + 1) % 3)),
                  t.push(v.x, v.y, v.z);
        }
        this.setAttribute("position", new Ii(t, 3));
      }
      function Yc(e, t, n) {
        va.call(this),
          (this.type = "ParametricGeometry"),
          (this.parameters = { func: e, slices: t, stacks: n }),
          this.fromBufferGeometry(new Zc(e, t, n)),
          this.mergeVertices();
      }
      function Zc(e, t, n) {
        Wi.call(this),
          (this.type = "ParametricBufferGeometry"),
          (this.parameters = { func: e, slices: t, stacks: n });
        var r = [],
          i = [],
          a = [],
          o = [],
          s = 1e-5,
          c = new $n(),
          u = new $n(),
          l = new $n(),
          h = new $n(),
          d = new $n();
        e.length < 3 &&
          console.error(
            "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
          );
        for (var p = t + 1, f = 0; f <= n; f++)
          for (var m = f / n, v = 0; v <= t; v++) {
            var g = v / t;
            e(g, m, u),
              i.push(u.x, u.y, u.z),
              g - s >= 0
                ? (e(g - s, m, l), h.subVectors(u, l))
                : (e(g + s, m, l), h.subVectors(l, u)),
              m - s >= 0
                ? (e(g, m - s, l), d.subVectors(u, l))
                : (e(g, m + s, l), d.subVectors(l, u)),
              c.crossVectors(h, d).normalize(),
              a.push(c.x, c.y, c.z),
              o.push(g, m);
          }
        for (var y = 0; y < n; y++)
          for (var x = 0; x < t; x++) {
            var b = y * p + x + 1,
              _ = (y + 1) * p + x + 1,
              w = (y + 1) * p + x;
            r.push(y * p + x, b, w), r.push(b, _, w);
          }
        this.setIndex(r),
          this.setAttribute("position", new Ii(i, 3)),
          this.setAttribute("normal", new Ii(a, 3)),
          this.setAttribute("uv", new Ii(o, 2));
      }
      function Jc(e, t, n, r) {
        va.call(this),
          (this.type = "PolyhedronGeometry"),
          (this.parameters = { vertices: e, indices: t, radius: n, detail: r }),
          this.fromBufferGeometry(new Kc(e, t, n, r)),
          this.mergeVertices();
      }
      function Kc(e, t, n, r) {
        Wi.call(this),
          (this.type = "PolyhedronBufferGeometry"),
          (this.parameters = { vertices: e, indices: t, radius: n, detail: r }),
          (n = n || 1);
        var i = [],
          a = [];
        function o(e, t, n, r) {
          for (var i = Math.pow(2, r), a = [], o = 0; o <= i; o++) {
            a[o] = [];
            for (
              var c = e.clone().lerp(n, o / i),
                u = t.clone().lerp(n, o / i),
                l = i - o,
                h = 0;
              h <= l;
              h++
            )
              a[o][h] = 0 === h && o === i ? c : c.clone().lerp(u, h / l);
          }
          for (var d = 0; d < i; d++)
            for (var p = 0; p < 2 * (i - d) - 1; p++) {
              var f = Math.floor(p / 2);
              p % 2 == 0
                ? (s(a[d][f + 1]), s(a[d + 1][f]), s(a[d][f]))
                : (s(a[d][f + 1]), s(a[d + 1][f + 1]), s(a[d + 1][f]));
            }
        }
        function s(e) {
          i.push(e.x, e.y, e.z);
        }
        function c(t, n) {
          var r = 3 * t;
          (n.x = e[r + 0]), (n.y = e[r + 1]), (n.z = e[r + 2]);
        }
        function u(e, t, n, r) {
          r < 0 && 1 === e.x && (a[t] = e.x - 1),
            0 === n.x && 0 === n.z && (a[t] = r / 2 / Math.PI + 0.5);
        }
        function l(e) {
          return Math.atan2(e.z, -e.x);
        }
        !(function (e) {
          for (
            var n = new $n(), r = new $n(), i = new $n(), a = 0;
            a < t.length;
            a += 3
          )
            c(t[a + 0], n), c(t[a + 1], r), c(t[a + 2], i), o(n, r, i, e);
        })((r = r || 0)),
          (function (e) {
            for (var t = new $n(), n = 0; n < i.length; n += 3)
              (t.x = i[n + 0]),
                (t.y = i[n + 1]),
                (t.z = i[n + 2]),
                t.normalize().multiplyScalar(e),
                (i[n + 0] = t.x),
                (i[n + 1] = t.y),
                (i[n + 2] = t.z);
          })(n),
          (function () {
            for (var e, t = new $n(), n = 0; n < i.length; n += 3) {
              (t.x = i[n + 0]), (t.y = i[n + 1]), (t.z = i[n + 2]);
              var r = l(t) / 2 / Math.PI + 0.5,
                o =
                  ((e = t),
                  Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI +
                    0.5);
              a.push(r, 1 - o);
            }
            (function () {
              for (
                var e = new $n(),
                  t = new $n(),
                  n = new $n(),
                  r = new $n(),
                  o = new Hn(),
                  s = new Hn(),
                  c = new Hn(),
                  h = 0,
                  d = 0;
                h < i.length;
                h += 9, d += 6
              ) {
                e.set(i[h + 0], i[h + 1], i[h + 2]),
                  t.set(i[h + 3], i[h + 4], i[h + 5]),
                  n.set(i[h + 6], i[h + 7], i[h + 8]),
                  o.set(a[d + 0], a[d + 1]),
                  s.set(a[d + 2], a[d + 3]),
                  c.set(a[d + 4], a[d + 5]),
                  r.copy(e).add(t).add(n).divideScalar(3);
                var p = l(r);
                u(o, d + 0, e, p), u(s, d + 2, t, p), u(c, d + 4, n, p);
              }
            })(),
              (function () {
                for (var e = 0; e < a.length; e += 6) {
                  var t = a[e + 0],
                    n = a[e + 2],
                    r = a[e + 4],
                    i = Math.max(t, n, r),
                    o = Math.min(t, n, r);
                  i > 0.9 &&
                    o < 0.1 &&
                    (t < 0.2 && (a[e + 0] += 1),
                    n < 0.2 && (a[e + 2] += 1),
                    r < 0.2 && (a[e + 4] += 1));
                }
              })();
          })(),
          this.setAttribute("position", new Ii(i, 3)),
          this.setAttribute("normal", new Ii(i.slice(), 3)),
          this.setAttribute("uv", new Ii(a, 2)),
          0 === r ? this.computeVertexNormals() : this.normalizeNormals();
      }
      function Qc(e, t) {
        va.call(this),
          (this.type = "TetrahedronGeometry"),
          (this.parameters = { radius: e, detail: t }),
          this.fromBufferGeometry(new $c(e, t)),
          this.mergeVertices();
      }
      function $c(e, t) {
        Kc.call(
          this,
          [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
          [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
          e,
          t
        ),
          (this.type = "TetrahedronBufferGeometry"),
          (this.parameters = { radius: e, detail: t });
      }
      function eu(e, t) {
        va.call(this),
          (this.type = "OctahedronGeometry"),
          (this.parameters = { radius: e, detail: t }),
          this.fromBufferGeometry(new tu(e, t)),
          this.mergeVertices();
      }
      function tu(e, t) {
        Kc.call(
          this,
          [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
          [
            0,
            2,
            4,
            0,
            4,
            3,
            0,
            3,
            5,
            0,
            5,
            2,
            1,
            2,
            5,
            1,
            5,
            3,
            1,
            3,
            4,
            1,
            4,
            2,
          ],
          e,
          t
        ),
          (this.type = "OctahedronBufferGeometry"),
          (this.parameters = { radius: e, detail: t });
      }
      function nu(e, t) {
        va.call(this),
          (this.type = "IcosahedronGeometry"),
          (this.parameters = { radius: e, detail: t }),
          this.fromBufferGeometry(new ru(e, t)),
          this.mergeVertices();
      }
      function ru(e, t) {
        var n = (1 + Math.sqrt(5)) / 2;
        Kc.call(
          this,
          [
            -1,
            n,
            0,
            1,
            n,
            0,
            -1,
            -n,
            0,
            1,
            -n,
            0,
            0,
            -1,
            n,
            0,
            1,
            n,
            0,
            -1,
            -n,
            0,
            1,
            -n,
            n,
            0,
            -1,
            n,
            0,
            1,
            -n,
            0,
            -1,
            -n,
            0,
            1,
          ],
          [
            0,
            11,
            5,
            0,
            5,
            1,
            0,
            1,
            7,
            0,
            7,
            10,
            0,
            10,
            11,
            1,
            5,
            9,
            5,
            11,
            4,
            11,
            10,
            2,
            10,
            7,
            6,
            7,
            1,
            8,
            3,
            9,
            4,
            3,
            4,
            2,
            3,
            2,
            6,
            3,
            6,
            8,
            3,
            8,
            9,
            4,
            9,
            5,
            2,
            4,
            11,
            6,
            2,
            10,
            8,
            6,
            7,
            9,
            8,
            1,
          ],
          e,
          t
        ),
          (this.type = "IcosahedronBufferGeometry"),
          (this.parameters = { radius: e, detail: t });
      }
      function iu(e, t) {
        va.call(this),
          (this.type = "DodecahedronGeometry"),
          (this.parameters = { radius: e, detail: t }),
          this.fromBufferGeometry(new au(e, t)),
          this.mergeVertices();
      }
      function au(e, t) {
        var n = (1 + Math.sqrt(5)) / 2,
          r = 1 / n;
        Kc.call(
          this,
          [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -r,
            -n,
            0,
            -r,
            n,
            0,
            r,
            -n,
            0,
            r,
            n,
            -r,
            -n,
            0,
            -r,
            n,
            0,
            r,
            -n,
            0,
            r,
            n,
            0,
            -n,
            0,
            -r,
            n,
            0,
            -r,
            -n,
            0,
            r,
            n,
            0,
            r,
          ],
          [
            3,
            11,
            7,
            3,
            7,
            15,
            3,
            15,
            13,
            7,
            19,
            17,
            7,
            17,
            6,
            7,
            6,
            15,
            17,
            4,
            8,
            17,
            8,
            10,
            17,
            10,
            6,
            8,
            0,
            16,
            8,
            16,
            2,
            8,
            2,
            10,
            0,
            12,
            1,
            0,
            1,
            18,
            0,
            18,
            16,
            6,
            10,
            2,
            6,
            2,
            13,
            6,
            13,
            15,
            2,
            16,
            18,
            2,
            18,
            3,
            2,
            3,
            13,
            18,
            1,
            9,
            18,
            9,
            11,
            18,
            11,
            3,
            4,
            14,
            12,
            4,
            12,
            0,
            4,
            0,
            8,
            11,
            9,
            5,
            11,
            5,
            19,
            11,
            19,
            7,
            19,
            5,
            14,
            19,
            14,
            4,
            19,
            4,
            17,
            1,
            12,
            14,
            1,
            14,
            5,
            1,
            5,
            9,
          ],
          e,
          t
        ),
          (this.type = "DodecahedronBufferGeometry"),
          (this.parameters = { radius: e, detail: t });
      }
      function ou(e, t, n, r, i, a) {
        va.call(this),
          (this.type = "TubeGeometry"),
          (this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: r,
            closed: i,
          }),
          void 0 !== a &&
            console.warn("THREE.TubeGeometry: taper has been removed.");
        var o = new su(e, t, n, r, i);
        (this.tangents = o.tangents),
          (this.normals = o.normals),
          (this.binormals = o.binormals),
          this.fromBufferGeometry(o),
          this.mergeVertices();
      }
      function su(e, t, n, r, i) {
        Wi.call(this),
          (this.type = "TubeBufferGeometry"),
          (this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: r,
            closed: i,
          }),
          (n = n || 1),
          (r = r || 8);
        var a = e.computeFrenetFrames((t = t || 64), (i = i || !1));
        (this.tangents = a.tangents),
          (this.normals = a.normals),
          (this.binormals = a.binormals);
        var o = new $n(),
          s = new $n(),
          c = new Hn(),
          u = new $n(),
          l = [],
          h = [],
          d = [],
          p = [];
        function f(i) {
          u = e.getPointAt(i / t, u);
          for (var c = a.normals[i], d = a.binormals[i], p = 0; p <= r; p++) {
            var f = (p / r) * Math.PI * 2,
              m = Math.sin(f),
              v = -Math.cos(f);
            (s.x = v * c.x + m * d.x),
              (s.y = v * c.y + m * d.y),
              (s.z = v * c.z + m * d.z),
              s.normalize(),
              h.push(s.x, s.y, s.z),
              (o.x = u.x + n * s.x),
              (o.y = u.y + n * s.y),
              (o.z = u.z + n * s.z),
              l.push(o.x, o.y, o.z);
          }
        }
        !(function () {
          for (var e = 0; e < t; e++) f(e);
          f(!1 === i ? t : 0),
            (function () {
              for (var e = 0; e <= t; e++)
                for (var n = 0; n <= r; n++)
                  (c.x = e / t), (c.y = n / r), d.push(c.x, c.y);
            })(),
            (function () {
              for (var e = 1; e <= t; e++)
                for (var n = 1; n <= r; n++) {
                  var i = (r + 1) * e + (n - 1),
                    a = (r + 1) * e + n,
                    o = (r + 1) * (e - 1) + n;
                  p.push((r + 1) * (e - 1) + (n - 1), i, o), p.push(i, a, o);
                }
            })();
        })(),
          this.setIndex(p),
          this.setAttribute("position", new Ii(l, 3)),
          this.setAttribute("normal", new Ii(h, 3)),
          this.setAttribute("uv", new Ii(d, 2));
      }
      function cu(e, t, n, r, i, a, o) {
        va.call(this),
          (this.type = "TorusKnotGeometry"),
          (this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: a,
          }),
          void 0 !== o &&
            console.warn(
              "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
            ),
          this.fromBufferGeometry(new uu(e, t, n, r, i, a)),
          this.mergeVertices();
      }
      function uu(e, t, n, r, i, a) {
        Wi.call(this),
          (this.type = "TorusKnotBufferGeometry"),
          (this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: a,
          }),
          (e = e || 1),
          (t = t || 0.4),
          (n = Math.floor(n) || 64),
          (r = Math.floor(r) || 8),
          (i = i || 2),
          (a = a || 3);
        for (
          var o = [],
            s = [],
            c = [],
            u = [],
            l = new $n(),
            h = new $n(),
            d = new $n(),
            p = new $n(),
            f = new $n(),
            m = new $n(),
            v = new $n(),
            g = 0;
          g <= n;
          ++g
        ) {
          var y = (g / n) * i * Math.PI * 2;
          L(y, i, a, e, d),
            L(y + 0.01, i, a, e, p),
            m.subVectors(p, d),
            v.addVectors(p, d),
            f.crossVectors(m, v),
            v.crossVectors(f, m),
            f.normalize(),
            v.normalize();
          for (var x = 0; x <= r; ++x) {
            var b = (x / r) * Math.PI * 2,
              _ = -t * Math.cos(b),
              w = t * Math.sin(b);
            (l.x = d.x + (_ * v.x + w * f.x)),
              (l.y = d.y + (_ * v.y + w * f.y)),
              (l.z = d.z + (_ * v.z + w * f.z)),
              s.push(l.x, l.y, l.z),
              h.subVectors(l, d).normalize(),
              c.push(h.x, h.y, h.z),
              u.push(g / n),
              u.push(x / r);
          }
        }
        for (var M = 1; M <= n; M++)
          for (var S = 1; S <= r; S++) {
            var T = (r + 1) * M + (S - 1),
              E = (r + 1) * M + S,
              A = (r + 1) * (M - 1) + S;
            o.push((r + 1) * (M - 1) + (S - 1), T, A), o.push(T, E, A);
          }
        function L(e, t, n, r, i) {
          var a = Math.cos(e),
            o = Math.sin(e),
            s = (n / t) * e,
            c = Math.cos(s);
          (i.x = r * (2 + c) * 0.5 * a),
            (i.y = r * (2 + c) * o * 0.5),
            (i.z = r * Math.sin(s) * 0.5);
        }
        this.setIndex(o),
          this.setAttribute("position", new Ii(s, 3)),
          this.setAttribute("normal", new Ii(c, 3)),
          this.setAttribute("uv", new Ii(u, 2));
      }
      function lu(e, t, n, r, i) {
        va.call(this),
          (this.type = "TorusGeometry"),
          (this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: r,
            arc: i,
          }),
          this.fromBufferGeometry(new hu(e, t, n, r, i)),
          this.mergeVertices();
      }
      function hu(e, t, n, r, i) {
        Wi.call(this),
          (this.type = "TorusBufferGeometry"),
          (this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: r,
            arc: i,
          }),
          (e = e || 1),
          (t = t || 0.4),
          (n = Math.floor(n) || 8),
          (r = Math.floor(r) || 6),
          (i = i || 2 * Math.PI);
        for (
          var a = [],
            o = [],
            s = [],
            c = [],
            u = new $n(),
            l = new $n(),
            h = new $n(),
            d = 0;
          d <= n;
          d++
        )
          for (var p = 0; p <= r; p++) {
            var f = (p / r) * i,
              m = (d / n) * Math.PI * 2;
            (l.x = (e + t * Math.cos(m)) * Math.cos(f)),
              (l.y = (e + t * Math.cos(m)) * Math.sin(f)),
              (l.z = t * Math.sin(m)),
              o.push(l.x, l.y, l.z),
              (u.x = e * Math.cos(f)),
              (u.y = e * Math.sin(f)),
              h.subVectors(l, u).normalize(),
              s.push(h.x, h.y, h.z),
              c.push(p / r),
              c.push(d / n);
          }
        for (var v = 1; v <= n; v++)
          for (var g = 1; g <= r; g++) {
            var y = (r + 1) * (v - 1) + g - 1,
              x = (r + 1) * (v - 1) + g,
              b = (r + 1) * v + g;
            a.push((r + 1) * v + g - 1, y, b), a.push(y, x, b);
          }
        this.setIndex(a),
          this.setAttribute("position", new Ii(o, 3)),
          this.setAttribute("normal", new Ii(s, 3)),
          this.setAttribute("uv", new Ii(c, 2));
      }
      function du(e, t, n, r, i) {
        var a, o;
        if (
          i ===
          (function (e, t, n, r) {
            for (var i = 0, a = t, o = n - r; a < n; a += r)
              (i += (e[o] - e[a]) * (e[a + 1] + e[o + 1])), (o = a);
            return i;
          })(e, t, n, r) >
            0
        )
          for (a = t; a < n; a += r) o = Du(a, e[a], e[a + 1], o);
        else for (a = n - r; a >= t; a -= r) o = Du(a, e[a], e[a + 1], o);
        return o && Au(o, o.next) && (Iu(o), (o = o.next)), o;
      }
      function pu(e, t) {
        if (!e) return e;
        t || (t = e);
        var n,
          r = e;
        do {
          if (
            ((n = !1),
            r.steiner || (!Au(r, r.next) && 0 !== Eu(r.prev, r, r.next)))
          )
            r = r.next;
          else {
            if ((Iu(r), (r = t = r.prev) === r.next)) break;
            n = !0;
          }
        } while (n || r !== t);
        return t;
      }
      function fu(e, t, n, r, i, a, o) {
        if (e) {
          !o &&
            a &&
            (function (e, t, n, r) {
              var i = e;
              do {
                null === i.z && (i.z = wu(i.x, i.y, t, n, r)),
                  (i.prevZ = i.prev),
                  (i.nextZ = i.next),
                  (i = i.next);
              } while (i !== e);
              (i.prevZ.nextZ = null),
                (i.prevZ = null),
                (function (e) {
                  var t,
                    n,
                    r,
                    i,
                    a,
                    o,
                    s,
                    c,
                    u = 1;
                  do {
                    for (n = e, e = null, a = null, o = 0; n; ) {
                      for (
                        o++, r = n, s = 0, t = 0;
                        t < u && (s++, (r = r.nextZ));
                        t++
                      );
                      for (c = u; s > 0 || (c > 0 && r); )
                        0 !== s && (0 === c || !r || n.z <= r.z)
                          ? ((i = n), (n = n.nextZ), s--)
                          : ((i = r), (r = r.nextZ), c--),
                          a ? (a.nextZ = i) : (e = i),
                          (i.prevZ = a),
                          (a = i);
                      n = r;
                    }
                    (a.nextZ = null), (u *= 2);
                  } while (o > 1);
                })(i);
            })(e, r, i, a);
          for (var s, c, u = e; e.prev !== e.next; )
            if (((s = e.prev), (c = e.next), a ? vu(e, r, i, a) : mu(e)))
              t.push(s.i / n),
                t.push(e.i / n),
                t.push(c.i / n),
                Iu(e),
                (e = c.next),
                (u = c.next);
            else if ((e = c) === u) {
              o
                ? 1 === o
                  ? fu((e = gu(pu(e), t, n)), t, n, r, i, a, 2)
                  : 2 === o && yu(e, t, n, r, i, a)
                : fu(pu(e), t, n, r, i, a, 1);
              break;
            }
        }
      }
      function mu(e) {
        var t = e.prev,
          n = e,
          r = e.next;
        if (Eu(t, n, r) >= 0) return !1;
        for (var i = e.next.next; i !== e.prev; ) {
          if (
            Su(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) &&
            Eu(i.prev, i, i.next) >= 0
          )
            return !1;
          i = i.next;
        }
        return !0;
      }
      function vu(e, t, n, r) {
        var i = e.prev,
          a = e,
          o = e.next;
        if (Eu(i, a, o) >= 0) return !1;
        for (
          var s = i.x > a.x ? (i.x > o.x ? i.x : o.x) : a.x > o.x ? a.x : o.x,
            c = i.y > a.y ? (i.y > o.y ? i.y : o.y) : a.y > o.y ? a.y : o.y,
            u = wu(
              i.x < a.x ? (i.x < o.x ? i.x : o.x) : a.x < o.x ? a.x : o.x,
              i.y < a.y ? (i.y < o.y ? i.y : o.y) : a.y < o.y ? a.y : o.y,
              t,
              n,
              r
            ),
            l = wu(s, c, t, n, r),
            h = e.prevZ,
            d = e.nextZ;
          h && h.z >= u && d && d.z <= l;

        ) {
          if (
            h !== e.prev &&
            h !== e.next &&
            Su(i.x, i.y, a.x, a.y, o.x, o.y, h.x, h.y) &&
            Eu(h.prev, h, h.next) >= 0
          )
            return !1;
          if (
            ((h = h.prevZ),
            d !== e.prev &&
              d !== e.next &&
              Su(i.x, i.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
              Eu(d.prev, d, d.next) >= 0)
          )
            return !1;
          d = d.nextZ;
        }
        for (; h && h.z >= u; ) {
          if (
            h !== e.prev &&
            h !== e.next &&
            Su(i.x, i.y, a.x, a.y, o.x, o.y, h.x, h.y) &&
            Eu(h.prev, h, h.next) >= 0
          )
            return !1;
          h = h.prevZ;
        }
        for (; d && d.z <= l; ) {
          if (
            d !== e.prev &&
            d !== e.next &&
            Su(i.x, i.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
            Eu(d.prev, d, d.next) >= 0
          )
            return !1;
          d = d.nextZ;
        }
        return !0;
      }
      function gu(e, t, n) {
        var r = e;
        do {
          var i = r.prev,
            a = r.next.next;
          !Au(i, a) &&
            Lu(i, r, r.next, a) &&
            Pu(i, a) &&
            Pu(a, i) &&
            (t.push(i.i / n),
            t.push(r.i / n),
            t.push(a.i / n),
            Iu(r),
            Iu(r.next),
            (r = e = a)),
            (r = r.next);
        } while (r !== e);
        return pu(r);
      }
      function yu(e, t, n, r, i, a) {
        var o = e;
        do {
          for (var s = o.next.next; s !== o.prev; ) {
            if (o.i !== s.i && Tu(o, s)) {
              var c = Ou(o, s);
              return (
                (o = pu(o, o.next)),
                (c = pu(c, c.next)),
                fu(o, t, n, r, i, a),
                void fu(c, t, n, r, i, a)
              );
            }
            s = s.next;
          }
          o = o.next;
        } while (o !== e);
      }
      function xu(e, t) {
        return e.x - t.x;
      }
      function bu(e, t) {
        if (
          (t = (function (e, t) {
            var n,
              r = t,
              i = e.x,
              a = e.y,
              o = -1 / 0;
            do {
              if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
                var s = r.x + ((a - r.y) * (r.next.x - r.x)) / (r.next.y - r.y);
                if (s <= i && s > o) {
                  if (((o = s), s === i)) {
                    if (a === r.y) return r;
                    if (a === r.next.y) return r.next;
                  }
                  n = r.x < r.next.x ? r : r.next;
                }
              }
              r = r.next;
            } while (r !== t);
            if (!n) return null;
            if (i === o) return n;
            var c,
              u = n,
              l = n.x,
              h = n.y,
              d = 1 / 0;
            r = n;
            do {
              i >= r.x &&
                r.x >= l &&
                i !== r.x &&
                Su(a < h ? i : o, a, l, h, a < h ? o : i, a, r.x, r.y) &&
                ((c = Math.abs(a - r.y) / (i - r.x)),
                Pu(r, e) &&
                  (c < d ||
                    (c === d && (r.x > n.x || (r.x === n.x && _u(n, r))))) &&
                  ((n = r), (d = c))),
                (r = r.next);
            } while (r !== u);
            return n;
          })(e, t))
        ) {
          var n = Ou(t, e);
          pu(t, t.next), pu(n, n.next);
        }
      }
      function _u(e, t) {
        return Eu(e.prev, e, t.prev) < 0 && Eu(t.next, e, e.next) < 0;
      }
      function wu(e, t, n, r, i) {
        return (
          (e =
            1431655765 &
            ((e =
              858993459 &
              ((e =
                252645135 &
                ((e = 16711935 & ((e = 32767 * (e - n) * i) | (e << 8))) |
                  (e << 4))) |
                (e << 2))) |
              (e << 1))) |
          ((t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 &
                ((t = 16711935 & ((t = 32767 * (t - r) * i) | (t << 8))) |
                  (t << 4))) |
                (t << 2))) |
              (t << 1))) <<
            1)
        );
      }
      function Mu(e) {
        var t = e,
          n = e;
        do {
          (t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next);
        } while (t !== e);
        return n;
      }
      function Su(e, t, n, r, i, a, o, s) {
        return (
          (i - o) * (t - s) - (e - o) * (a - s) >= 0 &&
          (e - o) * (r - s) - (n - o) * (t - s) >= 0 &&
          (n - o) * (a - s) - (i - o) * (r - s) >= 0
        );
      }
      function Tu(e, t) {
        return (
          e.next.i !== t.i &&
          e.prev.i !== t.i &&
          !(function (e, t) {
            var n = e;
            do {
              if (
                n.i !== e.i &&
                n.next.i !== e.i &&
                n.i !== t.i &&
                n.next.i !== t.i &&
                Lu(n, n.next, e, t)
              )
                return !0;
              n = n.next;
            } while (n !== e);
            return !1;
          })(e, t) &&
          ((Pu(e, t) &&
            Pu(t, e) &&
            (function (e, t) {
              var n = e,
                r = !1,
                i = (e.x + t.x) / 2,
                a = (e.y + t.y) / 2;
              do {
                n.y > a != n.next.y > a &&
                  n.next.y !== n.y &&
                  i < ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) + n.x &&
                  (r = !r),
                  (n = n.next);
              } while (n !== e);
              return r;
            })(e, t) &&
            (Eu(e.prev, e, t.prev) || Eu(e, t.prev, t))) ||
            (Au(e, t) &&
              Eu(e.prev, e, e.next) > 0 &&
              Eu(t.prev, t, t.next) > 0))
        );
      }
      function Eu(e, t, n) {
        return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
      }
      function Au(e, t) {
        return e.x === t.x && e.y === t.y;
      }
      function Lu(e, t, n, r) {
        var i = Ru(Eu(e, t, n)),
          a = Ru(Eu(e, t, r)),
          o = Ru(Eu(n, r, e)),
          s = Ru(Eu(n, r, t));
        return (
          (i !== a && o !== s) ||
          !(0 !== i || !Cu(e, n, t)) ||
          !(0 !== a || !Cu(e, r, t)) ||
          !(0 !== o || !Cu(n, e, r)) ||
          !(0 !== s || !Cu(n, t, r))
        );
      }
      function Cu(e, t, n) {
        return (
          t.x <= Math.max(e.x, n.x) &&
          t.x >= Math.min(e.x, n.x) &&
          t.y <= Math.max(e.y, n.y) &&
          t.y >= Math.min(e.y, n.y)
        );
      }
      function Ru(e) {
        return e > 0 ? 1 : e < 0 ? -1 : 0;
      }
      function Pu(e, t) {
        return Eu(e.prev, e, e.next) < 0
          ? Eu(e, t, e.next) >= 0 && Eu(e, e.prev, t) >= 0
          : Eu(e, t, e.prev) < 0 || Eu(e, e.next, t) < 0;
      }
      function Ou(e, t) {
        var n = new Nu(e.i, e.x, e.y),
          r = new Nu(t.i, t.x, t.y),
          i = e.next,
          a = t.prev;
        return (
          (e.next = t),
          (t.prev = e),
          (n.next = i),
          (i.prev = n),
          (r.next = n),
          (n.prev = r),
          (a.next = r),
          (r.prev = a),
          r
        );
      }
      function Du(e, t, n, r) {
        var i = new Nu(e, t, n);
        return (
          r
            ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
            : ((i.prev = i), (i.next = i)),
          i
        );
      }
      function Iu(e) {
        (e.next.prev = e.prev),
          (e.prev.next = e.next),
          e.prevZ && (e.prevZ.nextZ = e.nextZ),
          e.nextZ && (e.nextZ.prevZ = e.prevZ);
      }
      function Nu(e, t, n) {
        (this.i = e),
          (this.x = t),
          (this.y = n),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      (kc.prototype = Object.assign(Object.create(Tr.prototype), {
        constructor: kc,
        isPoints: !0,
        copy: function (e) {
          return (
            Tr.prototype.copy.call(this, e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        },
        raycast: function (e, t) {
          var n = this.geometry,
            r = this.matrixWorld,
            i = e.params.Points.threshold;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            Uc.copy(n.boundingSphere),
            Uc.applyMatrix4(r),
            (Uc.radius += i),
            !1 !== e.ray.intersectsSphere(Uc))
          ) {
            zc.getInverse(r), Fc.copy(e.ray).applyMatrix4(zc);
            var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              o = a * a;
            if (n.isBufferGeometry) {
              var s = n.index,
                c = n.attributes.position.array;
              if (null !== s)
                for (var u = s.array, l = 0, h = u.length; l < h; l++) {
                  var d = u[l];
                  Gc.fromArray(c, 3 * d), Hc(Gc, d, o, r, e, t, this);
                }
              else
                for (var p = 0, f = c.length / 3; p < f; p++)
                  Gc.fromArray(c, 3 * p), Hc(Gc, p, o, r, e, t, this);
            } else
              for (var m = n.vertices, v = 0, g = m.length; v < g; v++)
                Hc(m[v], v, o, r, e, t, this);
          }
        },
        updateMorphTargets: function () {
          var e = this.geometry;
          if (e.isBufferGeometry) {
            var t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              var r = t[n[0]];
              if (void 0 !== r) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (var i = 0, a = r.length; i < a; i++) {
                  var o = r[i].name || String(i);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[o] = i);
                }
              }
            }
          } else {
            var s = e.morphTargets;
            void 0 !== s &&
              s.length > 0 &&
              console.error(
                "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        },
      })),
        (jc.prototype = Object.assign(Object.create(qn.prototype), {
          constructor: jc,
          isVideoTexture: !0,
          update: function () {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
          },
        })),
        ((Vc.prototype = Object.create(qn.prototype)).constructor = Vc),
        (Vc.prototype.isCompressedTexture = !0),
        ((Wc.prototype = Object.create(qn.prototype)).constructor = Wc),
        (Wc.prototype.isCanvasTexture = !0),
        ((qc.prototype = Object.create(qn.prototype)).constructor = qc),
        (qc.prototype.isDepthTexture = !0),
        ((Xc.prototype = Object.create(Wi.prototype)).constructor = Xc),
        ((Yc.prototype = Object.create(va.prototype)).constructor = Yc),
        ((Zc.prototype = Object.create(Wi.prototype)).constructor = Zc),
        ((Jc.prototype = Object.create(va.prototype)).constructor = Jc),
        ((Kc.prototype = Object.create(Wi.prototype)).constructor = Kc),
        ((Qc.prototype = Object.create(va.prototype)).constructor = Qc),
        (($c.prototype = Object.create(Kc.prototype)).constructor = $c),
        ((eu.prototype = Object.create(va.prototype)).constructor = eu),
        ((tu.prototype = Object.create(Kc.prototype)).constructor = tu),
        ((nu.prototype = Object.create(va.prototype)).constructor = nu),
        ((ru.prototype = Object.create(Kc.prototype)).constructor = ru),
        ((iu.prototype = Object.create(va.prototype)).constructor = iu),
        ((au.prototype = Object.create(Kc.prototype)).constructor = au),
        ((ou.prototype = Object.create(va.prototype)).constructor = ou),
        ((su.prototype = Object.create(Wi.prototype)).constructor = su),
        (su.prototype.toJSON = function () {
          var e = Wi.prototype.toJSON.call(this);
          return (e.path = this.parameters.path.toJSON()), e;
        }),
        ((cu.prototype = Object.create(va.prototype)).constructor = cu),
        ((uu.prototype = Object.create(Wi.prototype)).constructor = uu),
        ((lu.prototype = Object.create(va.prototype)).constructor = lu),
        ((hu.prototype = Object.create(Wi.prototype)).constructor = hu);
      var Bu = {
        area: function (e) {
          for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++)
            n += e[r].x * e[i].y - e[i].x * e[r].y;
          return 0.5 * n;
        },
        isClockWise: function (e) {
          return Bu.area(e) < 0;
        },
        triangulateShape: function (e, t) {
          var n = [],
            r = [],
            i = [];
          zu(e), Fu(n, e);
          var a = e.length;
          t.forEach(zu);
          for (var o = 0; o < t.length; o++)
            r.push(a), (a += t[o].length), Fu(n, t[o]);
          for (
            var s = (function (e, t, n) {
                n = n || 2;
                var r,
                  i,
                  a,
                  o,
                  s,
                  c,
                  u,
                  l = t && t.length,
                  h = l ? t[0] * n : e.length,
                  d = du(e, 0, h, n, !0),
                  p = [];
                if (!d || d.next === d.prev) return p;
                if (
                  (l &&
                    (d = (function (e, t, n, r) {
                      var i,
                        a,
                        o,
                        s = [];
                      for (i = 0, a = t.length; i < a; i++)
                        (o = du(
                          e,
                          t[i] * r,
                          i < a - 1 ? t[i + 1] * r : e.length,
                          r,
                          !1
                        )) === o.next && (o.steiner = !0),
                          s.push(Mu(o));
                      for (s.sort(xu), i = 0; i < s.length; i++)
                        bu(s[i], n), (n = pu(n, n.next));
                      return n;
                    })(e, t, d, n)),
                  e.length > 80 * n)
                ) {
                  (r = a = e[0]), (i = o = e[1]);
                  for (var f = n; f < h; f += n)
                    (s = e[f]) < r && (r = s),
                      (c = e[f + 1]) < i && (i = c),
                      s > a && (a = s),
                      c > o && (o = c);
                  u = 0 !== (u = Math.max(a - r, o - i)) ? 1 / u : 0;
                }
                return fu(d, p, n, r, i, u), p;
              })(n, r),
              c = 0;
            c < s.length;
            c += 3
          )
            i.push(s.slice(c, c + 3));
          return i;
        },
      };
      function zu(e) {
        var t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop();
      }
      function Fu(e, t) {
        for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
      }
      function Uu(e, t) {
        va.call(this),
          (this.type = "ExtrudeGeometry"),
          (this.parameters = { shapes: e, options: t }),
          this.fromBufferGeometry(new Gu(e, t)),
          this.mergeVertices();
      }
      function Gu(e, t) {
        Wi.call(this),
          (this.type = "ExtrudeBufferGeometry"),
          (this.parameters = { shapes: e, options: t }),
          (e = Array.isArray(e) ? e : [e]);
        for (var n = this, r = [], i = [], a = 0, o = e.length; a < o; a++)
          s(e[a]);
        function s(e) {
          var a = [],
            o = void 0 !== t.curveSegments ? t.curveSegments : 12,
            s = void 0 !== t.steps ? t.steps : 1,
            c = void 0 !== t.depth ? t.depth : 100,
            u = void 0 === t.bevelEnabled || t.bevelEnabled,
            l = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
            h = void 0 !== t.bevelSize ? t.bevelSize : l - 2,
            d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
            p = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
            f = t.extrudePath,
            m = void 0 !== t.UVGenerator ? t.UVGenerator : ku;
          void 0 !== t.amount &&
            (console.warn(
              "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
            ),
            (c = t.amount));
          var v,
            g,
            y,
            x,
            b,
            _ = !1;
          f &&
            ((v = f.getSpacedPoints(s)),
            (_ = !0),
            (u = !1),
            (g = f.computeFrenetFrames(s, !1)),
            (y = new $n()),
            (x = new $n()),
            (b = new $n())),
            u || ((p = 0), (l = 0), (h = 0), (d = 0));
          var w = e.extractPoints(o),
            M = w.shape,
            S = w.holes;
          if (!Bu.isClockWise(M)) {
            M = M.reverse();
            for (var T = 0, E = S.length; T < E; T++) {
              var A = S[T];
              Bu.isClockWise(A) && (S[T] = A.reverse());
            }
          }
          for (
            var L = Bu.triangulateShape(M, S), C = M, R = 0, P = S.length;
            R < P;
            R++
          )
            M = M.concat(S[R]);
          function O(e, t, n) {
            return (
              t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
              t.clone().multiplyScalar(n).add(e)
            );
          }
          var D = M.length,
            I = L.length;
          function N(e, t, n) {
            var r,
              i,
              a,
              o = e.x - t.x,
              s = e.y - t.y,
              c = n.x - e.x,
              u = n.y - e.y,
              l = o * o + s * s;
            if (Math.abs(o * u - s * c) > Number.EPSILON) {
              var h = Math.sqrt(l),
                d = Math.sqrt(c * c + u * u),
                p = t.x - s / h,
                f = t.y + o / h,
                m =
                  ((n.x - u / d - p) * u - (n.y + c / d - f) * c) /
                  (o * u - s * c),
                v = (r = p + o * m - e.x) * r + (i = f + s * m - e.y) * i;
              if (v <= 2) return new Hn(r, i);
              a = Math.sqrt(v / 2);
            } else {
              var g = !1;
              o > Number.EPSILON
                ? c > Number.EPSILON && (g = !0)
                : o < -Number.EPSILON
                ? c < -Number.EPSILON && (g = !0)
                : Math.sign(s) === Math.sign(u) && (g = !0),
                g
                  ? ((r = -s), (i = o), (a = Math.sqrt(l)))
                  : ((r = o), (i = s), (a = Math.sqrt(l / 2)));
            }
            return new Hn(r / a, i / a);
          }
          for (
            var B = [], z = 0, F = C.length, U = F - 1, G = z + 1;
            z < F;
            z++, U++, G++
          )
            U === F && (U = 0),
              G === F && (G = 0),
              (B[z] = N(C[z], C[U], C[G]));
          for (var k, H = [], j = B.concat(), V = 0, W = S.length; V < W; V++) {
            var q = S[V];
            k = [];
            for (
              var X = 0, Y = q.length, Z = Y - 1, J = X + 1;
              X < Y;
              X++, Z++, J++
            )
              Z === Y && (Z = 0),
                J === Y && (J = 0),
                (k[X] = N(q[X], q[Z], q[J]));
            H.push(k), (j = j.concat(k));
          }
          for (var K = 0; K < p; K++) {
            for (
              var Q = K / p,
                $ = l * Math.cos((Q * Math.PI) / 2),
                ee = h * Math.sin((Q * Math.PI) / 2) + d,
                te = 0,
                ne = C.length;
              te < ne;
              te++
            ) {
              var re = O(C[te], B[te], ee);
              Re(re.x, re.y, -$);
            }
            for (var ie = 0, ae = S.length; ie < ae; ie++) {
              var oe = S[ie];
              k = H[ie];
              for (var se = 0, ce = oe.length; se < ce; se++) {
                var ue = O(oe[se], k[se], ee);
                Re(ue.x, ue.y, -$);
              }
            }
          }
          for (var le = h + d, he = 0; he < D; he++) {
            var de = u ? O(M[he], j[he], le) : M[he];
            _
              ? (x.copy(g.normals[0]).multiplyScalar(de.x),
                y.copy(g.binormals[0]).multiplyScalar(de.y),
                b.copy(v[0]).add(x).add(y),
                Re(b.x, b.y, b.z))
              : Re(de.x, de.y, 0);
          }
          for (var pe = 1; pe <= s; pe++)
            for (var fe = 0; fe < D; fe++) {
              var me = u ? O(M[fe], j[fe], le) : M[fe];
              _
                ? (x.copy(g.normals[pe]).multiplyScalar(me.x),
                  y.copy(g.binormals[pe]).multiplyScalar(me.y),
                  b.copy(v[pe]).add(x).add(y),
                  Re(b.x, b.y, b.z))
                : Re(me.x, me.y, (c / s) * pe);
            }
          for (var ve = p - 1; ve >= 0; ve--) {
            for (
              var ge = ve / p,
                ye = l * Math.cos((ge * Math.PI) / 2),
                xe = h * Math.sin((ge * Math.PI) / 2) + d,
                be = 0,
                _e = C.length;
              be < _e;
              be++
            ) {
              var we = O(C[be], B[be], xe);
              Re(we.x, we.y, c + ye);
            }
            for (var Me = 0, Se = S.length; Me < Se; Me++) {
              var Te = S[Me];
              k = H[Me];
              for (var Ee = 0, Ae = Te.length; Ee < Ae; Ee++) {
                var Le = O(Te[Ee], k[Ee], xe);
                _
                  ? Re(Le.x, Le.y + v[s - 1].y, v[s - 1].x + ye)
                  : Re(Le.x, Le.y, c + ye);
              }
            }
          }
          function Ce(e, t) {
            for (var n = e.length; --n >= 0; ) {
              var r = n,
                i = n - 1;
              i < 0 && (i = e.length - 1);
              for (var a = 0, o = s + 2 * p; a < o; a++) {
                var c = D * a,
                  u = D * (a + 1);
                Oe(t + r + c, t + i + c, t + i + u, t + r + u);
              }
            }
          }
          function Re(e, t, n) {
            a.push(e), a.push(t), a.push(n);
          }
          function Pe(e, t, i) {
            De(e), De(t), De(i);
            var a = r.length / 3,
              o = m.generateTopUV(n, r, a - 3, a - 2, a - 1);
            Ie(o[0]), Ie(o[1]), Ie(o[2]);
          }
          function Oe(e, t, i, a) {
            De(e), De(t), De(a), De(t), De(i), De(a);
            var o = r.length / 3,
              s = m.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1);
            Ie(s[0]), Ie(s[1]), Ie(s[3]), Ie(s[1]), Ie(s[2]), Ie(s[3]);
          }
          function De(e) {
            r.push(a[3 * e + 0]), r.push(a[3 * e + 1]), r.push(a[3 * e + 2]);
          }
          function Ie(e) {
            i.push(e.x), i.push(e.y);
          }
          !(function () {
            var e = r.length / 3;
            if (u) {
              for (var t = 0, i = D * t, a = 0; a < I; a++) {
                var o = L[a];
                Pe(o[2] + i, o[1] + i, o[0] + i);
              }
              i = D * (t = s + 2 * p);
              for (var c = 0; c < I; c++) {
                var l = L[c];
                Pe(l[0] + i, l[1] + i, l[2] + i);
              }
            } else {
              for (var h = 0; h < I; h++) {
                var d = L[h];
                Pe(d[2], d[1], d[0]);
              }
              for (var f = 0; f < I; f++) {
                var m = L[f];
                Pe(m[0] + D * s, m[1] + D * s, m[2] + D * s);
              }
            }
            n.addGroup(e, r.length / 3 - e, 0);
          })(),
            (function () {
              var e = r.length / 3,
                t = 0;
              Ce(C, t), (t += C.length);
              for (var i = 0, a = S.length; i < a; i++) {
                var o = S[i];
                Ce(o, t), (t += o.length);
              }
              n.addGroup(e, r.length / 3 - e, 1);
            })();
        }
        this.setAttribute("position", new Ii(r, 3)),
          this.setAttribute("uv", new Ii(i, 2)),
          this.computeVertexNormals();
      }
      ((Uu.prototype = Object.create(va.prototype)).constructor = Uu),
        (Uu.prototype.toJSON = function () {
          var e = va.prototype.toJSON.call(this);
          return Hu(this.parameters.shapes, this.parameters.options, e);
        }),
        ((Gu.prototype = Object.create(Wi.prototype)).constructor = Gu),
        (Gu.prototype.toJSON = function () {
          var e = Wi.prototype.toJSON.call(this);
          return Hu(this.parameters.shapes, this.parameters.options, e);
        });
      var ku = {
        generateTopUV: function (e, t, n, r, i) {
          var a = t[3 * r],
            o = t[3 * r + 1],
            s = t[3 * i],
            c = t[3 * i + 1];
          return [new Hn(t[3 * n], t[3 * n + 1]), new Hn(a, o), new Hn(s, c)];
        },
        generateSideWallUV: function (e, t, n, r, i, a) {
          var o = t[3 * n],
            s = t[3 * n + 1],
            c = t[3 * n + 2],
            u = t[3 * r],
            l = t[3 * r + 1],
            h = t[3 * r + 2],
            d = t[3 * i],
            p = t[3 * i + 1],
            f = t[3 * i + 2],
            m = t[3 * a],
            v = t[3 * a + 1],
            g = t[3 * a + 2];
          return Math.abs(s - l) < 0.01
            ? [
                new Hn(o, 1 - c),
                new Hn(u, 1 - h),
                new Hn(d, 1 - f),
                new Hn(m, 1 - g),
              ]
            : [
                new Hn(s, 1 - c),
                new Hn(l, 1 - h),
                new Hn(p, 1 - f),
                new Hn(v, 1 - g),
              ];
        },
      };
      function Hu(e, t, n) {
        if (((n.shapes = []), Array.isArray(e)))
          for (var r = 0, i = e.length; r < i; r++) n.shapes.push(e[r].uuid);
        else n.shapes.push(e.uuid);
        return (
          void 0 !== t.extrudePath &&
            (n.options.extrudePath = t.extrudePath.toJSON()),
          n
        );
      }
      function ju(e, t) {
        va.call(this),
          (this.type = "TextGeometry"),
          (this.parameters = { text: e, parameters: t }),
          this.fromBufferGeometry(new Vu(e, t)),
          this.mergeVertices();
      }
      function Vu(e, t) {
        var n = (t = t || {}).font;
        if (!n || !n.isFont)
          return (
            console.error(
              "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
            ),
            new va()
          );
        var r = n.generateShapes(e, t.size);
        (t.depth = void 0 !== t.height ? t.height : 50),
          void 0 === t.bevelThickness && (t.bevelThickness = 10),
          void 0 === t.bevelSize && (t.bevelSize = 8),
          void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
          Gu.call(this, r, t),
          (this.type = "TextBufferGeometry");
      }
      function Wu(e, t, n, r, i, a, o) {
        va.call(this),
          (this.type = "SphereGeometry"),
          (this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: a,
            thetaLength: o,
          }),
          this.fromBufferGeometry(new qu(e, t, n, r, i, a, o)),
          this.mergeVertices();
      }
      function qu(e, t, n, r, i, a, o) {
        Wi.call(this),
          (this.type = "SphereBufferGeometry"),
          (this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: a,
            thetaLength: o,
          }),
          (e = e || 1),
          (t = Math.max(3, Math.floor(t) || 8)),
          (n = Math.max(2, Math.floor(n) || 6)),
          (r = void 0 !== r ? r : 0),
          (i = void 0 !== i ? i : 2 * Math.PI),
          (a = void 0 !== a ? a : 0),
          (o = void 0 !== o ? o : Math.PI);
        for (
          var s = Math.min(a + o, Math.PI),
            c = 0,
            u = [],
            l = new $n(),
            h = new $n(),
            d = [],
            p = [],
            f = [],
            m = [],
            v = 0;
          v <= n;
          v++
        ) {
          var g = [],
            y = v / n,
            x = 0;
          0 == v && 0 == a
            ? (x = 0.5 / t)
            : v == n && s == Math.PI && (x = -0.5 / t);
          for (var b = 0; b <= t; b++) {
            var _ = b / t;
            (l.x = -e * Math.cos(r + _ * i) * Math.sin(a + y * o)),
              (l.y = e * Math.cos(a + y * o)),
              (l.z = e * Math.sin(r + _ * i) * Math.sin(a + y * o)),
              p.push(l.x, l.y, l.z),
              h.copy(l).normalize(),
              f.push(h.x, h.y, h.z),
              m.push(_ + x, 1 - y),
              g.push(c++);
          }
          u.push(g);
        }
        for (var w = 0; w < n; w++)
          for (var M = 0; M < t; M++) {
            var S = u[w][M + 1],
              T = u[w][M],
              E = u[w + 1][M],
              A = u[w + 1][M + 1];
            (0 !== w || a > 0) && d.push(S, T, A),
              (w !== n - 1 || s < Math.PI) && d.push(T, E, A);
          }
        this.setIndex(d),
          this.setAttribute("position", new Ii(p, 3)),
          this.setAttribute("normal", new Ii(f, 3)),
          this.setAttribute("uv", new Ii(m, 2));
      }
      function Xu(e, t, n, r, i, a) {
        va.call(this),
          (this.type = "RingGeometry"),
          (this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: a,
          }),
          this.fromBufferGeometry(new Yu(e, t, n, r, i, a)),
          this.mergeVertices();
      }
      function Yu(e, t, n, r, i, a) {
        Wi.call(this),
          (this.type = "RingBufferGeometry"),
          (this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: a,
          }),
          (e = e || 0.5),
          (t = t || 1),
          (i = void 0 !== i ? i : 0),
          (a = void 0 !== a ? a : 2 * Math.PI),
          (n = void 0 !== n ? Math.max(3, n) : 8);
        for (
          var o = [],
            s = [],
            c = [],
            u = [],
            l = e,
            h = (t - e) / (r = void 0 !== r ? Math.max(1, r) : 1),
            d = new $n(),
            p = new Hn(),
            f = 0;
          f <= r;
          f++
        ) {
          for (var m = 0; m <= n; m++) {
            var v = i + (m / n) * a;
            (d.x = l * Math.cos(v)),
              (d.y = l * Math.sin(v)),
              s.push(d.x, d.y, d.z),
              c.push(0, 0, 1),
              (p.x = (d.x / t + 1) / 2),
              (p.y = (d.y / t + 1) / 2),
              u.push(p.x, p.y);
          }
          l += h;
        }
        for (var g = 0; g < r; g++)
          for (var y = g * (n + 1), x = 0; x < n; x++) {
            var b = x + y,
              _ = b + n + 1,
              w = b + n + 2,
              M = b + 1;
            o.push(b, _, M), o.push(_, w, M);
          }
        this.setIndex(o),
          this.setAttribute("position", new Ii(s, 3)),
          this.setAttribute("normal", new Ii(c, 3)),
          this.setAttribute("uv", new Ii(u, 2));
      }
      function Zu(e, t, n, r) {
        va.call(this),
          (this.type = "LatheGeometry"),
          (this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: r,
          }),
          this.fromBufferGeometry(new Ju(e, t, n, r)),
          this.mergeVertices();
      }
      function Ju(e, t, n, r) {
        Wi.call(this),
          (this.type = "LatheBufferGeometry"),
          (this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: r,
          }),
          (t = Math.floor(t) || 12),
          (n = n || 0),
          (r = r || 2 * Math.PI),
          (r = kn.clamp(r, 0, 2 * Math.PI));
        for (
          var i = [],
            a = [],
            o = [],
            s = 1 / t,
            c = new $n(),
            u = new Hn(),
            l = 0;
          l <= t;
          l++
        )
          for (
            var h = n + l * s * r, d = Math.sin(h), p = Math.cos(h), f = 0;
            f <= e.length - 1;
            f++
          )
            (c.x = e[f].x * d),
              (c.y = e[f].y),
              (c.z = e[f].x * p),
              a.push(c.x, c.y, c.z),
              (u.x = l / t),
              (u.y = f / (e.length - 1)),
              o.push(u.x, u.y);
        for (var m = 0; m < t; m++)
          for (var v = 0; v < e.length - 1; v++) {
            var g = v + m * e.length,
              y = g + e.length,
              x = g + e.length + 1,
              b = g + 1;
            i.push(g, y, b), i.push(y, x, b);
          }
        if (
          (this.setIndex(i),
          this.setAttribute("position", new Ii(a, 3)),
          this.setAttribute("uv", new Ii(o, 2)),
          this.computeVertexNormals(),
          r === 2 * Math.PI)
        )
          for (
            var _ = this.attributes.normal.array,
              w = new $n(),
              M = new $n(),
              S = new $n(),
              T = t * e.length * 3,
              E = 0,
              A = 0;
            E < e.length;
            E++, A += 3
          )
            (w.x = _[A + 0]),
              (w.y = _[A + 1]),
              (w.z = _[A + 2]),
              (M.x = _[T + A + 0]),
              (M.y = _[T + A + 1]),
              (M.z = _[T + A + 2]),
              S.addVectors(w, M).normalize(),
              (_[A + 0] = _[T + A + 0] = S.x),
              (_[A + 1] = _[T + A + 1] = S.y),
              (_[A + 2] = _[T + A + 2] = S.z);
      }
      function Ku(e, t) {
        va.call(this),
          (this.type = "ShapeGeometry"),
          "object" == typeof t &&
            (console.warn(
              "THREE.ShapeGeometry: Options parameter has been removed."
            ),
            (t = t.curveSegments)),
          (this.parameters = { shapes: e, curveSegments: t }),
          this.fromBufferGeometry(new Qu(e, t)),
          this.mergeVertices();
      }
      function Qu(e, t) {
        Wi.call(this),
          (this.type = "ShapeBufferGeometry"),
          (this.parameters = { shapes: e, curveSegments: t }),
          (t = t || 12);
        var n = [],
          r = [],
          i = [],
          a = [],
          o = 0,
          s = 0;
        if (!1 === Array.isArray(e)) u(e);
        else
          for (var c = 0; c < e.length; c++)
            u(e[c]), this.addGroup(o, s, c), (o += s), (s = 0);
        function u(e) {
          var o = r.length / 3,
            c = e.extractPoints(t),
            u = c.shape,
            l = c.holes;
          !1 === Bu.isClockWise(u) && (u = u.reverse());
          for (var h = 0, d = l.length; h < d; h++) {
            var p = l[h];
            !0 === Bu.isClockWise(p) && (l[h] = p.reverse());
          }
          for (
            var f = Bu.triangulateShape(u, l), m = 0, v = l.length;
            m < v;
            m++
          )
            u = u.concat(l[m]);
          for (var g = 0, y = u.length; g < y; g++) {
            var x = u[g];
            r.push(x.x, x.y, 0), i.push(0, 0, 1), a.push(x.x, x.y);
          }
          for (var b = 0, _ = f.length; b < _; b++) {
            var w = f[b];
            n.push(w[0] + o, w[1] + o, w[2] + o), (s += 3);
          }
        }
        this.setIndex(n),
          this.setAttribute("position", new Ii(r, 3)),
          this.setAttribute("normal", new Ii(i, 3)),
          this.setAttribute("uv", new Ii(a, 2));
      }
      function $u(e, t) {
        if (((t.shapes = []), Array.isArray(e)))
          for (var n = 0, r = e.length; n < r; n++) t.shapes.push(e[n].uuid);
        else t.shapes.push(e.uuid);
        return t;
      }
      function el(e, t) {
        Wi.call(this),
          (this.type = "EdgesGeometry"),
          (this.parameters = { thresholdAngle: t }),
          (t = void 0 !== t ? t : 1);
        var n,
          r,
          i,
          a,
          o = [],
          s = Math.cos(kn.DEG2RAD * t),
          c = [0, 0],
          u = {},
          l = ["a", "b", "c"];
        e.isBufferGeometry
          ? (a = new va()).fromBufferGeometry(e)
          : (a = e.clone()),
          a.mergeVertices(),
          a.computeFaceNormals();
        for (var h = a.vertices, d = a.faces, p = 0, f = d.length; p < f; p++)
          for (var m = d[p], v = 0; v < 3; v++)
            (n = m[l[v]]),
              (r = m[l[(v + 1) % 3]]),
              (c[0] = Math.min(n, r)),
              (c[1] = Math.max(n, r)),
              void 0 === u[(i = c[0] + "," + c[1])]
                ? (u[i] = {
                    index1: c[0],
                    index2: c[1],
                    face1: p,
                    face2: void 0,
                  })
                : (u[i].face2 = p);
        for (i in u) {
          var g = u[i];
          if (
            void 0 === g.face2 ||
            d[g.face1].normal.dot(d[g.face2].normal) <= s
          ) {
            var y = h[g.index1];
            o.push(y.x, y.y, y.z), (y = h[g.index2]), o.push(y.x, y.y, y.z);
          }
        }
        this.setAttribute("position", new Ii(o, 3));
      }
      function tl(e, t, n, r, i, a, o, s) {
        va.call(this),
          (this.type = "CylinderGeometry"),
          (this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: a,
            thetaStart: o,
            thetaLength: s,
          }),
          this.fromBufferGeometry(new nl(e, t, n, r, i, a, o, s)),
          this.mergeVertices();
      }
      function nl(e, t, n, r, i, a, o, s) {
        Wi.call(this),
          (this.type = "CylinderBufferGeometry"),
          (this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: a,
            thetaStart: o,
            thetaLength: s,
          });
        var c = this;
        (e = void 0 !== e ? e : 1),
          (t = void 0 !== t ? t : 1),
          (n = n || 1),
          (r = Math.floor(r) || 8),
          (i = Math.floor(i) || 1),
          (a = void 0 !== a && a),
          (o = void 0 !== o ? o : 0),
          (s = void 0 !== s ? s : 2 * Math.PI);
        var u = [],
          l = [],
          h = [],
          d = [],
          p = 0,
          f = [],
          m = n / 2,
          v = 0;
        function g(n) {
          var i,
            a,
            f = new Hn(),
            g = new $n(),
            y = 0,
            x = !0 === n ? e : t,
            b = !0 === n ? 1 : -1;
          i = p;
          for (var _ = 1; _ <= r; _++)
            l.push(0, m * b, 0), h.push(0, b, 0), d.push(0.5, 0.5), p++;
          a = p;
          for (var w = 0; w <= r; w++) {
            var M = (w / r) * s + o,
              S = Math.cos(M),
              T = Math.sin(M);
            (g.x = x * T),
              (g.y = m * b),
              (g.z = x * S),
              l.push(g.x, g.y, g.z),
              h.push(0, b, 0),
              (f.x = 0.5 * S + 0.5),
              (f.y = 0.5 * T * b + 0.5),
              d.push(f.x, f.y),
              p++;
          }
          for (var E = 0; E < r; E++) {
            var A = i + E,
              L = a + E;
            !0 === n ? u.push(L, L + 1, A) : u.push(L + 1, L, A), (y += 3);
          }
          c.addGroup(v, y, !0 === n ? 1 : 2), (v += y);
        }
        !(function () {
          for (
            var a = new $n(), g = new $n(), y = 0, x = (t - e) / n, b = 0;
            b <= i;
            b++
          ) {
            for (
              var _ = [], w = b / i, M = w * (t - e) + e, S = 0;
              S <= r;
              S++
            ) {
              var T = S / r,
                E = T * s + o,
                A = Math.sin(E),
                L = Math.cos(E);
              (g.x = M * A),
                (g.y = -w * n + m),
                (g.z = M * L),
                l.push(g.x, g.y, g.z),
                a.set(A, x, L).normalize(),
                h.push(a.x, a.y, a.z),
                d.push(T, 1 - w),
                _.push(p++);
            }
            f.push(_);
          }
          for (var C = 0; C < r; C++)
            for (var R = 0; R < i; R++) {
              var P = f[R + 1][C],
                O = f[R + 1][C + 1],
                D = f[R][C + 1];
              u.push(f[R][C], P, D), u.push(P, O, D), (y += 6);
            }
          c.addGroup(v, y, 0), (v += y);
        })(),
          !1 === a && (e > 0 && g(!0), t > 0 && g(!1)),
          this.setIndex(u),
          this.setAttribute("position", new Ii(l, 3)),
          this.setAttribute("normal", new Ii(h, 3)),
          this.setAttribute("uv", new Ii(d, 2));
      }
      function rl(e, t, n, r, i, a, o) {
        tl.call(this, 0, e, t, n, r, i, a, o),
          (this.type = "ConeGeometry"),
          (this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: a,
            thetaLength: o,
          });
      }
      function il(e, t, n, r, i, a, o) {
        nl.call(this, 0, e, t, n, r, i, a, o),
          (this.type = "ConeBufferGeometry"),
          (this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: a,
            thetaLength: o,
          });
      }
      function al(e, t, n, r) {
        va.call(this),
          (this.type = "CircleGeometry"),
          (this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: r,
          }),
          this.fromBufferGeometry(new ol(e, t, n, r)),
          this.mergeVertices();
      }
      function ol(e, t, n, r) {
        Wi.call(this),
          (this.type = "CircleBufferGeometry"),
          (this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: r,
          }),
          (e = e || 1),
          (t = void 0 !== t ? Math.max(3, t) : 8),
          (n = void 0 !== n ? n : 0),
          (r = void 0 !== r ? r : 2 * Math.PI);
        var i = [],
          a = [],
          o = [],
          s = [],
          c = new $n(),
          u = new Hn();
        a.push(0, 0, 0), o.push(0, 0, 1), s.push(0.5, 0.5);
        for (var l = 0, h = 3; l <= t; l++, h += 3) {
          var d = n + (l / t) * r;
          (c.x = e * Math.cos(d)),
            (c.y = e * Math.sin(d)),
            a.push(c.x, c.y, c.z),
            o.push(0, 0, 1),
            (u.x = (a[h] / e + 1) / 2),
            (u.y = (a[h + 1] / e + 1) / 2),
            s.push(u.x, u.y);
        }
        for (var p = 1; p <= t; p++) i.push(p, p + 1, 0);
        this.setIndex(i),
          this.setAttribute("position", new Ii(a, 3)),
          this.setAttribute("normal", new Ii(o, 3)),
          this.setAttribute("uv", new Ii(s, 2));
      }
      ((ju.prototype = Object.create(va.prototype)).constructor = ju),
        ((Vu.prototype = Object.create(Gu.prototype)).constructor = Vu),
        ((Wu.prototype = Object.create(va.prototype)).constructor = Wu),
        ((qu.prototype = Object.create(Wi.prototype)).constructor = qu),
        ((Xu.prototype = Object.create(va.prototype)).constructor = Xu),
        ((Yu.prototype = Object.create(Wi.prototype)).constructor = Yu),
        ((Zu.prototype = Object.create(va.prototype)).constructor = Zu),
        ((Ju.prototype = Object.create(Wi.prototype)).constructor = Ju),
        ((Ku.prototype = Object.create(va.prototype)).constructor = Ku),
        (Ku.prototype.toJSON = function () {
          var e = va.prototype.toJSON.call(this);
          return $u(this.parameters.shapes, e);
        }),
        ((Qu.prototype = Object.create(Wi.prototype)).constructor = Qu),
        (Qu.prototype.toJSON = function () {
          var e = Wi.prototype.toJSON.call(this);
          return $u(this.parameters.shapes, e);
        }),
        ((el.prototype = Object.create(Wi.prototype)).constructor = el),
        ((tl.prototype = Object.create(va.prototype)).constructor = tl),
        ((nl.prototype = Object.create(Wi.prototype)).constructor = nl),
        ((rl.prototype = Object.create(tl.prototype)).constructor = rl),
        ((il.prototype = Object.create(nl.prototype)).constructor = il),
        ((al.prototype = Object.create(va.prototype)).constructor = al),
        ((ol.prototype = Object.create(Wi.prototype)).constructor = ol);
      var sl = Object.freeze({
        __proto__: null,
        WireframeGeometry: Xc,
        ParametricGeometry: Yc,
        ParametricBufferGeometry: Zc,
        TetrahedronGeometry: Qc,
        TetrahedronBufferGeometry: $c,
        OctahedronGeometry: eu,
        OctahedronBufferGeometry: tu,
        IcosahedronGeometry: nu,
        IcosahedronBufferGeometry: ru,
        DodecahedronGeometry: iu,
        DodecahedronBufferGeometry: au,
        PolyhedronGeometry: Jc,
        PolyhedronBufferGeometry: Kc,
        TubeGeometry: ou,
        TubeBufferGeometry: su,
        TorusKnotGeometry: cu,
        TorusKnotBufferGeometry: uu,
        TorusGeometry: lu,
        TorusBufferGeometry: hu,
        TextGeometry: ju,
        TextBufferGeometry: Vu,
        SphereGeometry: Wu,
        SphereBufferGeometry: qu,
        RingGeometry: Xu,
        RingBufferGeometry: Yu,
        PlaneGeometry: Ia,
        PlaneBufferGeometry: Na,
        LatheGeometry: Zu,
        LatheBufferGeometry: Ju,
        ShapeGeometry: Ku,
        ShapeBufferGeometry: Qu,
        ExtrudeGeometry: Uu,
        ExtrudeBufferGeometry: Gu,
        EdgesGeometry: el,
        ConeGeometry: rl,
        ConeBufferGeometry: il,
        CylinderGeometry: tl,
        CylinderBufferGeometry: nl,
        CircleGeometry: al,
        CircleBufferGeometry: ol,
        BoxGeometry: ga,
        BoxBufferGeometry: ya,
      });
      function cl(e) {
        wi.call(this),
          (this.type = "ShadowMaterial"),
          (this.color = new vi(0)),
          (this.transparent = !0),
          this.setValues(e);
      }
      function ul(e) {
        wa.call(this, e), (this.type = "RawShaderMaterial");
      }
      function ll(e) {
        wi.call(this),
          (this.defines = { STANDARD: "" }),
          (this.type = "MeshStandardMaterial"),
          (this.color = new vi(16777215)),
          (this.roughness = 1),
          (this.metalness = 0),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new vi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = ln),
          (this.normalScale = new Hn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.roughnessMap = null),
          (this.metalnessMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.envMapIntensity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.vertexTangents = !1),
          this.setValues(e);
      }
      function hl(e) {
        ll.call(this),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.type = "MeshPhysicalMaterial"),
          (this.clearcoat = 0),
          (this.clearcoatMap = null),
          (this.clearcoatRoughness = 0),
          (this.clearcoatRoughnessMap = null),
          (this.clearcoatNormalScale = new Hn(1, 1)),
          (this.clearcoatNormalMap = null),
          (this.reflectivity = 0.5),
          (this.sheen = null),
          (this.transparency = 0),
          this.setValues(e);
      }
      function dl(e) {
        wi.call(this),
          (this.type = "MeshPhongMaterial"),
          (this.color = new vi(16777215)),
          (this.specular = new vi(1118481)),
          (this.shininess = 30),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new vi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = ln),
          (this.normalScale = new Hn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Q),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function pl(e) {
        wi.call(this),
          (this.defines = { TOON: "" }),
          (this.type = "MeshToonMaterial"),
          (this.color = new vi(16777215)),
          (this.map = null),
          (this.gradientMap = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new vi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = ln),
          (this.normalScale = new Hn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function fl(e) {
        wi.call(this),
          (this.type = "MeshNormalMaterial"),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = ln),
          (this.normalScale = new Hn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function ml(e) {
        wi.call(this),
          (this.type = "MeshLambertMaterial"),
          (this.color = new vi(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new vi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Q),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function vl(e) {
        wi.call(this),
          (this.defines = { MATCAP: "" }),
          (this.type = "MeshMatcapMaterial"),
          (this.color = new vi(16777215)),
          (this.matcap = null),
          (this.map = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = ln),
          (this.normalScale = new Hn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function gl(e) {
        Tc.call(this),
          (this.type = "LineDashedMaterial"),
          (this.scale = 1),
          (this.dashSize = 3),
          (this.gapSize = 1),
          this.setValues(e);
      }
      ((cl.prototype = Object.create(wi.prototype)).constructor = cl),
        (cl.prototype.isShadowMaterial = !0),
        (cl.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e), this.color.copy(e.color), this
          );
        }),
        ((ul.prototype = Object.create(wa.prototype)).constructor = ul),
        (ul.prototype.isRawShaderMaterial = !0),
        ((ll.prototype = Object.create(wi.prototype)).constructor = ll),
        (ll.prototype.isMeshStandardMaterial = !0),
        (ll.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.envMapIntensity = e.envMapIntensity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.vertexTangents = e.vertexTangents),
            this
          );
        }),
        ((hl.prototype = Object.create(ll.prototype)).constructor = hl),
        (hl.prototype.isMeshPhysicalMaterial = !0),
        (hl.prototype.copy = function (e) {
          return (
            ll.prototype.copy.call(this, e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.reflectivity = e.reflectivity),
            (this.sheen = e.sheen
              ? (this.sheen || new vi()).copy(e.sheen)
              : null),
            (this.transparency = e.transparency),
            this
          );
        }),
        ((dl.prototype = Object.create(wi.prototype)).constructor = dl),
        (dl.prototype.isMeshPhongMaterial = !0),
        (dl.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        ((pl.prototype = Object.create(wi.prototype)).constructor = pl),
        (pl.prototype.isMeshToonMaterial = !0),
        (pl.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.gradientMap = e.gradientMap),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        ((fl.prototype = Object.create(wi.prototype)).constructor = fl),
        (fl.prototype.isMeshNormalMaterial = !0),
        (fl.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        ((ml.prototype = Object.create(wi.prototype)).constructor = ml),
        (ml.prototype.isMeshLambertMaterial = !0),
        (ml.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        ((vl.prototype = Object.create(wi.prototype)).constructor = vl),
        (vl.prototype.isMeshMatcapMaterial = !0),
        (vl.prototype.copy = function (e) {
          return (
            wi.prototype.copy.call(this, e),
            (this.defines = { MATCAP: "" }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        ((gl.prototype = Object.create(Tc.prototype)).constructor = gl),
        (gl.prototype.isLineDashedMaterial = !0),
        (gl.prototype.copy = function (e) {
          return (
            Tc.prototype.copy.call(this, e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
          );
        });
      var yl = Object.freeze({
          __proto__: null,
          ShadowMaterial: cl,
          SpriteMaterial: qs,
          RawShaderMaterial: ul,
          ShaderMaterial: wa,
          PointsMaterial: Bc,
          MeshPhysicalMaterial: hl,
          MeshStandardMaterial: ll,
          MeshPhongMaterial: dl,
          MeshToonMaterial: pl,
          MeshNormalMaterial: fl,
          MeshLambertMaterial: ml,
          MeshDepthMaterial: As,
          MeshDistanceMaterial: Ls,
          MeshBasicMaterial: Mi,
          MeshMatcapMaterial: vl,
          LineDashedMaterial: gl,
          LineBasicMaterial: Tc,
          Material: wi,
        }),
        xl = {
          arraySlice: function (e, t, n) {
            return xl.isTypedArray(e)
              ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length))
              : e.slice(t, n);
          },
          convertArray: function (e, t, n) {
            return !e || (!n && e.constructor === t)
              ? e
              : "number" == typeof t.BYTES_PER_ELEMENT
              ? new t(e)
              : Array.prototype.slice.call(e);
          },
          isTypedArray: function (e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView);
          },
          getKeyframeOrder: function (e) {
            for (var t = e.length, n = new Array(t), r = 0; r !== t; ++r)
              n[r] = r;
            return (
              n.sort(function (t, n) {
                return e[t] - e[n];
              }),
              n
            );
          },
          sortedArray: function (e, t, n) {
            for (
              var r = e.length, i = new e.constructor(r), a = 0, o = 0;
              o !== r;
              ++a
            )
              for (var s = n[a] * t, c = 0; c !== t; ++c) i[o++] = e[s + c];
            return i;
          },
          flattenJSON: function (e, t, n, r) {
            for (var i = 1, a = e[0]; void 0 !== a && void 0 === a[r]; )
              a = e[i++];
            if (void 0 !== a) {
              var o = a[r];
              if (void 0 !== o)
                if (Array.isArray(o))
                  do {
                    void 0 !== (o = a[r]) &&
                      (t.push(a.time), n.push.apply(n, o)),
                      (a = e[i++]);
                  } while (void 0 !== a);
                else if (void 0 !== o.toArray)
                  do {
                    void 0 !== (o = a[r]) &&
                      (t.push(a.time), o.toArray(n, n.length)),
                      (a = e[i++]);
                  } while (void 0 !== a);
                else
                  do {
                    void 0 !== (o = a[r]) && (t.push(a.time), n.push(o)),
                      (a = e[i++]);
                  } while (void 0 !== a);
            }
          },
          subclip: function (e, t, n, r, i) {
            i = i || 30;
            var a = e.clone();
            a.name = t;
            for (var o = [], s = 0; s < a.tracks.length; ++s) {
              for (
                var c = a.tracks[s],
                  u = c.getValueSize(),
                  l = [],
                  h = [],
                  d = 0;
                d < c.times.length;
                ++d
              ) {
                var p = c.times[d] * i;
                if (!(p < n || p >= r)) {
                  l.push(c.times[d]);
                  for (var f = 0; f < u; ++f) h.push(c.values[d * u + f]);
                }
              }
              0 !== l.length &&
                ((c.times = xl.convertArray(l, c.times.constructor)),
                (c.values = xl.convertArray(h, c.values.constructor)),
                o.push(c));
            }
            a.tracks = o;
            for (var m = 1 / 0, v = 0; v < a.tracks.length; ++v)
              m > a.tracks[v].times[0] && (m = a.tracks[v].times[0]);
            for (var g = 0; g < a.tracks.length; ++g) a.tracks[g].shift(-1 * m);
            return a.resetDuration(), a;
          },
          makeClipAdditive: function (e, t, n, r) {
            void 0 === t && (t = 0),
              void 0 === n && (n = e),
              (void 0 === r || r <= 0) && (r = 30);
            for (
              var i = e.tracks.length,
                a = t / r,
                o = function (t) {
                  var r = n.tracks[t],
                    i = r.ValueTypeName;
                  if ("bool" === i || "string" === i) return "continue";
                  var o = e.tracks.find(function (e) {
                    return e.name === r.name && e.ValueTypeName === i;
                  });
                  if (void 0 === o) return "continue";
                  var s = r.getValueSize(),
                    c = r.times.length - 1,
                    u = void 0;
                  if (a <= r.times[0])
                    u = xl.arraySlice(r.values, 0, r.valueSize);
                  else if (a >= r.times[c]) u = xl.arraySlice(r.values, c * s);
                  else {
                    var l = r.createInterpolant();
                    l.evaluate(a), (u = l.resultBuffer);
                  }
                  "quaternion" === i &&
                    new Jn(u[0], u[1], u[2], u[3])
                      .normalize()
                      .conjugate()
                      .toArray(u);
                  for (var h = o.times.length, d = 0; d < h; ++d) {
                    var p = d * s;
                    if ("quaternion" === i)
                      Jn.multiplyQuaternionsFlat(
                        o.values,
                        p,
                        u,
                        0,
                        o.values,
                        p
                      );
                    else for (var f = 0; f < s; ++f) o.values[p + f] -= u[f];
                  }
                },
                s = 0;
              s < i;
              ++s
            )
              o(s);
            return (e.blendMode = Zt), e;
          },
        };
      function bl(e, t, n, r) {
        (this.parameterPositions = e),
          (this._cachedIndex = 0),
          (this.resultBuffer = void 0 !== r ? r : new t.constructor(n)),
          (this.sampleValues = t),
          (this.valueSize = n);
      }
      function _l(e, t, n, r) {
        bl.call(this, e, t, n, r),
          (this._weightPrev = -0),
          (this._offsetPrev = -0),
          (this._weightNext = -0),
          (this._offsetNext = -0);
      }
      function wl(e, t, n, r) {
        bl.call(this, e, t, n, r);
      }
      function Ml(e, t, n, r) {
        bl.call(this, e, t, n, r);
      }
      function Sl(e, t, n, r) {
        if (void 0 === e)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
          throw new Error(
            "THREE.KeyframeTrack: no keyframes in track named " + e
          );
        (this.name = e),
          (this.times = xl.convertArray(t, this.TimeBufferType)),
          (this.values = xl.convertArray(n, this.ValueBufferType)),
          this.setInterpolation(r || this.DefaultInterpolation);
      }
      function Tl(e, t, n) {
        Sl.call(this, e, t, n);
      }
      function El(e, t, n, r) {
        Sl.call(this, e, t, n, r);
      }
      function Al(e, t, n, r) {
        Sl.call(this, e, t, n, r);
      }
      function Ll(e, t, n, r) {
        bl.call(this, e, t, n, r);
      }
      function Cl(e, t, n, r) {
        Sl.call(this, e, t, n, r);
      }
      function Rl(e, t, n, r) {
        Sl.call(this, e, t, n, r);
      }
      function Pl(e, t, n, r) {
        Sl.call(this, e, t, n, r);
      }
      function Ol(e, t, n, r) {
        (this.name = e),
          (this.tracks = n),
          (this.duration = void 0 !== t ? t : -1),
          (this.blendMode = void 0 !== r ? r : Yt),
          (this.uuid = kn.generateUUID()),
          this.duration < 0 && this.resetDuration();
      }
      function Dl(e) {
        if (void 0 === e.type)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        var t = (function (e) {
          switch (e.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return Al;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Pl;
            case "color":
              return El;
            case "quaternion":
              return Cl;
            case "bool":
            case "boolean":
              return Tl;
            case "string":
              return Rl;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
        })(e.type);
        if (void 0 === e.times) {
          var n = [],
            r = [];
          xl.flattenJSON(e.keys, n, r, "value"), (e.times = n), (e.values = r);
        }
        return void 0 !== t.parse
          ? t.parse(e)
          : new t(e.name, e.times, e.values, e.interpolation);
      }
      Object.assign(bl.prototype, {
        evaluate: function (e) {
          var t = this.parameterPositions,
            n = this._cachedIndex,
            r = t[n],
            i = t[n - 1];
          e: {
            t: {
              var a;
              n: {
                r: if (!(e < r)) {
                  for (var o = n + 2; ; ) {
                    if (void 0 === r) {
                      if (e < i) break r;
                      return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, e, i)
                      );
                    }
                    if (n === o) break;
                    if (((i = r), e < (r = t[++n]))) break t;
                  }
                  a = t.length;
                  break n;
                }
                if (e >= i) break e;
                var s = t[1];
                e < s && ((n = 2), (i = s));
                for (var c = n - 2; ; ) {
                  if (void 0 === i)
                    return (this._cachedIndex = 0), this.beforeStart_(0, e, r);
                  if (n === c) break;
                  if (((r = i), e >= (i = t[--n - 1]))) break t;
                }
                (a = n), (n = 0);
              }
              for (; n < a; ) {
                var u = (n + a) >>> 1;
                e < t[u] ? (a = u) : (n = u + 1);
              }
              if (((r = t[n]), void 0 === (i = t[n - 1])))
                return (this._cachedIndex = 0), this.beforeStart_(0, e, r);
              if (void 0 === r)
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, i, e)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, i, r);
          }
          return this.interpolate_(n, i, e, r);
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function () {
          return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function (e) {
          for (
            var t = this.resultBuffer,
              n = this.sampleValues,
              r = this.valueSize,
              i = e * r,
              a = 0;
            a !== r;
            ++a
          )
            t[a] = n[i + a];
          return t;
        },
        interpolate_: function () {
          throw new Error("call to abstract method");
        },
        intervalChanged_: function () {},
      }),
        Object.assign(bl.prototype, {
          beforeStart_: bl.prototype.copySampleValue_,
          afterEnd_: bl.prototype.copySampleValue_,
        }),
        (_l.prototype = Object.assign(Object.create(bl.prototype), {
          constructor: _l,
          DefaultSettings_: { endingStart: Wt, endingEnd: Wt },
          intervalChanged_: function (e, t, n) {
            var r = this.parameterPositions,
              i = e - 2,
              a = e + 1,
              o = r[i],
              s = r[a];
            if (void 0 === o)
              switch (this.getSettings_().endingStart) {
                case qt:
                  (i = e), (o = 2 * t - n);
                  break;
                case Xt:
                  o = t + r[(i = r.length - 2)] - r[i + 1];
                  break;
                default:
                  (i = e), (o = n);
              }
            if (void 0 === s)
              switch (this.getSettings_().endingEnd) {
                case qt:
                  (a = e), (s = 2 * n - t);
                  break;
                case Xt:
                  (a = 1), (s = n + r[1] - r[0]);
                  break;
                default:
                  (a = e - 1), (s = t);
              }
            var c = 0.5 * (n - t),
              u = this.valueSize;
            (this._weightPrev = c / (t - o)),
              (this._weightNext = c / (s - n)),
              (this._offsetPrev = i * u),
              (this._offsetNext = a * u);
          },
          interpolate_: function (e, t, n, r) {
            for (
              var i = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = e * o,
                c = s - o,
                u = this._offsetPrev,
                l = this._offsetNext,
                h = this._weightPrev,
                d = this._weightNext,
                p = (n - t) / (r - t),
                f = p * p,
                m = f * p,
                v = -h * m + 2 * h * f - h * p,
                g = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
                y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
                x = d * m - d * f,
                b = 0;
              b !== o;
              ++b
            )
              i[b] = v * a[u + b] + g * a[c + b] + y * a[s + b] + x * a[l + b];
            return i;
          },
        })),
        (wl.prototype = Object.assign(Object.create(bl.prototype), {
          constructor: wl,
          interpolate_: function (e, t, n, r) {
            for (
              var i = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = e * o,
                c = s - o,
                u = (n - t) / (r - t),
                l = 1 - u,
                h = 0;
              h !== o;
              ++h
            )
              i[h] = a[c + h] * l + a[s + h] * u;
            return i;
          },
        })),
        (Ml.prototype = Object.assign(Object.create(bl.prototype), {
          constructor: Ml,
          interpolate_: function (e) {
            return this.copySampleValue_(e - 1);
          },
        })),
        Object.assign(Sl, {
          toJSON: function (e) {
            var t,
              n = e.constructor;
            if (void 0 !== n.toJSON) t = n.toJSON(e);
            else {
              t = {
                name: e.name,
                times: xl.convertArray(e.times, Array),
                values: xl.convertArray(e.values, Array),
              };
              var r = e.getInterpolation();
              r !== e.DefaultInterpolation && (t.interpolation = r);
            }
            return (t.type = e.ValueTypeName), t;
          },
        }),
        Object.assign(Sl.prototype, {
          constructor: Sl,
          TimeBufferType: Float32Array,
          ValueBufferType: Float32Array,
          DefaultInterpolation: jt,
          InterpolantFactoryMethodDiscrete: function (e) {
            return new Ml(this.times, this.values, this.getValueSize(), e);
          },
          InterpolantFactoryMethodLinear: function (e) {
            return new wl(this.times, this.values, this.getValueSize(), e);
          },
          InterpolantFactoryMethodSmooth: function (e) {
            return new _l(this.times, this.values, this.getValueSize(), e);
          },
          setInterpolation: function (e) {
            var t;
            switch (e) {
              case Ht:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
              case jt:
                t = this.InterpolantFactoryMethodLinear;
                break;
              case Vt:
                t = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === t) {
              var n =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (e === this.DefaultInterpolation) throw new Error(n);
                this.setInterpolation(this.DefaultInterpolation);
              }
              return console.warn("THREE.KeyframeTrack:", n), this;
            }
            return (this.createInterpolant = t), this;
          },
          getInterpolation: function () {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return Ht;
              case this.InterpolantFactoryMethodLinear:
                return jt;
              case this.InterpolantFactoryMethodSmooth:
                return Vt;
            }
          },
          getValueSize: function () {
            return this.values.length / this.times.length;
          },
          shift: function (e) {
            if (0 !== e)
              for (var t = this.times, n = 0, r = t.length; n !== r; ++n)
                t[n] += e;
            return this;
          },
          scale: function (e) {
            if (1 !== e)
              for (var t = this.times, n = 0, r = t.length; n !== r; ++n)
                t[n] *= e;
            return this;
          },
          trim: function (e, t) {
            for (
              var n = this.times, r = n.length, i = 0, a = r - 1;
              i !== r && n[i] < e;

            )
              ++i;
            for (; -1 !== a && n[a] > t; ) --a;
            if ((++a, 0 !== i || a !== r)) {
              i >= a && (i = (a = Math.max(a, 1)) - 1);
              var o = this.getValueSize();
              (this.times = xl.arraySlice(n, i, a)),
                (this.values = xl.arraySlice(this.values, i * o, a * o));
            }
            return this;
          },
          validate: function () {
            var e = !0,
              t = this.getValueSize();
            t - Math.floor(t) != 0 &&
              (console.error(
                "THREE.KeyframeTrack: Invalid value size in track.",
                this
              ),
              (e = !1));
            var n = this.times,
              r = this.values,
              i = n.length;
            0 === i &&
              (console.error("THREE.KeyframeTrack: Track is empty.", this),
              (e = !1));
            for (var a = null, o = 0; o !== i; o++) {
              var s = n[o];
              if ("number" == typeof s && isNaN(s)) {
                console.error(
                  "THREE.KeyframeTrack: Time is not a valid number.",
                  this,
                  o,
                  s
                ),
                  (e = !1);
                break;
              }
              if (null !== a && a > s) {
                console.error(
                  "THREE.KeyframeTrack: Out of order keys.",
                  this,
                  o,
                  s,
                  a
                ),
                  (e = !1);
                break;
              }
              a = s;
            }
            if (void 0 !== r && xl.isTypedArray(r))
              for (var c = 0, u = r.length; c !== u; ++c) {
                var l = r[c];
                if (isNaN(l)) {
                  console.error(
                    "THREE.KeyframeTrack: Value is not a valid number.",
                    this,
                    c,
                    l
                  ),
                    (e = !1);
                  break;
                }
              }
            return e;
          },
          optimize: function () {
            for (
              var e = xl.arraySlice(this.times),
                t = xl.arraySlice(this.values),
                n = this.getValueSize(),
                r = this.getInterpolation() === Vt,
                i = e.length - 1,
                a = 1,
                o = 1;
              o < i;
              ++o
            ) {
              var s = !1,
                c = e[o];
              if (c !== e[o + 1] && (1 !== o || c !== c[0]))
                if (r) s = !0;
                else
                  for (
                    var u = o * n, l = u - n, h = u + n, d = 0;
                    d !== n;
                    ++d
                  ) {
                    var p = t[u + d];
                    if (p !== t[l + d] || p !== t[h + d]) {
                      s = !0;
                      break;
                    }
                  }
              if (s) {
                if (o !== a) {
                  e[a] = e[o];
                  for (var f = o * n, m = a * n, v = 0; v !== n; ++v)
                    t[m + v] = t[f + v];
                }
                ++a;
              }
            }
            if (i > 0) {
              e[a] = e[i];
              for (var g = i * n, y = a * n, x = 0; x !== n; ++x)
                t[y + x] = t[g + x];
              ++a;
            }
            return (
              a !== e.length
                ? ((this.times = xl.arraySlice(e, 0, a)),
                  (this.values = xl.arraySlice(t, 0, a * n)))
                : ((this.times = e), (this.values = t)),
              this
            );
          },
          clone: function () {
            var e = xl.arraySlice(this.times, 0),
              t = xl.arraySlice(this.values, 0),
              n = new (0, this.constructor)(this.name, e, t);
            return (n.createInterpolant = this.createInterpolant), n;
          },
        }),
        (Tl.prototype = Object.assign(Object.create(Sl.prototype), {
          constructor: Tl,
          ValueTypeName: "bool",
          ValueBufferType: Array,
          DefaultInterpolation: Ht,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0,
        })),
        (El.prototype = Object.assign(Object.create(Sl.prototype), {
          constructor: El,
          ValueTypeName: "color",
        })),
        (Al.prototype = Object.assign(Object.create(Sl.prototype), {
          constructor: Al,
          ValueTypeName: "number",
        })),
        (Ll.prototype = Object.assign(Object.create(bl.prototype), {
          constructor: Ll,
          interpolate_: function (e, t, n, r) {
            for (
              var i = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = (n - t) / (r - t),
                c = e * o,
                u = c + o;
              c !== u;
              c += 4
            )
              Jn.slerpFlat(i, 0, a, c - o, a, c, s);
            return i;
          },
        })),
        (Cl.prototype = Object.assign(Object.create(Sl.prototype), {
          constructor: Cl,
          ValueTypeName: "quaternion",
          DefaultInterpolation: jt,
          InterpolantFactoryMethodLinear: function (e) {
            return new Ll(this.times, this.values, this.getValueSize(), e);
          },
          InterpolantFactoryMethodSmooth: void 0,
        })),
        (Rl.prototype = Object.assign(Object.create(Sl.prototype), {
          constructor: Rl,
          ValueTypeName: "string",
          ValueBufferType: Array,
          DefaultInterpolation: Ht,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0,
        })),
        (Pl.prototype = Object.assign(Object.create(Sl.prototype), {
          constructor: Pl,
          ValueTypeName: "vector",
        })),
        Object.assign(Ol, {
          parse: function (e) {
            for (
              var t = [],
                n = e.tracks,
                r = 1 / (e.fps || 1),
                i = 0,
                a = n.length;
              i !== a;
              ++i
            )
              t.push(Dl(n[i]).scale(r));
            return new Ol(e.name, e.duration, t, e.blendMode);
          },
          toJSON: function (e) {
            for (
              var t = [],
                n = e.tracks,
                r = {
                  name: e.name,
                  duration: e.duration,
                  tracks: t,
                  uuid: e.uuid,
                  blendMode: e.blendMode,
                },
                i = 0,
                a = n.length;
              i !== a;
              ++i
            )
              t.push(Sl.toJSON(n[i]));
            return r;
          },
          CreateFromMorphTargetSequence: function (e, t, n, r) {
            for (var i = t.length, a = [], o = 0; o < i; o++) {
              var s = [],
                c = [];
              s.push((o + i - 1) % i, o, (o + 1) % i), c.push(0, 1, 0);
              var u = xl.getKeyframeOrder(s);
              (s = xl.sortedArray(s, 1, u)),
                (c = xl.sortedArray(c, 1, u)),
                r || 0 !== s[0] || (s.push(i), c.push(c[0])),
                a.push(
                  new Al(
                    ".morphTargetInfluences[" + t[o].name + "]",
                    s,
                    c
                  ).scale(1 / n)
                );
            }
            return new Ol(e, -1, a);
          },
          findByName: function (e, t) {
            var n = e;
            if (!Array.isArray(e)) {
              var r = e;
              n = (r.geometry && r.geometry.animations) || r.animations;
            }
            for (var i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
            return null;
          },
          CreateClipsFromMorphTargetSequences: function (e, t, n) {
            for (
              var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length;
              a < o;
              a++
            ) {
              var s = e[a],
                c = s.name.match(i);
              if (c && c.length > 1) {
                var u = c[1],
                  l = r[u];
                l || (r[u] = l = []), l.push(s);
              }
            }
            var h = [];
            for (var d in r)
              h.push(Ol.CreateFromMorphTargetSequence(d, r[d], t, n));
            return h;
          },
          parseAnimation: function (e, t) {
            if (!e)
              return (
                console.error(
                  "THREE.AnimationClip: No animation in JSONLoader data."
                ),
                null
              );
            for (
              var n = function (e, t, n, r, i) {
                  if (0 !== n.length) {
                    var a = [],
                      o = [];
                    xl.flattenJSON(n, a, o, r),
                      0 !== a.length && i.push(new e(t, a, o));
                  }
                },
                r = [],
                i = e.name || "default",
                a = e.fps || 30,
                o = e.blendMode,
                s = e.length || -1,
                c = e.hierarchy || [],
                u = 0;
              u < c.length;
              u++
            ) {
              var l = c[u].keys;
              if (l && 0 !== l.length)
                if (l[0].morphTargets) {
                  var h = {},
                    d = void 0;
                  for (d = 0; d < l.length; d++)
                    if (l[d].morphTargets)
                      for (var p = 0; p < l[d].morphTargets.length; p++)
                        h[l[d].morphTargets[p]] = -1;
                  for (var f in h) {
                    for (
                      var m = [], v = [], g = 0;
                      g !== l[d].morphTargets.length;
                      ++g
                    ) {
                      var y = l[d];
                      m.push(y.time), v.push(y.morphTarget === f ? 1 : 0);
                    }
                    r.push(new Al(".morphTargetInfluence[" + f + "]", m, v));
                  }
                  s = h.length * (a || 1);
                } else {
                  var x = ".bones[" + t[u].name + "]";
                  n(Pl, x + ".position", l, "pos", r),
                    n(Cl, x + ".quaternion", l, "rot", r),
                    n(Pl, x + ".scale", l, "scl", r);
                }
            }
            return 0 === r.length ? null : new Ol(i, s, r, o);
          },
        }),
        Object.assign(Ol.prototype, {
          resetDuration: function () {
            for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
              var r = this.tracks[t];
              e = Math.max(e, r.times[r.times.length - 1]);
            }
            return (this.duration = e), this;
          },
          trim: function () {
            for (var e = 0; e < this.tracks.length; e++)
              this.tracks[e].trim(0, this.duration);
            return this;
          },
          validate: function () {
            for (var e = !0, t = 0; t < this.tracks.length; t++)
              e = e && this.tracks[t].validate();
            return e;
          },
          optimize: function () {
            for (var e = 0; e < this.tracks.length; e++)
              this.tracks[e].optimize();
            return this;
          },
          clone: function () {
            for (var e = [], t = 0; t < this.tracks.length; t++)
              e.push(this.tracks[t].clone());
            return new Ol(this.name, this.duration, e, this.blendMode);
          },
        });
      var Il = {
        enabled: !1,
        files: {},
        add: function (e, t) {
          !1 !== this.enabled && (this.files[e] = t);
        },
        get: function (e) {
          if (!1 !== this.enabled) return this.files[e];
        },
        remove: function (e) {
          delete this.files[e];
        },
        clear: function () {
          this.files = {};
        },
      };
      function Nl(e, t, n) {
        var r = this,
          i = !1,
          a = 0,
          o = 0,
          s = void 0,
          c = [];
        (this.onStart = void 0),
          (this.onLoad = e),
          (this.onProgress = t),
          (this.onError = n),
          (this.itemStart = function (e) {
            o++,
              !1 === i && void 0 !== r.onStart && r.onStart(e, a, o),
              (i = !0);
          }),
          (this.itemEnd = function (e) {
            a++,
              void 0 !== r.onProgress && r.onProgress(e, a, o),
              a === o && ((i = !1), void 0 !== r.onLoad && r.onLoad());
          }),
          (this.itemError = function (e) {
            void 0 !== r.onError && r.onError(e);
          }),
          (this.resolveURL = function (e) {
            return s ? s(e) : e;
          }),
          (this.setURLModifier = function (e) {
            return (s = e), this;
          }),
          (this.addHandler = function (e, t) {
            return c.push(e, t), this;
          }),
          (this.removeHandler = function (e) {
            var t = c.indexOf(e);
            return -1 !== t && c.splice(t, 2), this;
          }),
          (this.getHandler = function (e) {
            for (var t = 0, n = c.length; t < n; t += 2) {
              var r = c[t],
                i = c[t + 1];
              if ((r.global && (r.lastIndex = 0), r.test(e))) return i;
            }
            return null;
          });
      }
      var Bl = new Nl();
      function zl(e) {
        (this.manager = void 0 !== e ? e : Bl),
          (this.crossOrigin = "anonymous"),
          (this.path = ""),
          (this.resourcePath = ""),
          (this.requestHeader = {});
      }
      Object.assign(zl.prototype, {
        load: function () {},
        loadAsync: function (e, t) {
          var n = this;
          return new Promise(function (r, i) {
            n.load(e, r, t, i);
          });
        },
        parse: function () {},
        setCrossOrigin: function (e) {
          return (this.crossOrigin = e), this;
        },
        setPath: function (e) {
          return (this.path = e), this;
        },
        setResourcePath: function (e) {
          return (this.resourcePath = e), this;
        },
        setRequestHeader: function (e) {
          return (this.requestHeader = e), this;
        },
      });
      var Fl = {};
      function Ul(e) {
        zl.call(this, e);
      }
      function Gl(e) {
        zl.call(this, e);
      }
      function kl(e) {
        zl.call(this, e);
      }
      function Hl(e) {
        zl.call(this, e);
      }
      function jl(e) {
        zl.call(this, e);
      }
      function Vl(e) {
        zl.call(this, e);
      }
      function Wl(e) {
        zl.call(this, e);
      }
      function ql() {
        (this.type = "Curve"), (this.arcLengthDivisions = 200);
      }
      function Xl(e, t, n, r, i, a, o, s) {
        ql.call(this),
          (this.type = "EllipseCurve"),
          (this.aX = e || 0),
          (this.aY = t || 0),
          (this.xRadius = n || 1),
          (this.yRadius = r || 1),
          (this.aStartAngle = i || 0),
          (this.aEndAngle = a || 2 * Math.PI),
          (this.aClockwise = o || !1),
          (this.aRotation = s || 0);
      }
      function Yl(e, t, n, r, i, a) {
        Xl.call(this, e, t, n, n, r, i, a), (this.type = "ArcCurve");
      }
      function Zl() {
        var e = 0,
          t = 0,
          n = 0,
          r = 0;
        function i(i, a, o, s) {
          (e = i),
            (t = o),
            (n = -3 * i + 3 * a - 2 * o - s),
            (r = 2 * i - 2 * a + o + s);
        }
        return {
          initCatmullRom: function (e, t, n, r, a) {
            i(t, n, a * (n - e), a * (r - t));
          },
          initNonuniformCatmullRom: function (e, t, n, r, a, o, s) {
            var c = (t - e) / a - (n - e) / (a + o) + (n - t) / o,
              u = (n - t) / o - (r - t) / (o + s) + (r - n) / s;
            i(t, n, (c *= o), (u *= o));
          },
          calc: function (i) {
            var a = i * i;
            return e + t * i + n * a + r * (a * i);
          },
        };
      }
      (Ul.prototype = Object.assign(Object.create(zl.prototype), {
        constructor: Ul,
        load: function (e, t, n, r) {
          void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          var i = this,
            a = Il.get(e);
          if (void 0 !== a)
            return (
              i.manager.itemStart(e),
              setTimeout(function () {
                t && t(a), i.manager.itemEnd(e);
              }, 0),
              a
            );
          if (void 0 === Fl[e]) {
            var o,
              s = e.match(/^data:(.*?)(;base64)?,(.*)$/);
            if (s) {
              var c = s[1],
                u = !!s[2],
                l = s[3];
              (l = decodeURIComponent(l)), u && (l = atob(l));
              try {
                var h,
                  d = (this.responseType || "").toLowerCase();
                switch (d) {
                  case "arraybuffer":
                  case "blob":
                    for (
                      var p = new Uint8Array(l.length), f = 0;
                      f < l.length;
                      f++
                    )
                      p[f] = l.charCodeAt(f);
                    h =
                      "blob" === d
                        ? new Blob([p.buffer], { type: c })
                        : p.buffer;
                    break;
                  case "document":
                    var m = new DOMParser();
                    h = m.parseFromString(l, c);
                    break;
                  case "json":
                    h = JSON.parse(l);
                    break;
                  default:
                    h = l;
                }
                setTimeout(function () {
                  t && t(h), i.manager.itemEnd(e);
                }, 0);
              } catch (g) {
                setTimeout(function () {
                  r && r(g), i.manager.itemError(e), i.manager.itemEnd(e);
                }, 0);
              }
            } else {
              for (var v in ((Fl[e] = []),
              Fl[e].push({ onLoad: t, onProgress: n, onError: r }),
              (o = new XMLHttpRequest()).open("GET", e, !0),
              o.addEventListener(
                "load",
                function (t) {
                  var n = this.response,
                    r = Fl[e];
                  if (
                    (delete Fl[e], 200 === this.status || 0 === this.status)
                  ) {
                    0 === this.status &&
                      console.warn("THREE.FileLoader: HTTP Status 0 received."),
                      Il.add(e, n);
                    for (var a = 0, o = r.length; a < o; a++) {
                      var s = r[a];
                      s.onLoad && s.onLoad(n);
                    }
                    i.manager.itemEnd(e);
                  } else {
                    for (var c = 0, u = r.length; c < u; c++) {
                      var l = r[c];
                      l.onError && l.onError(t);
                    }
                    i.manager.itemError(e), i.manager.itemEnd(e);
                  }
                },
                !1
              ),
              o.addEventListener(
                "progress",
                function (t) {
                  for (var n = Fl[e], r = 0, i = n.length; r < i; r++) {
                    var a = n[r];
                    a.onProgress && a.onProgress(t);
                  }
                },
                !1
              ),
              o.addEventListener(
                "error",
                function (t) {
                  var n = Fl[e];
                  delete Fl[e];
                  for (var r = 0, a = n.length; r < a; r++) {
                    var o = n[r];
                    o.onError && o.onError(t);
                  }
                  i.manager.itemError(e), i.manager.itemEnd(e);
                },
                !1
              ),
              o.addEventListener(
                "abort",
                function (t) {
                  var n = Fl[e];
                  delete Fl[e];
                  for (var r = 0, a = n.length; r < a; r++) {
                    var o = n[r];
                    o.onError && o.onError(t);
                  }
                  i.manager.itemError(e), i.manager.itemEnd(e);
                },
                !1
              ),
              void 0 !== this.responseType &&
                (o.responseType = this.responseType),
              void 0 !== this.withCredentials &&
                (o.withCredentials = this.withCredentials),
              o.overrideMimeType &&
                o.overrideMimeType(
                  void 0 !== this.mimeType ? this.mimeType : "text/plain"
                ),
              this.requestHeader))
                o.setRequestHeader(v, this.requestHeader[v]);
              o.send(null);
            }
            return i.manager.itemStart(e), o;
          }
          Fl[e].push({ onLoad: t, onProgress: n, onError: r });
        },
        setResponseType: function (e) {
          return (this.responseType = e), this;
        },
        setWithCredentials: function (e) {
          return (this.withCredentials = e), this;
        },
        setMimeType: function (e) {
          return (this.mimeType = e), this;
        },
      })),
        (Gl.prototype = Object.assign(Object.create(zl.prototype), {
          constructor: Gl,
          load: function (e, t, n, r) {
            var i = this,
              a = new Ul(i.manager);
            a.setPath(i.path),
              a.load(
                e,
                function (n) {
                  try {
                    t(i.parse(JSON.parse(n)));
                  } catch (a) {
                    r ? r(a) : console.error(a), i.manager.itemError(e);
                  }
                },
                n,
                r
              );
          },
          parse: function (e) {
            for (var t = [], n = 0; n < e.length; n++) {
              var r = Ol.parse(e[n]);
              t.push(r);
            }
            return t;
          },
        })),
        (kl.prototype = Object.assign(Object.create(zl.prototype), {
          constructor: kl,
          load: function (e, t, n, r) {
            var i = this,
              a = [],
              o = new Vc();
            o.image = a;
            var s = new Ul(this.manager);
            s.setPath(this.path), s.setResponseType("arraybuffer");
            var c = 0;
            function u(u) {
              s.load(
                e[u],
                function (e) {
                  var n = i.parse(e, !0);
                  (a[u] = {
                    width: n.width,
                    height: n.height,
                    format: n.format,
                    mipmaps: n.mipmaps,
                  }),
                    6 === (c += 1) &&
                      (1 === n.mipmapCount && (o.minFilter = we),
                      (o.format = n.format),
                      (o.needsUpdate = !0),
                      t && t(o));
                },
                n,
                r
              );
            }
            if (Array.isArray(e))
              for (var l = 0, h = e.length; l < h; ++l) u(l);
            else
              s.load(
                e,
                function (e) {
                  var n = i.parse(e, !0);
                  if (n.isCubemap)
                    for (
                      var r = n.mipmaps.length / n.mipmapCount, s = 0;
                      s < r;
                      s++
                    ) {
                      a[s] = { mipmaps: [] };
                      for (var c = 0; c < n.mipmapCount; c++)
                        a[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]),
                          (a[s].format = n.format),
                          (a[s].width = n.width),
                          (a[s].height = n.height);
                    }
                  else
                    (o.image.width = n.width),
                      (o.image.height = n.height),
                      (o.mipmaps = n.mipmaps);
                  1 === n.mipmapCount && (o.minFilter = we),
                    (o.format = n.format),
                    (o.needsUpdate = !0),
                    t && t(o);
                },
                n,
                r
              );
            return o;
          },
        })),
        (Hl.prototype = Object.assign(Object.create(zl.prototype), {
          constructor: Hl,
          load: function (e, t, n, r) {
            var i = this,
              a = new Aa(),
              o = new Ul(this.manager);
            return (
              o.setResponseType("arraybuffer"),
              o.setPath(this.path),
              o.load(
                e,
                function (e) {
                  var n = i.parse(e);
                  n &&
                    (void 0 !== n.image
                      ? (a.image = n.image)
                      : void 0 !== n.data &&
                        ((a.image.width = n.width),
                        (a.image.height = n.height),
                        (a.image.data = n.data)),
                    (a.wrapS = void 0 !== n.wrapS ? n.wrapS : me),
                    (a.wrapT = void 0 !== n.wrapT ? n.wrapT : me),
                    (a.magFilter = void 0 !== n.magFilter ? n.magFilter : we),
                    (a.minFilter = void 0 !== n.minFilter ? n.minFilter : we),
                    (a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                    void 0 !== n.format && (a.format = n.format),
                    void 0 !== n.type && (a.type = n.type),
                    void 0 !== n.mipmaps &&
                      ((a.mipmaps = n.mipmaps), (a.minFilter = Te)),
                    1 === n.mipmapCount && (a.minFilter = we),
                    (a.needsUpdate = !0),
                    t && t(a, n));
                },
                n,
                r
              ),
              a
            );
          },
        })),
        (jl.prototype = Object.assign(Object.create(zl.prototype), {
          constructor: jl,
          load: function (e, t, n, r) {
            void 0 !== this.path && (e = this.path + e),
              (e = this.manager.resolveURL(e));
            var i = this,
              a = Il.get(e);
            if (void 0 !== a)
              return (
                i.manager.itemStart(e),
                setTimeout(function () {
                  t && t(a), i.manager.itemEnd(e);
                }, 0),
                a
              );
            var o = document.createElementNS(
              "http://www.w3.org/1999/xhtml",
              "img"
            );
            function s() {
              o.removeEventListener("load", s, !1),
                o.removeEventListener("error", c, !1),
                Il.add(e, this),
                t && t(this),
                i.manager.itemEnd(e);
            }
            function c(t) {
              o.removeEventListener("load", s, !1),
                o.removeEventListener("error", c, !1),
                r && r(t),
                i.manager.itemError(e),
                i.manager.itemEnd(e);
            }
            return (
              o.addEventListener("load", s, !1),
              o.addEventListener("error", c, !1),
              "data:" !== e.substr(0, 5) &&
                void 0 !== this.crossOrigin &&
                (o.crossOrigin = this.crossOrigin),
              i.manager.itemStart(e),
              (o.src = e),
              o
            );
          },
        })),
        (Vl.prototype = Object.assign(Object.create(zl.prototype), {
          constructor: Vl,
          load: function (e, t, n, r) {
            var i = new Ka(),
              a = new jl(this.manager);
            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
            var o = 0;
            function s(n) {
              a.load(
                e[n],
                function (e) {
                  (i.images[n] = e),
                    6 === ++o && ((i.needsUpdate = !0), t && t(i));
                },
                void 0,
                r
              );
            }
            for (var c = 0; c < e.length; ++c) s(c);
            return i;
          },
        })),
        (Wl.prototype = Object.assign(Object.create(zl.prototype), {
          constructor: Wl,
          load: function (e, t, n, r) {
            var i = new qn(),
              a = new jl(this.manager);
            return (
              a.setCrossOrigin(this.crossOrigin),
              a.setPath(this.path),
              a.load(
                e,
                function (n) {
                  i.image = n;
                  var r =
                    e.search(/\.jpe?g($|\?)/i) > 0 ||
                    0 === e.search(/^data\:image\/jpeg/);
                  (i.format = r ? Ge : ke),
                    (i.needsUpdate = !0),
                    void 0 !== t && t(i);
                },
                n,
                r
              ),
              i
            );
          },
        })),
        Object.assign(ql.prototype, {
          getPoint: function () {
            return (
              console.warn("THREE.Curve: .getPoint() not implemented."), null
            );
          },
          getPointAt: function (e, t) {
            var n = this.getUtoTmapping(e);
            return this.getPoint(n, t);
          },
          getPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return t;
          },
          getSpacedPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
            return t;
          },
          getLength: function () {
            var e = this.getLengths();
            return e[e.length - 1];
          },
          getLengths: function (e) {
            if (
              (void 0 === e && (e = this.arcLengthDivisions),
              this.cacheArcLengths &&
                this.cacheArcLengths.length === e + 1 &&
                !this.needsUpdate)
            )
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t,
              n = [],
              r = this.getPoint(0),
              i = 0;
            n.push(0);
            for (var a = 1; a <= e; a++)
              (i += (t = this.getPoint(a / e)).distanceTo(r)),
                n.push(i),
                (r = t);
            return (this.cacheArcLengths = n), n;
          },
          updateArcLengths: function () {
            (this.needsUpdate = !0), this.getLengths();
          },
          getUtoTmapping: function (e, t) {
            var n,
              r = this.getLengths(),
              i = 0,
              a = r.length;
            n = t || e * r[a - 1];
            for (var o, s = 0, c = a - 1; s <= c; )
              if ((o = r[(i = Math.floor(s + (c - s) / 2))] - n) < 0) s = i + 1;
              else {
                if (!(o > 0)) {
                  c = i;
                  break;
                }
                c = i - 1;
              }
            if (r[(i = c)] === n) return i / (a - 1);
            var u = r[i];
            return (i + (n - u) / (r[i + 1] - u)) / (a - 1);
          },
          getTangent: function (e, t) {
            var n = e - 1e-4,
              r = e + 1e-4;
            n < 0 && (n = 0), r > 1 && (r = 1);
            var i = this.getPoint(n),
              a = this.getPoint(r),
              o = t || (i.isVector2 ? new Hn() : new $n());
            return o.copy(a).sub(i).normalize(), o;
          },
          getTangentAt: function (e, t) {
            var n = this.getUtoTmapping(e);
            return this.getTangent(n, t);
          },
          computeFrenetFrames: function (e, t) {
            for (
              var n = new $n(),
                r = [],
                i = [],
                a = [],
                o = new $n(),
                s = new sr(),
                c = 0;
              c <= e;
              c++
            )
              (r[c] = this.getTangentAt(c / e, new $n())), r[c].normalize();
            (i[0] = new $n()), (a[0] = new $n());
            var u = Number.MAX_VALUE,
              l = Math.abs(r[0].x),
              h = Math.abs(r[0].y),
              d = Math.abs(r[0].z);
            l <= u && ((u = l), n.set(1, 0, 0)),
              h <= u && ((u = h), n.set(0, 1, 0)),
              d <= u && n.set(0, 0, 1),
              o.crossVectors(r[0], n).normalize(),
              i[0].crossVectors(r[0], o),
              a[0].crossVectors(r[0], i[0]);
            for (var p = 1; p <= e; p++) {
              if (
                ((i[p] = i[p - 1].clone()),
                (a[p] = a[p - 1].clone()),
                o.crossVectors(r[p - 1], r[p]),
                o.length() > Number.EPSILON)
              ) {
                o.normalize();
                var f = Math.acos(kn.clamp(r[p - 1].dot(r[p]), -1, 1));
                i[p].applyMatrix4(s.makeRotationAxis(o, f));
              }
              a[p].crossVectors(r[p], i[p]);
            }
            if (!0 === t) {
              var m = Math.acos(kn.clamp(i[0].dot(i[e]), -1, 1));
              (m /= e), r[0].dot(o.crossVectors(i[0], i[e])) > 0 && (m = -m);
              for (var v = 1; v <= e; v++)
                i[v].applyMatrix4(s.makeRotationAxis(r[v], m * v)),
                  a[v].crossVectors(r[v], i[v]);
            }
            return { tangents: r, normals: i, binormals: a };
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (this.arcLengthDivisions = e.arcLengthDivisions), this;
          },
          toJSON: function () {
            var e = {
              metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON",
              },
            };
            return (
              (e.arcLengthDivisions = this.arcLengthDivisions),
              (e.type = this.type),
              e
            );
          },
          fromJSON: function (e) {
            return (this.arcLengthDivisions = e.arcLengthDivisions), this;
          },
        }),
        ((Xl.prototype = Object.create(ql.prototype)).constructor = Xl),
        (Xl.prototype.isEllipseCurve = !0),
        (Xl.prototype.getPoint = function (e, t) {
          for (
            var n = t || new Hn(),
              r = 2 * Math.PI,
              i = this.aEndAngle - this.aStartAngle,
              a = Math.abs(i) < Number.EPSILON;
            i < 0;

          )
            i += r;
          for (; i > r; ) i -= r;
          i < Number.EPSILON && (i = a ? 0 : r),
            !0 !== this.aClockwise || a || (i === r ? (i = -r) : (i -= r));
          var o = this.aStartAngle + e * i,
            s = this.aX + this.xRadius * Math.cos(o),
            c = this.aY + this.yRadius * Math.sin(o);
          if (0 !== this.aRotation) {
            var u = Math.cos(this.aRotation),
              l = Math.sin(this.aRotation),
              h = s - this.aX,
              d = c - this.aY;
            (s = h * u - d * l + this.aX), (c = h * l + d * u + this.aY);
          }
          return n.set(s, c);
        }),
        (Xl.prototype.copy = function (e) {
          return (
            ql.prototype.copy.call(this, e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }),
        (Xl.prototype.toJSON = function () {
          var e = ql.prototype.toJSON.call(this);
          return (
            (e.aX = this.aX),
            (e.aY = this.aY),
            (e.xRadius = this.xRadius),
            (e.yRadius = this.yRadius),
            (e.aStartAngle = this.aStartAngle),
            (e.aEndAngle = this.aEndAngle),
            (e.aClockwise = this.aClockwise),
            (e.aRotation = this.aRotation),
            e
          );
        }),
        (Xl.prototype.fromJSON = function (e) {
          return (
            ql.prototype.fromJSON.call(this, e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }),
        ((Yl.prototype = Object.create(Xl.prototype)).constructor = Yl),
        (Yl.prototype.isArcCurve = !0);
      var Jl = new $n(),
        Kl = new Zl(),
        Ql = new Zl(),
        $l = new Zl();
      function eh(e, t, n, r) {
        ql.call(this),
          (this.type = "CatmullRomCurve3"),
          (this.points = e || []),
          (this.closed = t || !1),
          (this.curveType = n || "centripetal"),
          (this.tension = r || 0.5);
      }
      function th(e, t, n, r, i) {
        var a = 0.5 * (r - t),
          o = 0.5 * (i - n),
          s = e * e;
        return (
          (2 * n - 2 * r + a + o) * (e * s) +
          (-3 * n + 3 * r - 2 * a - o) * s +
          a * e +
          n
        );
      }
      function nh(e, t, n, r) {
        return (
          (function (e, t) {
            var n = 1 - e;
            return n * n * t;
          })(e, t) +
          (function (e, t) {
            return 2 * (1 - e) * e * t;
          })(e, n) +
          (function (e, t) {
            return e * e * t;
          })(e, r)
        );
      }
      function rh(e, t, n, r, i) {
        return (
          (function (e, t) {
            var n = 1 - e;
            return n * n * n * t;
          })(e, t) +
          (function (e, t) {
            var n = 1 - e;
            return 3 * n * n * e * t;
          })(e, n) +
          (function (e, t) {
            return 3 * (1 - e) * e * e * t;
          })(e, r) +
          (function (e, t) {
            return e * e * e * t;
          })(e, i)
        );
      }
      function ih(e, t, n, r) {
        ql.call(this),
          (this.type = "CubicBezierCurve"),
          (this.v0 = e || new Hn()),
          (this.v1 = t || new Hn()),
          (this.v2 = n || new Hn()),
          (this.v3 = r || new Hn());
      }
      function ah(e, t, n, r) {
        ql.call(this),
          (this.type = "CubicBezierCurve3"),
          (this.v0 = e || new $n()),
          (this.v1 = t || new $n()),
          (this.v2 = n || new $n()),
          (this.v3 = r || new $n());
      }
      function oh(e, t) {
        ql.call(this),
          (this.type = "LineCurve"),
          (this.v1 = e || new Hn()),
          (this.v2 = t || new Hn());
      }
      function sh(e, t) {
        ql.call(this),
          (this.type = "LineCurve3"),
          (this.v1 = e || new $n()),
          (this.v2 = t || new $n());
      }
      function ch(e, t, n) {
        ql.call(this),
          (this.type = "QuadraticBezierCurve"),
          (this.v0 = e || new Hn()),
          (this.v1 = t || new Hn()),
          (this.v2 = n || new Hn());
      }
      function uh(e, t, n) {
        ql.call(this),
          (this.type = "QuadraticBezierCurve3"),
          (this.v0 = e || new $n()),
          (this.v1 = t || new $n()),
          (this.v2 = n || new $n());
      }
      function lh(e) {
        ql.call(this), (this.type = "SplineCurve"), (this.points = e || []);
      }
      ((eh.prototype = Object.create(ql.prototype)).constructor = eh),
        (eh.prototype.isCatmullRomCurve3 = !0),
        (eh.prototype.getPoint = function (e, t) {
          var n,
            r,
            i,
            a,
            o = t || new $n(),
            s = this.points,
            c = s.length,
            u = (c - (this.closed ? 0 : 1)) * e,
            l = Math.floor(u),
            h = u - l;
          if (
            (this.closed
              ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c)
              : 0 === h && l === c - 1 && ((l = c - 2), (h = 1)),
            this.closed || l > 0
              ? (n = s[(l - 1) % c])
              : (Jl.subVectors(s[0], s[1]).add(s[0]), (n = Jl)),
            (r = s[l % c]),
            (i = s[(l + 1) % c]),
            this.closed || l + 2 < c
              ? (a = s[(l + 2) % c])
              : (Jl.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), (a = Jl)),
            "centripetal" === this.curveType || "chordal" === this.curveType)
          ) {
            var d = "chordal" === this.curveType ? 0.5 : 0.25,
              p = Math.pow(n.distanceToSquared(r), d),
              f = Math.pow(r.distanceToSquared(i), d),
              m = Math.pow(i.distanceToSquared(a), d);
            f < 1e-4 && (f = 1),
              p < 1e-4 && (p = f),
              m < 1e-4 && (m = f),
              Kl.initNonuniformCatmullRom(n.x, r.x, i.x, a.x, p, f, m),
              Ql.initNonuniformCatmullRom(n.y, r.y, i.y, a.y, p, f, m),
              $l.initNonuniformCatmullRom(n.z, r.z, i.z, a.z, p, f, m);
          } else
            "catmullrom" === this.curveType &&
              (Kl.initCatmullRom(n.x, r.x, i.x, a.x, this.tension),
              Ql.initCatmullRom(n.y, r.y, i.y, a.y, this.tension),
              $l.initCatmullRom(n.z, r.z, i.z, a.z, this.tension));
          return o.set(Kl.calc(h), Ql.calc(h), $l.calc(h)), o;
        }),
        (eh.prototype.copy = function (e) {
          ql.prototype.copy.call(this, e), (this.points = []);
          for (var t = 0, n = e.points.length; t < n; t++)
            this.points.push(e.points[t].clone());
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }),
        (eh.prototype.toJSON = function () {
          var e = ql.prototype.toJSON.call(this);
          e.points = [];
          for (var t = 0, n = this.points.length; t < n; t++)
            e.points.push(this.points[t].toArray());
          return (
            (e.closed = this.closed),
            (e.curveType = this.curveType),
            (e.tension = this.tension),
            e
          );
        }),
        (eh.prototype.fromJSON = function (e) {
          ql.prototype.fromJSON.call(this, e), (this.points = []);
          for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push(new $n().fromArray(r));
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }),
        ((ih.prototype = Object.create(ql.prototype)).constructor = ih),
        (ih.prototype.isCubicBezierCurve = !0),
        (ih.prototype.getPoint = function (e, t) {
          var n = t || new Hn(),
            r = this.v0,
            i = this.v1,
            a = this.v2,
            o = this.v3;
          return n.set(rh(e, r.x, i.x, a.x, o.x), rh(e, r.y, i.y, a.y, o.y)), n;
        }),
        (ih.prototype.copy = function (e) {
          return (
            ql.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }),
        (ih.prototype.toJSON = function () {
          var e = ql.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }),
        (ih.prototype.fromJSON = function (e) {
          return (
            ql.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }),
        ((ah.prototype = Object.create(ql.prototype)).constructor = ah),
        (ah.prototype.isCubicBezierCurve3 = !0),
        (ah.prototype.getPoint = function (e, t) {
          var n = t || new $n(),
            r = this.v0,
            i = this.v1,
            a = this.v2,
            o = this.v3;
          return (
            n.set(
              rh(e, r.x, i.x, a.x, o.x),
              rh(e, r.y, i.y, a.y, o.y),
              rh(e, r.z, i.z, a.z, o.z)
            ),
            n
          );
        }),
        (ah.prototype.copy = function (e) {
          return (
            ql.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }),
        (ah.prototype.toJSON = function () {
          var e = ql.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }),
        (ah.prototype.fromJSON = function (e) {
          return (
            ql.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }),
        ((oh.prototype = Object.create(ql.prototype)).constructor = oh),
        (oh.prototype.isLineCurve = !0),
        (oh.prototype.getPoint = function (e, t) {
          var n = t || new Hn();
          return (
            1 === e
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }),
        (oh.prototype.getPointAt = function (e, t) {
          return this.getPoint(e, t);
        }),
        (oh.prototype.getTangent = function (e, t) {
          var n = t || new Hn();
          return n.copy(this.v2).sub(this.v1).normalize(), n;
        }),
        (oh.prototype.copy = function (e) {
          return (
            ql.prototype.copy.call(this, e),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }),
        (oh.prototype.toJSON = function () {
          var e = ql.prototype.toJSON.call(this);
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }),
        (oh.prototype.fromJSON = function (e) {
          return (
            ql.prototype.fromJSON.call(this, e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        ((sh.prototype = Object.create(ql.prototype)).constructor = sh),
        (sh.prototype.isLineCurve3 = !0),
        (sh.prototype.getPoint = function (e, t) {
          var n = t || new $n();
          return (
            1 === e
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }),
        (sh.prototype.getPointAt = function (e, t) {
          return this.getPoint(e, t);
        }),
        (sh.prototype.copy = function (e) {
          return (
            ql.prototype.copy.call(this, e),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }),
        (sh.prototype.toJSON = function () {
          var e = ql.prototype.toJSON.call(this);
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }),
        (sh.prototype.fromJSON = function (e) {
          return (
            ql.prototype.fromJSON.call(this, e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        ((ch.prototype = Object.create(ql.prototype)).constructor = ch),
        (ch.prototype.isQuadraticBezierCurve = !0),
        (ch.prototype.getPoint = function (e, t) {
          var n = t || new Hn(),
            r = this.v0,
            i = this.v1,
            a = this.v2;
          return n.set(nh(e, r.x, i.x, a.x), nh(e, r.y, i.y, a.y)), n;
        }),
        (ch.prototype.copy = function (e) {
          return (
            ql.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }),
        (ch.prototype.toJSON = function () {
          var e = ql.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }),
        (ch.prototype.fromJSON = function (e) {
          return (
            ql.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        ((uh.prototype = Object.create(ql.prototype)).constructor = uh),
        (uh.prototype.isQuadraticBezierCurve3 = !0),
        (uh.prototype.getPoint = function (e, t) {
          var n = t || new $n(),
            r = this.v0,
            i = this.v1,
            a = this.v2;
          return (
            n.set(
              nh(e, r.x, i.x, a.x),
              nh(e, r.y, i.y, a.y),
              nh(e, r.z, i.z, a.z)
            ),
            n
          );
        }),
        (uh.prototype.copy = function (e) {
          return (
            ql.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }),
        (uh.prototype.toJSON = function () {
          var e = ql.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }),
        (uh.prototype.fromJSON = function (e) {
          return (
            ql.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        ((lh.prototype = Object.create(ql.prototype)).constructor = lh),
        (lh.prototype.isSplineCurve = !0),
        (lh.prototype.getPoint = function (e, t) {
          var n = t || new Hn(),
            r = this.points,
            i = (r.length - 1) * e,
            a = Math.floor(i),
            o = i - a,
            s = r[0 === a ? a : a - 1],
            c = r[a],
            u = r[a > r.length - 2 ? r.length - 1 : a + 1],
            l = r[a > r.length - 3 ? r.length - 1 : a + 2];
          return n.set(th(o, s.x, c.x, u.x, l.x), th(o, s.y, c.y, u.y, l.y)), n;
        }),
        (lh.prototype.copy = function (e) {
          ql.prototype.copy.call(this, e), (this.points = []);
          for (var t = 0, n = e.points.length; t < n; t++)
            this.points.push(e.points[t].clone());
          return this;
        }),
        (lh.prototype.toJSON = function () {
          var e = ql.prototype.toJSON.call(this);
          e.points = [];
          for (var t = 0, n = this.points.length; t < n; t++)
            e.points.push(this.points[t].toArray());
          return e;
        }),
        (lh.prototype.fromJSON = function (e) {
          ql.prototype.fromJSON.call(this, e), (this.points = []);
          for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push(new Hn().fromArray(r));
          }
          return this;
        });
      var hh = Object.freeze({
        __proto__: null,
        ArcCurve: Yl,
        CatmullRomCurve3: eh,
        CubicBezierCurve: ih,
        CubicBezierCurve3: ah,
        EllipseCurve: Xl,
        LineCurve: oh,
        LineCurve3: sh,
        QuadraticBezierCurve: ch,
        QuadraticBezierCurve3: uh,
        SplineCurve: lh,
      });
      function dh() {
        ql.call(this),
          (this.type = "CurvePath"),
          (this.curves = []),
          (this.autoClose = !1);
      }
      function ph(e) {
        dh.call(this),
          (this.type = "Path"),
          (this.currentPoint = new Hn()),
          e && this.setFromPoints(e);
      }
      function fh(e) {
        ph.call(this, e),
          (this.uuid = kn.generateUUID()),
          (this.type = "Shape"),
          (this.holes = []);
      }
      function mh(e, t) {
        Tr.call(this),
          (this.type = "Light"),
          (this.color = new vi(e)),
          (this.intensity = void 0 !== t ? t : 1),
          (this.receiveShadow = void 0);
      }
      function vh(e, t, n) {
        mh.call(this, e, n),
          (this.type = "HemisphereLight"),
          (this.castShadow = void 0),
          this.position.copy(Tr.DefaultUp),
          this.updateMatrix(),
          (this.groundColor = new vi(t));
      }
      function gh(e) {
        (this.camera = e),
          (this.bias = 0),
          (this.normalBias = 0),
          (this.radius = 1),
          (this.mapSize = new Hn(512, 512)),
          (this.map = null),
          (this.mapPass = null),
          (this.matrix = new sr()),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this._frustum = new Ra()),
          (this._frameExtents = new Hn(1, 1)),
          (this._viewportCount = 1),
          (this._viewports = [new Xn(0, 0, 1, 1)]);
      }
      function yh() {
        gh.call(this, new Sa(50, 1, 0.5, 500));
      }
      function xh(e, t, n, r, i, a) {
        mh.call(this, e, t),
          (this.type = "SpotLight"),
          this.position.copy(Tr.DefaultUp),
          this.updateMatrix(),
          (this.target = new Tr()),
          Object.defineProperty(this, "power", {
            get: function () {
              return this.intensity * Math.PI;
            },
            set: function (e) {
              this.intensity = e / Math.PI;
            },
          }),
          (this.distance = void 0 !== n ? n : 0),
          (this.angle = void 0 !== r ? r : Math.PI / 3),
          (this.penumbra = void 0 !== i ? i : 0),
          (this.decay = void 0 !== a ? a : 1),
          (this.shadow = new yh());
      }
      function bh() {
        gh.call(this, new Sa(90, 1, 0.5, 500)),
          (this._frameExtents = new Hn(4, 2)),
          (this._viewportCount = 6),
          (this._viewports = [
            new Xn(2, 1, 1, 1),
            new Xn(0, 1, 1, 1),
            new Xn(3, 1, 1, 1),
            new Xn(1, 1, 1, 1),
            new Xn(3, 0, 1, 1),
            new Xn(1, 0, 1, 1),
          ]),
          (this._cubeDirections = [
            new $n(1, 0, 0),
            new $n(-1, 0, 0),
            new $n(0, 0, 1),
            new $n(0, 0, -1),
            new $n(0, 1, 0),
            new $n(0, -1, 0),
          ]),
          (this._cubeUps = [
            new $n(0, 1, 0),
            new $n(0, 1, 0),
            new $n(0, 1, 0),
            new $n(0, 1, 0),
            new $n(0, 0, 1),
            new $n(0, 0, -1),
          ]);
      }
      function _h(e, t, n, r) {
        mh.call(this, e, t),
          (this.type = "PointLight"),
          Object.defineProperty(this, "power", {
            get: function () {
              return 4 * this.intensity * Math.PI;
            },
            set: function (e) {
              this.intensity = e / (4 * Math.PI);
            },
          }),
          (this.distance = void 0 !== n ? n : 0),
          (this.decay = void 0 !== r ? r : 1),
          (this.shadow = new bh());
      }
      function wh(e, t, n, r, i, a) {
        Ma.call(this),
          (this.type = "OrthographicCamera"),
          (this.zoom = 1),
          (this.view = null),
          (this.left = void 0 !== e ? e : -1),
          (this.right = void 0 !== t ? t : 1),
          (this.top = void 0 !== n ? n : 1),
          (this.bottom = void 0 !== r ? r : -1),
          (this.near = void 0 !== i ? i : 0.1),
          (this.far = void 0 !== a ? a : 2e3),
          this.updateProjectionMatrix();
      }
      function Mh() {
        gh.call(this, new wh(-5, 5, 5, -5, 0.5, 500));
      }
      function Sh(e, t) {
        mh.call(this, e, t),
          (this.type = "DirectionalLight"),
          this.position.copy(Tr.DefaultUp),
          this.updateMatrix(),
          (this.target = new Tr()),
          (this.shadow = new Mh());
      }
      function Th(e, t) {
        mh.call(this, e, t),
          (this.type = "AmbientLight"),
          (this.castShadow = void 0);
      }
      function Eh(e, t, n, r) {
        mh.call(this, e, t),
          (this.type = "RectAreaLight"),
          (this.width = void 0 !== n ? n : 10),
          (this.height = void 0 !== r ? r : 10);
      }
      function Ah() {
        this.coefficients = [];
        for (var e = 0; e < 9; e++) this.coefficients.push(new $n());
      }
      function Lh(e, t) {
        mh.call(this, void 0, t),
          (this.type = "LightProbe"),
          (this.sh = void 0 !== e ? e : new Ah());
      }
      function Ch(e) {
        zl.call(this, e), (this.textures = {});
      }
      (dh.prototype = Object.assign(Object.create(ql.prototype), {
        constructor: dh,
        add: function (e) {
          this.curves.push(e);
        },
        closePath: function () {
          var e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
          e.equals(t) || this.curves.push(new oh(t, e));
        },
        getPoint: function (e) {
          for (
            var t = e * this.getLength(), n = this.getCurveLengths(), r = 0;
            r < n.length;

          ) {
            if (n[r] >= t) {
              var i = n[r] - t,
                a = this.curves[r],
                o = a.getLength();
              return a.getPointAt(0 === o ? 0 : 1 - i / o);
            }
            r++;
          }
          return null;
        },
        getLength: function () {
          var e = this.getCurveLengths();
          return e[e.length - 1];
        },
        updateArcLengths: function () {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        },
        getCurveLengths: function () {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++)
            (t += this.curves[n].getLength()), e.push(t);
          return (this.cacheLengths = e), e;
        },
        getSpacedPoints: function (e) {
          void 0 === e && (e = 40);
          for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return this.autoClose && t.push(t[0]), t;
        },
        getPoints: function (e) {
          e = e || 12;
          for (var t, n = [], r = 0, i = this.curves; r < i.length; r++)
            for (
              var a = i[r],
                o = a.getPoints(
                  a && a.isEllipseCurve
                    ? 2 * e
                    : a && (a.isLineCurve || a.isLineCurve3)
                    ? 1
                    : a && a.isSplineCurve
                    ? e * a.points.length
                    : e
                ),
                s = 0;
              s < o.length;
              s++
            ) {
              var c = o[s];
              (t && t.equals(c)) || (n.push(c), (t = c));
            }
          return (
            this.autoClose &&
              n.length > 1 &&
              !n[n.length - 1].equals(n[0]) &&
              n.push(n[0]),
            n
          );
        },
        copy: function (e) {
          ql.prototype.copy.call(this, e), (this.curves = []);
          for (var t = 0, n = e.curves.length; t < n; t++)
            this.curves.push(e.curves[t].clone());
          return (this.autoClose = e.autoClose), this;
        },
        toJSON: function () {
          var e = ql.prototype.toJSON.call(this);
          (e.autoClose = this.autoClose), (e.curves = []);
          for (var t = 0, n = this.curves.length; t < n; t++)
            e.curves.push(this.curves[t].toJSON());
          return e;
        },
        fromJSON: function (e) {
          ql.prototype.fromJSON.call(this, e),
            (this.autoClose = e.autoClose),
            (this.curves = []);
          for (var t = 0, n = e.curves.length; t < n; t++) {
            var r = e.curves[t];
            this.curves.push(new hh[r.type]().fromJSON(r));
          }
          return this;
        },
      })),
        (ph.prototype = Object.assign(Object.create(dh.prototype), {
          constructor: ph,
          setFromPoints: function (e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, n = e.length; t < n; t++)
              this.lineTo(e[t].x, e[t].y);
            return this;
          },
          moveTo: function (e, t) {
            return this.currentPoint.set(e, t), this;
          },
          lineTo: function (e, t) {
            var n = new oh(this.currentPoint.clone(), new Hn(e, t));
            return this.curves.push(n), this.currentPoint.set(e, t), this;
          },
          quadraticCurveTo: function (e, t, n, r) {
            var i = new ch(
              this.currentPoint.clone(),
              new Hn(e, t),
              new Hn(n, r)
            );
            return this.curves.push(i), this.currentPoint.set(n, r), this;
          },
          bezierCurveTo: function (e, t, n, r, i, a) {
            var o = new ih(
              this.currentPoint.clone(),
              new Hn(e, t),
              new Hn(n, r),
              new Hn(i, a)
            );
            return this.curves.push(o), this.currentPoint.set(i, a), this;
          },
          splineThru: function (e) {
            var t = new lh([this.currentPoint.clone()].concat(e));
            return (
              this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this
            );
          },
          arc: function (e, t, n, r, i, a) {
            return (
              this.absarc(
                e + this.currentPoint.x,
                t + this.currentPoint.y,
                n,
                r,
                i,
                a
              ),
              this
            );
          },
          absarc: function (e, t, n, r, i, a) {
            return this.absellipse(e, t, n, n, r, i, a), this;
          },
          ellipse: function (e, t, n, r, i, a, o, s) {
            return (
              this.absellipse(
                e + this.currentPoint.x,
                t + this.currentPoint.y,
                n,
                r,
                i,
                a,
                o,
                s
              ),
              this
            );
          },
          absellipse: function (e, t, n, r, i, a, o, s) {
            var c = new Xl(e, t, n, r, i, a, o, s);
            if (this.curves.length > 0) {
              var u = c.getPoint(0);
              u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
            }
            this.curves.push(c);
            var l = c.getPoint(1);
            return this.currentPoint.copy(l), this;
          },
          copy: function (e) {
            return (
              dh.prototype.copy.call(this, e),
              this.currentPoint.copy(e.currentPoint),
              this
            );
          },
          toJSON: function () {
            var e = dh.prototype.toJSON.call(this);
            return (e.currentPoint = this.currentPoint.toArray()), e;
          },
          fromJSON: function (e) {
            return (
              dh.prototype.fromJSON.call(this, e),
              this.currentPoint.fromArray(e.currentPoint),
              this
            );
          },
        })),
        (fh.prototype = Object.assign(Object.create(ph.prototype), {
          constructor: fh,
          getPointsHoles: function (e) {
            for (var t = [], n = 0, r = this.holes.length; n < r; n++)
              t[n] = this.holes[n].getPoints(e);
            return t;
          },
          extractPoints: function (e) {
            return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
          },
          copy: function (e) {
            ph.prototype.copy.call(this, e), (this.holes = []);
            for (var t = 0, n = e.holes.length; t < n; t++)
              this.holes.push(e.holes[t].clone());
            return this;
          },
          toJSON: function () {
            var e = ph.prototype.toJSON.call(this);
            (e.uuid = this.uuid), (e.holes = []);
            for (var t = 0, n = this.holes.length; t < n; t++)
              e.holes.push(this.holes[t].toJSON());
            return e;
          },
          fromJSON: function (e) {
            ph.prototype.fromJSON.call(this, e),
              (this.uuid = e.uuid),
              (this.holes = []);
            for (var t = 0, n = e.holes.length; t < n; t++) {
              var r = e.holes[t];
              this.holes.push(new ph().fromJSON(r));
            }
            return this;
          },
        })),
        (mh.prototype = Object.assign(Object.create(Tr.prototype), {
          constructor: mh,
          isLight: !0,
          copy: function (e) {
            return (
              Tr.prototype.copy.call(this, e),
              this.color.copy(e.color),
              (this.intensity = e.intensity),
              this
            );
          },
          toJSON: function (e) {
            var t = Tr.prototype.toJSON.call(this, e);
            return (
              (t.object.color = this.color.getHex()),
              (t.object.intensity = this.intensity),
              void 0 !== this.groundColor &&
                (t.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (t.object.distance = this.distance),
              void 0 !== this.angle && (t.object.angle = this.angle),
              void 0 !== this.decay && (t.object.decay = this.decay),
              void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
              void 0 !== this.shadow &&
                (t.object.shadow = this.shadow.toJSON()),
              t
            );
          },
        })),
        (vh.prototype = Object.assign(Object.create(mh.prototype), {
          constructor: vh,
          isHemisphereLight: !0,
          copy: function (e) {
            return (
              mh.prototype.copy.call(this, e),
              this.groundColor.copy(e.groundColor),
              this
            );
          },
        })),
        Object.assign(gh.prototype, {
          _projScreenMatrix: new sr(),
          _lightPositionWorld: new $n(),
          _lookTarget: new $n(),
          getViewportCount: function () {
            return this._viewportCount;
          },
          getFrustum: function () {
            return this._frustum;
          },
          updateMatrices: function (e) {
            var t = this.camera,
              n = this.matrix,
              r = this._projScreenMatrix,
              i = this._lookTarget,
              a = this._lightPositionWorld;
            a.setFromMatrixPosition(e.matrixWorld),
              t.position.copy(a),
              i.setFromMatrixPosition(e.target.matrixWorld),
              t.lookAt(i),
              t.updateMatrixWorld(),
              r.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(r),
              n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              n.multiply(t.projectionMatrix),
              n.multiply(t.matrixWorldInverse);
          },
          getViewport: function (e) {
            return this._viewports[e];
          },
          getFrameExtents: function () {
            return this._frameExtents;
          },
          copy: function (e) {
            return (
              (this.camera = e.camera.clone()),
              (this.bias = e.bias),
              (this.radius = e.radius),
              this.mapSize.copy(e.mapSize),
              this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          toJSON: function () {
            var e = {};
            return (
              0 !== this.bias && (e.bias = this.bias),
              0 !== this.normalBias && (e.normalBias = this.normalBias),
              1 !== this.radius && (e.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                (e.mapSize = this.mapSize.toArray()),
              (e.camera = this.camera.toJSON(!1).object),
              delete e.camera.matrix,
              e
            );
          },
        }),
        (yh.prototype = Object.assign(Object.create(gh.prototype), {
          constructor: yh,
          isSpotLightShadow: !0,
          updateMatrices: function (e) {
            var t = this.camera,
              n = 2 * kn.RAD2DEG * e.angle,
              r = this.mapSize.width / this.mapSize.height,
              i = e.distance || t.far;
            (n === t.fov && r === t.aspect && i === t.far) ||
              ((t.fov = n),
              (t.aspect = r),
              (t.far = i),
              t.updateProjectionMatrix()),
              gh.prototype.updateMatrices.call(this, e);
          },
        })),
        (xh.prototype = Object.assign(Object.create(mh.prototype), {
          constructor: xh,
          isSpotLight: !0,
          copy: function (e) {
            return (
              mh.prototype.copy.call(this, e),
              (this.distance = e.distance),
              (this.angle = e.angle),
              (this.penumbra = e.penumbra),
              (this.decay = e.decay),
              (this.target = e.target.clone()),
              (this.shadow = e.shadow.clone()),
              this
            );
          },
        })),
        (bh.prototype = Object.assign(Object.create(gh.prototype), {
          constructor: bh,
          isPointLightShadow: !0,
          updateMatrices: function (e, t) {
            void 0 === t && (t = 0);
            var n = this.camera,
              r = this.matrix,
              i = this._lightPositionWorld,
              a = this._lookTarget,
              o = this._projScreenMatrix;
            i.setFromMatrixPosition(e.matrixWorld),
              n.position.copy(i),
              a.copy(n.position),
              a.add(this._cubeDirections[t]),
              n.up.copy(this._cubeUps[t]),
              n.lookAt(a),
              n.updateMatrixWorld(),
              r.makeTranslation(-i.x, -i.y, -i.z),
              o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(o);
          },
        })),
        (_h.prototype = Object.assign(Object.create(mh.prototype), {
          constructor: _h,
          isPointLight: !0,
          copy: function (e) {
            return (
              mh.prototype.copy.call(this, e),
              (this.distance = e.distance),
              (this.decay = e.decay),
              (this.shadow = e.shadow.clone()),
              this
            );
          },
        })),
        (wh.prototype = Object.assign(Object.create(Ma.prototype), {
          constructor: wh,
          isOrthographicCamera: !0,
          copy: function (e, t) {
            return (
              Ma.prototype.copy.call(this, e, t),
              (this.left = e.left),
              (this.right = e.right),
              (this.top = e.top),
              (this.bottom = e.bottom),
              (this.near = e.near),
              (this.far = e.far),
              (this.zoom = e.zoom),
              (this.view = null === e.view ? null : Object.assign({}, e.view)),
              this
            );
          },
          setViewOffset: function (e, t, n, r, i, a) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = e),
              (this.view.fullHeight = t),
              (this.view.offsetX = n),
              (this.view.offsetY = r),
              (this.view.width = i),
              (this.view.height = a),
              this.updateProjectionMatrix();
          },
          clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          },
          updateProjectionMatrix: function () {
            var e = (this.right - this.left) / (2 * this.zoom),
              t = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              r = (this.top + this.bottom) / 2,
              i = n - e,
              a = n + e,
              o = r + t,
              s = r - t;
            if (null !== this.view && this.view.enabled) {
              var c =
                  (this.right - this.left) / this.view.fullWidth / this.zoom,
                u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              (a = (i += c * this.view.offsetX) + c * this.view.width),
                (s = (o -= u * this.view.offsetY) - u * this.view.height);
            }
            this.projectionMatrix.makeOrthographic(
              i,
              a,
              o,
              s,
              this.near,
              this.far
            ),
              this.projectionMatrixInverse.getInverse(this.projectionMatrix);
          },
          toJSON: function (e) {
            var t = Tr.prototype.toJSON.call(this, e);
            return (
              (t.object.zoom = this.zoom),
              (t.object.left = this.left),
              (t.object.right = this.right),
              (t.object.top = this.top),
              (t.object.bottom = this.bottom),
              (t.object.near = this.near),
              (t.object.far = this.far),
              null !== this.view &&
                (t.object.view = Object.assign({}, this.view)),
              t
            );
          },
        })),
        (Mh.prototype = Object.assign(Object.create(gh.prototype), {
          constructor: Mh,
          isDirectionalLightShadow: !0,
          updateMatrices: function (e) {
            gh.prototype.updateMatrices.call(this, e);
          },
        })),
        (Sh.prototype = Object.assign(Object.create(mh.prototype), {
          constructor: Sh,
          isDirectionalLight: !0,
          copy: function (e) {
            return (
              mh.prototype.copy.call(this, e),
              (this.target = e.target.clone()),
              (this.shadow = e.shadow.clone()),
              this
            );
          },
        })),
        (Th.prototype = Object.assign(Object.create(mh.prototype), {
          constructor: Th,
          isAmbientLight: !0,
        })),
        (Eh.prototype = Object.assign(Object.create(mh.prototype), {
          constructor: Eh,
          isRectAreaLight: !0,
          copy: function (e) {
            return (
              mh.prototype.copy.call(this, e),
              (this.width = e.width),
              (this.height = e.height),
              this
            );
          },
          toJSON: function (e) {
            var t = mh.prototype.toJSON.call(this, e);
            return (
              (t.object.width = this.width), (t.object.height = this.height), t
            );
          },
        })),
        Object.assign(Ah.prototype, {
          isSphericalHarmonics3: !0,
          set: function (e) {
            for (var t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
            return this;
          },
          zero: function () {
            for (var e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
            return this;
          },
          getAt: function (e, t) {
            var n = e.x,
              r = e.y,
              i = e.z,
              a = this.coefficients;
            return (
              t.copy(a[0]).multiplyScalar(0.282095),
              t.addScaledVector(a[1], 0.488603 * r),
              t.addScaledVector(a[2], 0.488603 * i),
              t.addScaledVector(a[3], 0.488603 * n),
              t.addScaledVector(a[4], n * r * 1.092548),
              t.addScaledVector(a[5], r * i * 1.092548),
              t.addScaledVector(a[6], 0.315392 * (3 * i * i - 1)),
              t.addScaledVector(a[7], n * i * 1.092548),
              t.addScaledVector(a[8], 0.546274 * (n * n - r * r)),
              t
            );
          },
          getIrradianceAt: function (e, t) {
            var n = e.x,
              r = e.y,
              i = e.z,
              a = this.coefficients;
            return (
              t.copy(a[0]).multiplyScalar(0.886227),
              t.addScaledVector(a[1], 1.023328 * r),
              t.addScaledVector(a[2], 1.023328 * i),
              t.addScaledVector(a[3], 1.023328 * n),
              t.addScaledVector(a[4], 0.858086 * n * r),
              t.addScaledVector(a[5], 0.858086 * r * i),
              t.addScaledVector(a[6], 0.743125 * i * i - 0.247708),
              t.addScaledVector(a[7], 0.858086 * n * i),
              t.addScaledVector(a[8], 0.429043 * (n * n - r * r)),
              t
            );
          },
          add: function (e) {
            for (var t = 0; t < 9; t++)
              this.coefficients[t].add(e.coefficients[t]);
            return this;
          },
          addScaledSH: function (e, t) {
            for (var n = 0; n < 9; n++)
              this.coefficients[n].addScaledVector(e.coefficients[n], t);
            return this;
          },
          scale: function (e) {
            for (var t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
            return this;
          },
          lerp: function (e, t) {
            for (var n = 0; n < 9; n++)
              this.coefficients[n].lerp(e.coefficients[n], t);
            return this;
          },
          equals: function (e) {
            for (var t = 0; t < 9; t++)
              if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
            return !0;
          },
          copy: function (e) {
            return this.set(e.coefficients);
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var n = this.coefficients, r = 0; r < 9; r++)
              n[r].fromArray(e, t + 3 * r);
            return this;
          },
          toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            for (var n = this.coefficients, r = 0; r < 9; r++)
              n[r].toArray(e, t + 3 * r);
            return e;
          },
        }),
        Object.assign(Ah, {
          getBasisAt: function (e, t) {
            var n = e.x,
              r = e.y,
              i = e.z;
            (t[0] = 0.282095),
              (t[1] = 0.488603 * r),
              (t[2] = 0.488603 * i),
              (t[3] = 0.488603 * n),
              (t[4] = 1.092548 * n * r),
              (t[5] = 1.092548 * r * i),
              (t[6] = 0.315392 * (3 * i * i - 1)),
              (t[7] = 1.092548 * n * i),
              (t[8] = 0.546274 * (n * n - r * r));
          },
        }),
        (Lh.prototype = Object.assign(Object.create(mh.prototype), {
          constructor: Lh,
          isLightProbe: !0,
          copy: function (e) {
            return mh.prototype.copy.call(this, e), this.sh.copy(e.sh), this;
          },
          fromJSON: function (e) {
            return (
              (this.intensity = e.intensity), this.sh.fromArray(e.sh), this
            );
          },
          toJSON: function (e) {
            var t = mh.prototype.toJSON.call(this, e);
            return (t.object.sh = this.sh.toArray()), t;
          },
        })),
        (Ch.prototype = Object.assign(Object.create(zl.prototype), {
          constructor: Ch,
          load: function (e, t, n, r) {
            var i = this,
              a = new Ul(i.manager);
            a.setPath(i.path),
              a.load(
                e,
                function (n) {
                  try {
                    t(i.parse(JSON.parse(n)));
                  } catch (a) {
                    r ? r(a) : console.error(a), i.manager.itemError(e);
                  }
                },
                n,
                r
              );
          },
          parse: function (e) {
            var t = this.textures;
            function n(e) {
              return (
                void 0 === t[e] &&
                  console.warn("THREE.MaterialLoader: Undefined texture", e),
                t[e]
              );
            }
            var r = new yl[e.type]();
            if (
              (void 0 !== e.uuid && (r.uuid = e.uuid),
              void 0 !== e.name && (r.name = e.name),
              void 0 !== e.color && r.color.setHex(e.color),
              void 0 !== e.roughness && (r.roughness = e.roughness),
              void 0 !== e.metalness && (r.metalness = e.metalness),
              void 0 !== e.sheen && (r.sheen = new vi().setHex(e.sheen)),
              void 0 !== e.emissive && r.emissive.setHex(e.emissive),
              void 0 !== e.specular && r.specular.setHex(e.specular),
              void 0 !== e.shininess && (r.shininess = e.shininess),
              void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat),
              void 0 !== e.clearcoatRoughness &&
                (r.clearcoatRoughness = e.clearcoatRoughness),
              void 0 !== e.fog && (r.fog = e.fog),
              void 0 !== e.flatShading && (r.flatShading = e.flatShading),
              void 0 !== e.blending && (r.blending = e.blending),
              void 0 !== e.combine && (r.combine = e.combine),
              void 0 !== e.side && (r.side = e.side),
              void 0 !== e.opacity && (r.opacity = e.opacity),
              void 0 !== e.transparent && (r.transparent = e.transparent),
              void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest),
              void 0 !== e.depthTest && (r.depthTest = e.depthTest),
              void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite),
              void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite),
              void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite),
              void 0 !== e.stencilWriteMask &&
                (r.stencilWriteMask = e.stencilWriteMask),
              void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc),
              void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef),
              void 0 !== e.stencilFuncMask &&
                (r.stencilFuncMask = e.stencilFuncMask),
              void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail),
              void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail),
              void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass),
              void 0 !== e.wireframe && (r.wireframe = e.wireframe),
              void 0 !== e.wireframeLinewidth &&
                (r.wireframeLinewidth = e.wireframeLinewidth),
              void 0 !== e.wireframeLinecap &&
                (r.wireframeLinecap = e.wireframeLinecap),
              void 0 !== e.wireframeLinejoin &&
                (r.wireframeLinejoin = e.wireframeLinejoin),
              void 0 !== e.rotation && (r.rotation = e.rotation),
              1 !== e.linewidth && (r.linewidth = e.linewidth),
              void 0 !== e.dashSize && (r.dashSize = e.dashSize),
              void 0 !== e.gapSize && (r.gapSize = e.gapSize),
              void 0 !== e.scale && (r.scale = e.scale),
              void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset),
              void 0 !== e.polygonOffsetFactor &&
                (r.polygonOffsetFactor = e.polygonOffsetFactor),
              void 0 !== e.polygonOffsetUnits &&
                (r.polygonOffsetUnits = e.polygonOffsetUnits),
              void 0 !== e.skinning && (r.skinning = e.skinning),
              void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets),
              void 0 !== e.morphNormals && (r.morphNormals = e.morphNormals),
              void 0 !== e.dithering && (r.dithering = e.dithering),
              void 0 !== e.vertexTangents &&
                (r.vertexTangents = e.vertexTangents),
              void 0 !== e.visible && (r.visible = e.visible),
              void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped),
              void 0 !== e.userData && (r.userData = e.userData),
              void 0 !== e.vertexColors &&
                (r.vertexColors =
                  "number" == typeof e.vertexColors
                    ? e.vertexColors > 0
                    : e.vertexColors),
              void 0 !== e.uniforms)
            )
              for (var i in e.uniforms) {
                var a = e.uniforms[i];
                switch (((r.uniforms[i] = {}), a.type)) {
                  case "t":
                    r.uniforms[i].value = n(a.value);
                    break;
                  case "c":
                    r.uniforms[i].value = new vi().setHex(a.value);
                    break;
                  case "v2":
                    r.uniforms[i].value = new Hn().fromArray(a.value);
                    break;
                  case "v3":
                    r.uniforms[i].value = new $n().fromArray(a.value);
                    break;
                  case "v4":
                    r.uniforms[i].value = new Xn().fromArray(a.value);
                    break;
                  case "m3":
                    r.uniforms[i].value = new jn().fromArray(a.value);
                  case "m4":
                    r.uniforms[i].value = new sr().fromArray(a.value);
                    break;
                  default:
                    r.uniforms[i].value = a.value;
                }
              }
            if (
              (void 0 !== e.defines && (r.defines = e.defines),
              void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader),
              void 0 !== e.fragmentShader &&
                (r.fragmentShader = e.fragmentShader),
              void 0 !== e.extensions)
            )
              for (var o in e.extensions) r.extensions[o] = e.extensions[o];
            if (
              (void 0 !== e.shading && (r.flatShading = 1 === e.shading),
              void 0 !== e.size && (r.size = e.size),
              void 0 !== e.sizeAttenuation &&
                (r.sizeAttenuation = e.sizeAttenuation),
              void 0 !== e.map && (r.map = n(e.map)),
              void 0 !== e.matcap && (r.matcap = n(e.matcap)),
              void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)),
              void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)),
              void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale),
              void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)),
              void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType),
              void 0 !== e.normalScale)
            ) {
              var s = e.normalScale;
              !1 === Array.isArray(s) && (s = [s, s]),
                (r.normalScale = new Hn().fromArray(s));
            }
            return (
              void 0 !== e.displacementMap &&
                (r.displacementMap = n(e.displacementMap)),
              void 0 !== e.displacementScale &&
                (r.displacementScale = e.displacementScale),
              void 0 !== e.displacementBias &&
                (r.displacementBias = e.displacementBias),
              void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)),
              void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)),
              void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)),
              void 0 !== e.emissiveIntensity &&
                (r.emissiveIntensity = e.emissiveIntensity),
              void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)),
              void 0 !== e.envMap && (r.envMap = n(e.envMap)),
              void 0 !== e.envMapIntensity &&
                (r.envMapIntensity = e.envMapIntensity),
              void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity),
              void 0 !== e.refractionRatio &&
                (r.refractionRatio = e.refractionRatio),
              void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)),
              void 0 !== e.lightMapIntensity &&
                (r.lightMapIntensity = e.lightMapIntensity),
              void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)),
              void 0 !== e.aoMapIntensity &&
                (r.aoMapIntensity = e.aoMapIntensity),
              void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)),
              void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)),
              void 0 !== e.clearcoatRoughnessMap &&
                (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
              void 0 !== e.clearcoatNormalMap &&
                (r.clearcoatNormalMap = n(e.clearcoatNormalMap)),
              void 0 !== e.clearcoatNormalScale &&
                (r.clearcoatNormalScale = new Hn().fromArray(
                  e.clearcoatNormalScale
                )),
              r
            );
          },
          setTextures: function (e) {
            return (this.textures = e), this;
          },
        }));
      var Rh = {
        decodeText: function (e) {
          if ("undefined" != typeof TextDecoder)
            return new TextDecoder().decode(e);
          for (var t = "", n = 0, r = e.length; n < r; n++)
            t += String.fromCharCode(e[n]);
          try {
            return decodeURIComponent(escape(t));
          } catch (i) {
            return t;
          }
        },
        extractUrlBase: function (e) {
          var t = e.lastIndexOf("/");
          return -1 === t ? "./" : e.substr(0, t + 1);
        },
      };
      function Ph() {
        Wi.call(this),
          (this.type = "InstancedBufferGeometry"),
          (this.instanceCount = 1 / 0);
      }
      function Oh(e, t, n, r) {
        "number" == typeof n &&
          ((r = n),
          (n = !1),
          console.error(
            "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
          )),
          Ei.call(this, e, t, n),
          (this.meshPerAttribute = r || 1);
      }
      function Dh(e) {
        zl.call(this, e);
      }
      (Ph.prototype = Object.assign(Object.create(Wi.prototype), {
        constructor: Ph,
        isInstancedBufferGeometry: !0,
        copy: function (e) {
          return (
            Wi.prototype.copy.call(this, e),
            (this.instanceCount = e.instanceCount),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        toJSON: function () {
          var e = Wi.prototype.toJSON.call(this);
          return (
            (e.instanceCount = this.instanceCount),
            (e.isInstancedBufferGeometry = !0),
            e
          );
        },
      })),
        (Oh.prototype = Object.assign(Object.create(Ei.prototype), {
          constructor: Oh,
          isInstancedBufferAttribute: !0,
          copy: function (e) {
            return (
              Ei.prototype.copy.call(this, e),
              (this.meshPerAttribute = e.meshPerAttribute),
              this
            );
          },
          toJSON: function () {
            var e = Ei.prototype.toJSON.call(this);
            return (
              (e.meshPerAttribute = this.meshPerAttribute),
              (e.isInstancedBufferAttribute = !0),
              e
            );
          },
        })),
        (Dh.prototype = Object.assign(Object.create(zl.prototype), {
          constructor: Dh,
          load: function (e, t, n, r) {
            var i = this,
              a = new Ul(i.manager);
            a.setPath(i.path),
              a.load(
                e,
                function (n) {
                  try {
                    t(i.parse(JSON.parse(n)));
                  } catch (a) {
                    r ? r(a) : console.error(a), i.manager.itemError(e);
                  }
                },
                n,
                r
              );
          },
          parse: function (e) {
            var t = {},
              n = {};
            function r(e, r) {
              if (void 0 !== t[r]) return t[r];
              var i = e.interleavedBuffers[r],
                a = (function (e, t) {
                  if (void 0 !== n[t]) return n[t];
                  var r = new Uint32Array(e.arrayBuffers[t]).buffer;
                  return (n[t] = r), r;
                })(e, i.buffer),
                o = new Hs(new Ih[i.type](a), i.stride);
              return (o.uuid = i.uuid), (t[r] = o), o;
            }
            var i = e.isInstancedBufferGeometry ? new Ph() : new Wi(),
              a = e.data.index;
            if (void 0 !== a) {
              var o = new Ih[a.type](a.array);
              i.setIndex(new Ei(o, 1));
            }
            var s = e.data.attributes;
            for (var c in s) {
              var u = s[c],
                l = void 0;
              if (u.isInterleavedBufferAttribute)
                l = new Ws(
                  r(e.data, u.data),
                  u.itemSize,
                  u.offset,
                  u.normalized
                );
              else {
                var h = new Ih[u.type](u.array);
                l = new (u.isInstancedBufferAttribute ? Oh : Ei)(
                  h,
                  u.itemSize,
                  u.normalized
                );
              }
              void 0 !== u.name && (l.name = u.name), i.setAttribute(c, l);
            }
            var d = e.data.morphAttributes;
            if (d)
              for (var p in d) {
                for (var f = d[p], m = [], v = 0, g = f.length; v < g; v++) {
                  var y = f[v],
                    x = void 0;
                  (x = y.isInterleavedBufferAttribute
                    ? new Ws(
                        r(e.data, y.data),
                        y.itemSize,
                        y.offset,
                        y.normalized
                      )
                    : new Ei(
                        new Ih[y.type](y.array),
                        y.itemSize,
                        y.normalized
                      )),
                    void 0 !== y.name && (x.name = y.name),
                    m.push(x);
                }
                i.morphAttributes[p] = m;
              }
            e.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
            var b = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== b)
              for (var _ = 0, w = b.length; _ !== w; ++_) {
                var M = b[_];
                i.addGroup(M.start, M.count, M.materialIndex);
              }
            var S = e.data.boundingSphere;
            if (void 0 !== S) {
              var T = new $n();
              void 0 !== S.center && T.fromArray(S.center),
                (i.boundingSphere = new jr(T, S.radius));
            }
            return (
              e.name && (i.name = e.name),
              e.userData && (i.userData = e.userData),
              i
            );
          },
        }));
      var Ih = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray:
          "undefined" != typeof Uint8ClampedArray
            ? Uint8ClampedArray
            : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array,
      };
      function Nh(e) {
        zl.call(this, e);
      }
      Nh.prototype = Object.assign(Object.create(zl.prototype), {
        constructor: Nh,
        load: function (e, t, n, r) {
          var i = this,
            a = "" === this.path ? Rh.extractUrlBase(e) : this.path;
          this.resourcePath = this.resourcePath || a;
          var o = new Ul(i.manager);
          o.setPath(this.path),
            o.load(
              e,
              function (n) {
                var a = null;
                try {
                  a = JSON.parse(n);
                } catch (s) {
                  return (
                    void 0 !== r && r(s),
                    void console.error(
                      "THREE:ObjectLoader: Can't parse " + e + ".",
                      s.message
                    )
                  );
                }
                var o = a.metadata;
                void 0 !== o &&
                void 0 !== o.type &&
                "geometry" !== o.type.toLowerCase()
                  ? i.parse(a, t)
                  : console.error("THREE.ObjectLoader: Can't load " + e);
              },
              n,
              r
            );
        },
        parse: function (e, t) {
          var n = this.parseShape(e.shapes),
            r = this.parseGeometries(e.geometries, n),
            i = this.parseImages(e.images, function () {
              void 0 !== t && t(s);
            }),
            a = this.parseTextures(e.textures, i),
            o = this.parseMaterials(e.materials, a),
            s = this.parseObject(e.object, r, o);
          return (
            e.animations && (s.animations = this.parseAnimations(e.animations)),
            (void 0 !== e.images && 0 !== e.images.length) ||
              (void 0 !== t && t(s)),
            s
          );
        },
        parseShape: function (e) {
          var t = {};
          if (void 0 !== e)
            for (var n = 0, r = e.length; n < r; n++) {
              var i = new fh().fromJSON(e[n]);
              t[i.uuid] = i;
            }
          return t;
        },
        parseGeometries: function (e, t) {
          var n,
            r = {};
          if (void 0 !== e)
            for (var i = new Dh(), a = 0, o = e.length; a < o; a++) {
              var s = void 0,
                c = e[a];
              switch (c.type) {
                case "PlaneGeometry":
                case "PlaneBufferGeometry":
                  s = new sl[c.type](
                    c.width,
                    c.height,
                    c.widthSegments,
                    c.heightSegments
                  );
                  break;
                case "BoxGeometry":
                case "BoxBufferGeometry":
                case "CubeGeometry":
                  s = new sl[c.type](
                    c.width,
                    c.height,
                    c.depth,
                    c.widthSegments,
                    c.heightSegments,
                    c.depthSegments
                  );
                  break;
                case "CircleGeometry":
                case "CircleBufferGeometry":
                  s = new sl[c.type](
                    c.radius,
                    c.segments,
                    c.thetaStart,
                    c.thetaLength
                  );
                  break;
                case "CylinderGeometry":
                case "CylinderBufferGeometry":
                  s = new sl[c.type](
                    c.radiusTop,
                    c.radiusBottom,
                    c.height,
                    c.radialSegments,
                    c.heightSegments,
                    c.openEnded,
                    c.thetaStart,
                    c.thetaLength
                  );
                  break;
                case "ConeGeometry":
                case "ConeBufferGeometry":
                  s = new sl[c.type](
                    c.radius,
                    c.height,
                    c.radialSegments,
                    c.heightSegments,
                    c.openEnded,
                    c.thetaStart,
                    c.thetaLength
                  );
                  break;
                case "SphereGeometry":
                case "SphereBufferGeometry":
                  s = new sl[c.type](
                    c.radius,
                    c.widthSegments,
                    c.heightSegments,
                    c.phiStart,
                    c.phiLength,
                    c.thetaStart,
                    c.thetaLength
                  );
                  break;
                case "DodecahedronGeometry":
                case "DodecahedronBufferGeometry":
                case "IcosahedronGeometry":
                case "IcosahedronBufferGeometry":
                case "OctahedronGeometry":
                case "OctahedronBufferGeometry":
                case "TetrahedronGeometry":
                case "TetrahedronBufferGeometry":
                  s = new sl[c.type](c.radius, c.detail);
                  break;
                case "RingGeometry":
                case "RingBufferGeometry":
                  s = new sl[c.type](
                    c.innerRadius,
                    c.outerRadius,
                    c.thetaSegments,
                    c.phiSegments,
                    c.thetaStart,
                    c.thetaLength
                  );
                  break;
                case "TorusGeometry":
                case "TorusBufferGeometry":
                  s = new sl[c.type](
                    c.radius,
                    c.tube,
                    c.radialSegments,
                    c.tubularSegments,
                    c.arc
                  );
                  break;
                case "TorusKnotGeometry":
                case "TorusKnotBufferGeometry":
                  s = new sl[c.type](
                    c.radius,
                    c.tube,
                    c.tubularSegments,
                    c.radialSegments,
                    c.p,
                    c.q
                  );
                  break;
                case "TubeGeometry":
                case "TubeBufferGeometry":
                  s = new sl[c.type](
                    new hh[c.path.type]().fromJSON(c.path),
                    c.tubularSegments,
                    c.radius,
                    c.radialSegments,
                    c.closed
                  );
                  break;
                case "LatheGeometry":
                case "LatheBufferGeometry":
                  s = new sl[c.type](
                    c.points,
                    c.segments,
                    c.phiStart,
                    c.phiLength
                  );
                  break;
                case "PolyhedronGeometry":
                case "PolyhedronBufferGeometry":
                  s = new sl[c.type](
                    c.vertices,
                    c.indices,
                    c.radius,
                    c.details
                  );
                  break;
                case "ShapeGeometry":
                case "ShapeBufferGeometry":
                  n = [];
                  for (var u = 0, l = c.shapes.length; u < l; u++)
                    n.push(t[c.shapes[u]]);
                  s = new sl[c.type](n, c.curveSegments);
                  break;
                case "ExtrudeGeometry":
                case "ExtrudeBufferGeometry":
                  n = [];
                  for (var h = 0, d = c.shapes.length; h < d; h++)
                    n.push(t[c.shapes[h]]);
                  var p = c.options.extrudePath;
                  void 0 !== p &&
                    (c.options.extrudePath = new hh[p.type]().fromJSON(p)),
                    (s = new sl[c.type](n, c.options));
                  break;
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  s = i.parse(c);
                  break;
                case "Geometry":
                  console.error(
                    'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'
                  );
                  break;
                default:
                  console.warn(
                    'THREE.ObjectLoader: Unsupported geometry type "' +
                      c.type +
                      '"'
                  );
                  continue;
              }
              (s.uuid = c.uuid),
                void 0 !== c.name && (s.name = c.name),
                !0 === s.isBufferGeometry &&
                  void 0 !== c.userData &&
                  (s.userData = c.userData),
                (r[c.uuid] = s);
            }
          return r;
        },
        parseMaterials: function (e, t) {
          var n = {},
            r = {};
          if (void 0 !== e) {
            var i = new Ch();
            i.setTextures(t);
            for (var a = 0, o = e.length; a < o; a++) {
              var s = e[a];
              if ("MultiMaterial" === s.type) {
                for (var c = [], u = 0; u < s.materials.length; u++) {
                  var l = s.materials[u];
                  void 0 === n[l.uuid] && (n[l.uuid] = i.parse(l)),
                    c.push(n[l.uuid]);
                }
                r[s.uuid] = c;
              } else
                void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)),
                  (r[s.uuid] = n[s.uuid]);
            }
          }
          return r;
        },
        parseAnimations: function (e) {
          for (var t = [], n = 0; n < e.length; n++) {
            var r = e[n],
              i = Ol.parse(r);
            void 0 !== r.uuid && (i.uuid = r.uuid), t.push(i);
          }
          return t;
        },
        parseImages: function (e, t) {
          var n,
            r = this,
            i = {};
          function a(e) {
            return (
              r.manager.itemStart(e),
              n.load(
                e,
                function () {
                  r.manager.itemEnd(e);
                },
                void 0,
                function () {
                  r.manager.itemError(e), r.manager.itemEnd(e);
                }
              )
            );
          }
          if (void 0 !== e && e.length > 0) {
            var o = new Nl(t);
            (n = new jl(o)).setCrossOrigin(this.crossOrigin);
            for (var s = 0, c = e.length; s < c; s++) {
              var u = e[s],
                l = u.url;
              if (Array.isArray(l)) {
                i[u.uuid] = [];
                for (var h = 0, d = l.length; h < d; h++) {
                  var p = l[h],
                    f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p)
                      ? p
                      : r.resourcePath + p;
                  i[u.uuid].push(a(f));
                }
              } else {
                var m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u.url)
                  ? u.url
                  : r.resourcePath + u.url;
                i[u.uuid] = a(m);
              }
            }
          }
          return i;
        },
        parseTextures: function (e, t) {
          function n(e, t) {
            return "number" == typeof e
              ? e
              : (console.warn(
                  "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                  e
                ),
                t[e]);
          }
          var r = {};
          if (void 0 !== e)
            for (var i = 0, a = e.length; i < a; i++) {
              var o = e[i],
                s = void 0;
              void 0 === o.image &&
                console.warn(
                  'THREE.ObjectLoader: No "image" specified for',
                  o.uuid
                ),
                void 0 === t[o.image] &&
                  console.warn("THREE.ObjectLoader: Undefined image", o.image),
                ((s = Array.isArray(t[o.image])
                  ? new Ka(t[o.image])
                  : new qn(t[o.image])).needsUpdate = !0),
                (s.uuid = o.uuid),
                void 0 !== o.name && (s.name = o.name),
                void 0 !== o.mapping && (s.mapping = n(o.mapping, zh)),
                void 0 !== o.offset && s.offset.fromArray(o.offset),
                void 0 !== o.repeat && s.repeat.fromArray(o.repeat),
                void 0 !== o.center && s.center.fromArray(o.center),
                void 0 !== o.rotation && (s.rotation = o.rotation),
                void 0 !== o.wrap &&
                  ((s.wrapS = n(o.wrap[0], Fh)), (s.wrapT = n(o.wrap[1], Fh))),
                void 0 !== o.format && (s.format = o.format),
                void 0 !== o.type && (s.type = o.type),
                void 0 !== o.encoding && (s.encoding = o.encoding),
                void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, Uh)),
                void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, Uh)),
                void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy),
                void 0 !== o.flipY && (s.flipY = o.flipY),
                void 0 !== o.premultiplyAlpha &&
                  (s.premultiplyAlpha = o.premultiplyAlpha),
                void 0 !== o.unpackAlignment &&
                  (s.unpackAlignment = o.unpackAlignment),
                (r[o.uuid] = s);
            }
          return r;
        },
        parseObject: function (e, t, n) {
          var r, i, a;
          function o(e) {
            return (
              void 0 === t[e] &&
                console.warn("THREE.ObjectLoader: Undefined geometry", e),
              t[e]
            );
          }
          function s(e) {
            if (void 0 !== e) {
              if (Array.isArray(e)) {
                for (var t = [], r = 0, i = e.length; r < i; r++) {
                  var a = e[r];
                  void 0 === n[a] &&
                    console.warn("THREE.ObjectLoader: Undefined material", a),
                    t.push(n[a]);
                }
                return t;
              }
              return (
                void 0 === n[e] &&
                  console.warn("THREE.ObjectLoader: Undefined material", e),
                n[e]
              );
            }
          }
          switch (e.type) {
            case "Scene":
              (r = new Er()),
                void 0 !== e.background &&
                  Number.isInteger(e.background) &&
                  (r.background = new vi(e.background)),
                void 0 !== e.fog &&
                  ("Fog" === e.fog.type
                    ? (r.fog = new ks(e.fog.color, e.fog.near, e.fog.far))
                    : "FogExp2" === e.fog.type &&
                      (r.fog = new Gs(e.fog.color, e.fog.density)));
              break;
            case "PerspectiveCamera":
              (r = new Sa(e.fov, e.aspect, e.near, e.far)),
                void 0 !== e.focus && (r.focus = e.focus),
                void 0 !== e.zoom && (r.zoom = e.zoom),
                void 0 !== e.filmGauge && (r.filmGauge = e.filmGauge),
                void 0 !== e.filmOffset && (r.filmOffset = e.filmOffset),
                void 0 !== e.view && (r.view = Object.assign({}, e.view));
              break;
            case "OrthographicCamera":
              (r = new wh(e.left, e.right, e.top, e.bottom, e.near, e.far)),
                void 0 !== e.zoom && (r.zoom = e.zoom),
                void 0 !== e.view && (r.view = Object.assign({}, e.view));
              break;
            case "AmbientLight":
              r = new Th(e.color, e.intensity);
              break;
            case "DirectionalLight":
              r = new Sh(e.color, e.intensity);
              break;
            case "PointLight":
              r = new _h(e.color, e.intensity, e.distance, e.decay);
              break;
            case "RectAreaLight":
              r = new Eh(e.color, e.intensity, e.width, e.height);
              break;
            case "SpotLight":
              r = new xh(
                e.color,
                e.intensity,
                e.distance,
                e.angle,
                e.penumbra,
                e.decay
              );
              break;
            case "HemisphereLight":
              r = new vh(e.color, e.groundColor, e.intensity);
              break;
            case "LightProbe":
              r = new Lh().fromJSON(e);
              break;
            case "SkinnedMesh":
              console.warn(
                "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
              );
            case "Mesh":
              r = new ua((i = o(e.geometry)), (a = s(e.material)));
              break;
            case "InstancedMesh":
              (i = o(e.geometry)), (a = s(e.material));
              var c = e.instanceMatrix;
              (r = new Sc(i, a, e.count)).instanceMatrix = new Ei(
                new Float32Array(c.array),
                16
              );
              break;
            case "LOD":
              r = new fc();
              break;
            case "Line":
              r = new Pc(o(e.geometry), s(e.material), e.mode);
              break;
            case "LineLoop":
              r = new Nc(o(e.geometry), s(e.material));
              break;
            case "LineSegments":
              r = new Ic(o(e.geometry), s(e.material));
              break;
            case "PointCloud":
            case "Points":
              r = new kc(o(e.geometry), s(e.material));
              break;
            case "Sprite":
              r = new ac(s(e.material));
              break;
            case "Group":
              r = new Is();
              break;
            default:
              r = new Tr();
          }
          if (
            ((r.uuid = e.uuid),
            void 0 !== e.name && (r.name = e.name),
            void 0 !== e.matrix
              ? (r.matrix.fromArray(e.matrix),
                void 0 !== e.matrixAutoUpdate &&
                  (r.matrixAutoUpdate = e.matrixAutoUpdate),
                r.matrixAutoUpdate &&
                  r.matrix.decompose(r.position, r.quaternion, r.scale))
              : (void 0 !== e.position && r.position.fromArray(e.position),
                void 0 !== e.rotation && r.rotation.fromArray(e.rotation),
                void 0 !== e.quaternion && r.quaternion.fromArray(e.quaternion),
                void 0 !== e.scale && r.scale.fromArray(e.scale)),
            void 0 !== e.castShadow && (r.castShadow = e.castShadow),
            void 0 !== e.receiveShadow && (r.receiveShadow = e.receiveShadow),
            e.shadow &&
              (void 0 !== e.shadow.bias && (r.shadow.bias = e.shadow.bias),
              void 0 !== e.shadow.normalBias &&
                (r.shadow.normalBias = e.shadow.normalBias),
              void 0 !== e.shadow.radius && (r.shadow.radius = e.shadow.radius),
              void 0 !== e.shadow.mapSize &&
                r.shadow.mapSize.fromArray(e.shadow.mapSize),
              void 0 !== e.shadow.camera &&
                (r.shadow.camera = this.parseObject(e.shadow.camera))),
            void 0 !== e.visible && (r.visible = e.visible),
            void 0 !== e.frustumCulled && (r.frustumCulled = e.frustumCulled),
            void 0 !== e.renderOrder && (r.renderOrder = e.renderOrder),
            void 0 !== e.userData && (r.userData = e.userData),
            void 0 !== e.layers && (r.layers.mask = e.layers),
            void 0 !== e.children)
          )
            for (var u = e.children, l = 0; l < u.length; l++)
              r.add(this.parseObject(u[l], t, n));
          if ("LOD" === e.type) {
            void 0 !== e.autoUpdate && (r.autoUpdate = e.autoUpdate);
            for (var h = e.levels, d = 0; d < h.length; d++) {
              var p = h[d],
                f = r.getObjectByProperty("uuid", p.object);
              void 0 !== f && r.addLevel(f, p.distance);
            }
          }
          return r;
        },
      });
      var Bh,
        zh = {
          UVMapping: se,
          CubeReflectionMapping: ce,
          CubeRefractionMapping: ue,
          EquirectangularReflectionMapping: le,
          EquirectangularRefractionMapping: he,
          CubeUVReflectionMapping: de,
          CubeUVRefractionMapping: pe,
        },
        Fh = {
          RepeatWrapping: fe,
          ClampToEdgeWrapping: me,
          MirroredRepeatWrapping: ve,
        },
        Uh = {
          NearestFilter: ge,
          NearestMipmapNearestFilter: ye,
          NearestMipmapLinearFilter: be,
          LinearFilter: we,
          LinearMipmapNearestFilter: Me,
          LinearMipmapLinearFilter: Te,
        };
      function Gh(e) {
        "undefined" == typeof createImageBitmap &&
          console.warn(
            "THREE.ImageBitmapLoader: createImageBitmap() not supported."
          ),
          "undefined" == typeof fetch &&
            console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
          zl.call(this, e),
          (this.options = { premultiplyAlpha: "none" });
      }
      function kh() {
        (this.type = "ShapePath"),
          (this.color = new vi()),
          (this.subPaths = []),
          (this.currentPath = null);
      }
      function Hh(e) {
        (this.type = "Font"), (this.data = e);
      }
      function jh(e, t, n, r, i) {
        var a = i.glyphs[e] || i.glyphs["?"];
        if (a) {
          var o,
            s,
            c,
            u,
            l,
            h,
            d,
            p,
            f = new kh();
          if (a.o)
            for (
              var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")),
                v = 0,
                g = m.length;
              v < g;

            )
              switch (m[v++]) {
                case "m":
                  (o = m[v++] * t + n), (s = m[v++] * t + r), f.moveTo(o, s);
                  break;
                case "l":
                  (o = m[v++] * t + n), (s = m[v++] * t + r), f.lineTo(o, s);
                  break;
                case "q":
                  (c = m[v++] * t + n),
                    (u = m[v++] * t + r),
                    (l = m[v++] * t + n),
                    (h = m[v++] * t + r),
                    f.quadraticCurveTo(l, h, c, u);
                  break;
                case "b":
                  (c = m[v++] * t + n),
                    (u = m[v++] * t + r),
                    (l = m[v++] * t + n),
                    (h = m[v++] * t + r),
                    (d = m[v++] * t + n),
                    (p = m[v++] * t + r),
                    f.bezierCurveTo(l, h, d, p, c, u);
              }
          return { offsetX: a.ha * t, path: f };
        }
        console.error(
          'THREE.Font: character "' +
            e +
            '" does not exists in font family ' +
            i.familyName +
            "."
        );
      }
      function Vh(e) {
        zl.call(this, e);
      }
      (Gh.prototype = Object.assign(Object.create(zl.prototype), {
        constructor: Gh,
        isImageBitmapLoader: !0,
        setOptions: function (e) {
          return (this.options = e), this;
        },
        load: function (e, t, n, r) {
          void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          var i = this,
            a = Il.get(e);
          if (void 0 !== a)
            return (
              i.manager.itemStart(e),
              setTimeout(function () {
                t && t(a), i.manager.itemEnd(e);
              }, 0),
              a
            );
          fetch(e)
            .then(function (e) {
              return e.blob();
            })
            .then(function (e) {
              return createImageBitmap(e, i.options);
            })
            .then(function (n) {
              Il.add(e, n), t && t(n), i.manager.itemEnd(e);
            })
            .catch(function (t) {
              r && r(t), i.manager.itemError(e), i.manager.itemEnd(e);
            }),
            i.manager.itemStart(e);
        },
      })),
        Object.assign(kh.prototype, {
          moveTo: function (e, t) {
            return (
              (this.currentPath = new ph()),
              this.subPaths.push(this.currentPath),
              this.currentPath.moveTo(e, t),
              this
            );
          },
          lineTo: function (e, t) {
            return this.currentPath.lineTo(e, t), this;
          },
          quadraticCurveTo: function (e, t, n, r) {
            return this.currentPath.quadraticCurveTo(e, t, n, r), this;
          },
          bezierCurveTo: function (e, t, n, r, i, a) {
            return this.currentPath.bezierCurveTo(e, t, n, r, i, a), this;
          },
          splineThru: function (e) {
            return this.currentPath.splineThru(e), this;
          },
          toShapes: function (e, t) {
            function n(e) {
              for (var t = [], n = 0, r = e.length; n < r; n++) {
                var i = e[n],
                  a = new fh();
                (a.curves = i.curves), t.push(a);
              }
              return t;
            }
            function r(e, t) {
              for (var n = t.length, r = !1, i = n - 1, a = 0; a < n; i = a++) {
                var o = t[i],
                  s = t[a],
                  c = s.x - o.x,
                  u = s.y - o.y;
                if (Math.abs(u) > Number.EPSILON) {
                  if (
                    (u < 0 && ((o = t[a]), (c = -c), (s = t[i]), (u = -u)),
                    e.y < o.y || e.y > s.y)
                  )
                    continue;
                  if (e.y === o.y) {
                    if (e.x === o.x) return !0;
                  } else {
                    var l = u * (e.x - o.x) - c * (e.y - o.y);
                    if (0 === l) return !0;
                    if (l < 0) continue;
                    r = !r;
                  }
                } else {
                  if (e.y !== o.y) continue;
                  if ((s.x <= e.x && e.x <= o.x) || (o.x <= e.x && e.x <= s.x))
                    return !0;
                }
              }
              return r;
            }
            var i = Bu.isClockWise,
              a = this.subPaths;
            if (0 === a.length) return [];
            if (!0 === t) return n(a);
            var o,
              s,
              c,
              u = [];
            if (1 === a.length)
              return (
                (s = a[0]), ((c = new fh()).curves = s.curves), u.push(c), u
              );
            var l = !i(a[0].getPoints());
            l = e ? !l : l;
            var h,
              d,
              p = [],
              f = [],
              m = [],
              v = 0;
            (f[v] = void 0), (m[v] = []);
            for (var g = 0, y = a.length; g < y; g++)
              (o = i((h = (s = a[g]).getPoints()))),
                (o = e ? !o : o)
                  ? (!l && f[v] && v++,
                    (f[v] = { s: new fh(), p: h }),
                    (f[v].s.curves = s.curves),
                    l && v++,
                    (m[v] = []))
                  : m[v].push({ h: s, p: h[0] });
            if (!f[0]) return n(a);
            if (f.length > 1) {
              for (var x = !1, b = [], _ = 0, w = f.length; _ < w; _++)
                p[_] = [];
              for (var M = 0, S = f.length; M < S; M++)
                for (var T = m[M], E = 0; E < T.length; E++) {
                  for (var A = T[E], L = !0, C = 0; C < f.length; C++)
                    r(A.p, f[C].p) &&
                      (M !== C && b.push({ froms: M, tos: C, hole: E }),
                      L ? ((L = !1), p[C].push(A)) : (x = !0));
                  L && p[M].push(A);
                }
              b.length > 0 && (x || (m = p));
            }
            for (var R = 0, P = f.length; R < P; R++) {
              (c = f[R].s), u.push(c);
              for (var O = 0, D = (d = m[R]).length; O < D; O++)
                c.holes.push(d[O].h);
            }
            return u;
          },
        }),
        Object.assign(Hh.prototype, {
          isFont: !0,
          generateShapes: function (e, t) {
            void 0 === t && (t = 100);
            for (
              var n = [],
                r = (function (e, t, n) {
                  for (
                    var r = Array.from ? Array.from(e) : String(e).split(""),
                      i = t / n.resolution,
                      a =
                        (n.boundingBox.yMax -
                          n.boundingBox.yMin +
                          n.underlineThickness) *
                        i,
                      o = [],
                      s = 0,
                      c = 0,
                      u = 0;
                    u < r.length;
                    u++
                  ) {
                    var l = r[u];
                    if ("\n" === l) (s = 0), (c -= a);
                    else {
                      var h = jh(l, i, s, c, n);
                      (s += h.offsetX), o.push(h.path);
                    }
                  }
                  return o;
                })(e, t, this.data),
                i = 0,
                a = r.length;
              i < a;
              i++
            )
              Array.prototype.push.apply(n, r[i].toShapes());
            return n;
          },
        }),
        (Vh.prototype = Object.assign(Object.create(zl.prototype), {
          constructor: Vh,
          load: function (e, t, n, r) {
            var i = this,
              a = new Ul(this.manager);
            a.setPath(this.path),
              a.load(
                e,
                function (e) {
                  var n;
                  try {
                    n = JSON.parse(e);
                  } catch (a) {
                    console.warn(
                      "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                    ),
                      (n = JSON.parse(e.substring(65, e.length - 2)));
                  }
                  var r = i.parse(n);
                  t && t(r);
                },
                n,
                r
              );
          },
          parse: function (e) {
            return new Hh(e);
          },
        }));
      var Wh = {
        getContext: function () {
          return (
            void 0 === Bh &&
              (Bh = new (window.AudioContext || window.webkitAudioContext)()),
            Bh
          );
        },
        setContext: function (e) {
          Bh = e;
        },
      };
      function qh(e) {
        zl.call(this, e);
      }
      function Xh(e, t, n) {
        Lh.call(this, void 0, n);
        var r = new vi().set(e),
          i = new vi().set(t),
          a = new $n(r.r, r.g, r.b),
          o = new $n(i.r, i.g, i.b),
          s = Math.sqrt(Math.PI),
          c = s * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s),
          this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c);
      }
      function Yh(e, t) {
        Lh.call(this, void 0, t);
        var n = new vi().set(e);
        this.sh.coefficients[0]
          .set(n.r, n.g, n.b)
          .multiplyScalar(2 * Math.sqrt(Math.PI));
      }
      (qh.prototype = Object.assign(Object.create(zl.prototype), {
        constructor: qh,
        load: function (e, t, n, r) {
          var i = this,
            a = new Ul(i.manager);
          a.setResponseType("arraybuffer"),
            a.setPath(i.path),
            a.load(
              e,
              function (n) {
                try {
                  var a = n.slice(0);
                  Wh.getContext().decodeAudioData(a, function (e) {
                    t(e);
                  });
                } catch (o) {
                  r ? r(o) : console.error(o), i.manager.itemError(e);
                }
              },
              n,
              r
            );
        },
      })),
        (Xh.prototype = Object.assign(Object.create(Lh.prototype), {
          constructor: Xh,
          isHemisphereLightProbe: !0,
          copy: function (e) {
            return Lh.prototype.copy.call(this, e), this;
          },
          toJSON: function (e) {
            return Lh.prototype.toJSON.call(this, e);
          },
        })),
        (Yh.prototype = Object.assign(Object.create(Lh.prototype), {
          constructor: Yh,
          isAmbientLightProbe: !0,
          copy: function (e) {
            return Lh.prototype.copy.call(this, e), this;
          },
          toJSON: function (e) {
            return Lh.prototype.toJSON.call(this, e);
          },
        }));
      var Zh = new sr(),
        Jh = new sr();
      function Kh() {
        (this.type = "StereoCamera"),
          (this.aspect = 1),
          (this.eyeSep = 0.064),
          (this.cameraL = new Sa()),
          this.cameraL.layers.enable(1),
          (this.cameraL.matrixAutoUpdate = !1),
          (this.cameraR = new Sa()),
          this.cameraR.layers.enable(2),
          (this.cameraR.matrixAutoUpdate = !1),
          (this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null,
          });
      }
      function Qh(e) {
        (this.autoStart = void 0 === e || e),
          (this.startTime = 0),
          (this.oldTime = 0),
          (this.elapsedTime = 0),
          (this.running = !1);
      }
      Object.assign(Kh.prototype, {
        update: function (e) {
          var t = this._cache;
          if (
            t.focus !== e.focus ||
            t.fov !== e.fov ||
            t.aspect !== e.aspect * this.aspect ||
            t.near !== e.near ||
            t.far !== e.far ||
            t.zoom !== e.zoom ||
            t.eyeSep !== this.eyeSep
          ) {
            (t.focus = e.focus),
              (t.fov = e.fov),
              (t.aspect = e.aspect * this.aspect),
              (t.near = e.near),
              (t.far = e.far),
              (t.zoom = e.zoom),
              (t.eyeSep = this.eyeSep);
            var n,
              r,
              i = e.projectionMatrix.clone(),
              a = t.eyeSep / 2,
              o = (a * t.near) / t.focus,
              s = (t.near * Math.tan(kn.DEG2RAD * t.fov * 0.5)) / t.zoom;
            (Jh.elements[12] = -a),
              (Zh.elements[12] = a),
              (n = -s * t.aspect + o),
              (r = s * t.aspect + o),
              (i.elements[0] = (2 * t.near) / (r - n)),
              (i.elements[8] = (r + n) / (r - n)),
              this.cameraL.projectionMatrix.copy(i),
              (n = -s * t.aspect - o),
              (r = s * t.aspect - o),
              (i.elements[0] = (2 * t.near) / (r - n)),
              (i.elements[8] = (r + n) / (r - n)),
              this.cameraR.projectionMatrix.copy(i);
          }
          this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Jh),
            this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Zh);
        },
      }),
        Object.assign(Qh.prototype, {
          start: function () {
            (this.startTime = ("undefined" == typeof performance
              ? Date
              : performance
            ).now()),
              (this.oldTime = this.startTime),
              (this.elapsedTime = 0),
              (this.running = !0);
          },
          stop: function () {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
          },
          getElapsedTime: function () {
            return this.getDelta(), this.elapsedTime;
          },
          getDelta: function () {
            var e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
              var t = ("undefined" == typeof performance
                ? Date
                : performance
              ).now();
              (e = (t - this.oldTime) / 1e3),
                (this.oldTime = t),
                (this.elapsedTime += e);
            }
            return e;
          },
        });
      var $h = new $n(),
        ed = new Jn(),
        td = new $n(),
        nd = new $n();
      function rd() {
        Tr.call(this),
          (this.type = "AudioListener"),
          (this.context = Wh.getContext()),
          (this.gain = this.context.createGain()),
          this.gain.connect(this.context.destination),
          (this.filter = null),
          (this.timeDelta = 0),
          (this._clock = new Qh());
      }
      function id(e) {
        Tr.call(this),
          (this.type = "Audio"),
          (this.listener = e),
          (this.context = e.context),
          (this.gain = this.context.createGain()),
          this.gain.connect(e.getInput()),
          (this.autoplay = !1),
          (this.buffer = null),
          (this.detune = 0),
          (this.loop = !1),
          (this.loopStart = 0),
          (this.loopEnd = 0),
          (this.offset = 0),
          (this.duration = void 0),
          (this.playbackRate = 1),
          (this.isPlaying = !1),
          (this.hasPlaybackControl = !0),
          (this.sourceType = "empty"),
          (this._startedAt = 0),
          (this._progress = 0),
          (this.filters = []);
      }
      (rd.prototype = Object.assign(Object.create(Tr.prototype), {
        constructor: rd,
        getInput: function () {
          return this.gain;
        },
        removeFilter: function () {
          return (
            null !== this.filter &&
              (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination),
              this.gain.connect(this.context.destination),
              (this.filter = null)),
            this
          );
        },
        getFilter: function () {
          return this.filter;
        },
        setFilter: function (e) {
          return (
            null !== this.filter
              ? (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination))
              : this.gain.disconnect(this.context.destination),
            (this.filter = e),
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
          );
        },
        getMasterVolume: function () {
          return this.gain.gain.value;
        },
        setMasterVolume: function (e) {
          return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
          );
        },
        updateMatrixWorld: function (e) {
          Tr.prototype.updateMatrixWorld.call(this, e);
          var t = this.context.listener,
            n = this.up;
          if (
            ((this.timeDelta = this._clock.getDelta()),
            this.matrixWorld.decompose($h, ed, td),
            nd.set(0, 0, -1).applyQuaternion(ed),
            t.positionX)
          ) {
            var r = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime($h.x, r),
              t.positionY.linearRampToValueAtTime($h.y, r),
              t.positionZ.linearRampToValueAtTime($h.z, r),
              t.forwardX.linearRampToValueAtTime(nd.x, r),
              t.forwardY.linearRampToValueAtTime(nd.y, r),
              t.forwardZ.linearRampToValueAtTime(nd.z, r),
              t.upX.linearRampToValueAtTime(n.x, r),
              t.upY.linearRampToValueAtTime(n.y, r),
              t.upZ.linearRampToValueAtTime(n.z, r);
          } else
            t.setPosition($h.x, $h.y, $h.z),
              t.setOrientation(nd.x, nd.y, nd.z, n.x, n.y, n.z);
        },
      })),
        (id.prototype = Object.assign(Object.create(Tr.prototype), {
          constructor: id,
          getOutput: function () {
            return this.gain;
          },
          setNodeSource: function (e) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "audioNode"),
              (this.source = e),
              this.connect(),
              this
            );
          },
          setMediaElementSource: function (e) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "mediaNode"),
              (this.source = this.context.createMediaElementSource(e)),
              this.connect(),
              this
            );
          },
          setMediaStreamSource: function (e) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "mediaStreamNode"),
              (this.source = this.context.createMediaStreamSource(e)),
              this.connect(),
              this
            );
          },
          setBuffer: function (e) {
            return (
              (this.buffer = e),
              (this.sourceType = "buffer"),
              this.autoplay && this.play(),
              this
            );
          },
          play: function (e) {
            if ((void 0 === e && (e = 0), !0 !== this.isPlaying)) {
              if (!1 !== this.hasPlaybackControl) {
                this._startedAt = this.context.currentTime + e;
                var t = this.context.createBufferSource();
                return (
                  (t.buffer = this.buffer),
                  (t.loop = this.loop),
                  (t.loopStart = this.loopStart),
                  (t.loopEnd = this.loopEnd),
                  (t.onended = this.onEnded.bind(this)),
                  t.start(
                    this._startedAt,
                    this._progress + this.offset,
                    this.duration
                  ),
                  (this.isPlaying = !0),
                  (this.source = t),
                  this.setDetune(this.detune),
                  this.setPlaybackRate(this.playbackRate),
                  this.connect()
                );
              }
              console.warn("THREE.Audio: this Audio has no playback control.");
            } else console.warn("THREE.Audio: Audio is already playing.");
          },
          pause: function () {
            if (!1 !== this.hasPlaybackControl)
              return (
                !0 === this.isPlaying &&
                  ((this._progress +=
                    Math.max(this.context.currentTime - this._startedAt, 0) *
                    this.playbackRate),
                  !0 === this.loop &&
                    (this._progress =
                      this._progress % (this.duration || this.buffer.duration)),
                  this.source.stop(),
                  (this.source.onended = null),
                  (this.isPlaying = !1)),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          },
          stop: function () {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this._progress = 0),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          },
          connect: function () {
            if (this.filters.length > 0) {
              this.source.connect(this.filters[0]);
              for (var e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
              this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return this;
          },
          disconnect: function () {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0]);
              for (var e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].disconnect(this.filters[e]);
              this.filters[this.filters.length - 1].disconnect(
                this.getOutput()
              );
            } else this.source.disconnect(this.getOutput());
            return this;
          },
          getFilters: function () {
            return this.filters;
          },
          setFilters: function (e) {
            return (
              e || (e = []),
              !0 === this.isPlaying
                ? (this.disconnect(), (this.filters = e), this.connect())
                : (this.filters = e),
              this
            );
          },
          setDetune: function (e) {
            if (((this.detune = e), void 0 !== this.source.detune))
              return (
                !0 === this.isPlaying &&
                  this.source.detune.setTargetAtTime(
                    this.detune,
                    this.context.currentTime,
                    0.01
                  ),
                this
              );
          },
          getDetune: function () {
            return this.detune;
          },
          getFilter: function () {
            return this.getFilters()[0];
          },
          setFilter: function (e) {
            return this.setFilters(e ? [e] : []);
          },
          setPlaybackRate: function (e) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.playbackRate = e),
                !0 === this.isPlaying &&
                  this.source.playbackRate.setTargetAtTime(
                    this.playbackRate,
                    this.context.currentTime,
                    0.01
                  ),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          },
          getPlaybackRate: function () {
            return this.playbackRate;
          },
          onEnded: function () {
            this.isPlaying = !1;
          },
          getLoop: function () {
            return !1 === this.hasPlaybackControl
              ? (console.warn(
                  "THREE.Audio: this Audio has no playback control."
                ),
                !1)
              : this.loop;
          },
          setLoop: function (e) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.loop = e),
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          },
          setLoopStart: function (e) {
            return (this.loopStart = e), this;
          },
          setLoopEnd: function (e) {
            return (this.loopEnd = e), this;
          },
          getVolume: function () {
            return this.gain.gain.value;
          },
          setVolume: function (e) {
            return (
              this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
              this
            );
          },
        }));
      var ad = new $n(),
        od = new Jn(),
        sd = new $n(),
        cd = new $n();
      function ud(e) {
        id.call(this, e),
          (this.panner = this.context.createPanner()),
          (this.panner.panningModel = "HRTF"),
          this.panner.connect(this.gain);
      }
      function ld(e, t) {
        (this.analyser = e.context.createAnalyser()),
          (this.analyser.fftSize = void 0 !== t ? t : 2048),
          (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
          e.getOutput().connect(this.analyser);
      }
      function hd(e, t, n) {
        var r, i, a;
        switch (((this.binding = e), (this.valueSize = n), t)) {
          case "quaternion":
            (r = this._slerp),
              (i = this._slerpAdditive),
              (a = this._setAdditiveIdentityQuaternion),
              (this.buffer = new Float64Array(6 * n)),
              (this._workIndex = 5);
            break;
          case "string":
          case "bool":
            (r = this._select),
              (i = this._select),
              (a = this._setAdditiveIdentityOther),
              (this.buffer = new Array(5 * n));
            break;
          default:
            (r = this._lerp),
              (i = this._lerpAdditive),
              (a = this._setAdditiveIdentityNumeric),
              (this.buffer = new Float64Array(5 * n));
        }
        (this._mixBufferRegion = r),
          (this._mixBufferRegionAdditive = i),
          (this._setIdentity = a),
          (this._origIndex = 3),
          (this._addIndex = 4),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          (this.useCount = 0),
          (this.referenceCount = 0);
      }
      (ud.prototype = Object.assign(Object.create(id.prototype), {
        constructor: ud,
        getOutput: function () {
          return this.panner;
        },
        getRefDistance: function () {
          return this.panner.refDistance;
        },
        setRefDistance: function (e) {
          return (this.panner.refDistance = e), this;
        },
        getRolloffFactor: function () {
          return this.panner.rolloffFactor;
        },
        setRolloffFactor: function (e) {
          return (this.panner.rolloffFactor = e), this;
        },
        getDistanceModel: function () {
          return this.panner.distanceModel;
        },
        setDistanceModel: function (e) {
          return (this.panner.distanceModel = e), this;
        },
        getMaxDistance: function () {
          return this.panner.maxDistance;
        },
        setMaxDistance: function (e) {
          return (this.panner.maxDistance = e), this;
        },
        setDirectionalCone: function (e, t, n) {
          return (
            (this.panner.coneInnerAngle = e),
            (this.panner.coneOuterAngle = t),
            (this.panner.coneOuterGain = n),
            this
          );
        },
        updateMatrixWorld: function (e) {
          if (
            (Tr.prototype.updateMatrixWorld.call(this, e),
            !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
          ) {
            this.matrixWorld.decompose(ad, od, sd),
              cd.set(0, 0, 1).applyQuaternion(od);
            var t = this.panner;
            if (t.positionX) {
              var n = this.context.currentTime + this.listener.timeDelta;
              t.positionX.linearRampToValueAtTime(ad.x, n),
                t.positionY.linearRampToValueAtTime(ad.y, n),
                t.positionZ.linearRampToValueAtTime(ad.z, n),
                t.orientationX.linearRampToValueAtTime(cd.x, n),
                t.orientationY.linearRampToValueAtTime(cd.y, n),
                t.orientationZ.linearRampToValueAtTime(cd.z, n);
            } else
              t.setPosition(ad.x, ad.y, ad.z),
                t.setOrientation(cd.x, cd.y, cd.z);
          }
        },
      })),
        Object.assign(ld.prototype, {
          getFrequencyData: function () {
            return this.analyser.getByteFrequencyData(this.data), this.data;
          },
          getAverageFrequency: function () {
            for (
              var e = 0, t = this.getFrequencyData(), n = 0;
              n < t.length;
              n++
            )
              e += t[n];
            return e / t.length;
          },
        }),
        Object.assign(hd.prototype, {
          accumulate: function (e, t) {
            var n = this.buffer,
              r = this.valueSize,
              i = e * r + r,
              a = this.cumulativeWeight;
            if (0 === a) {
              for (var o = 0; o !== r; ++o) n[i + o] = n[o];
              a = t;
            } else (a += t), this._mixBufferRegion(n, i, 0, t / a, r);
            this.cumulativeWeight = a;
          },
          accumulateAdditive: function (e) {
            var t = this.buffer,
              n = this.valueSize,
              r = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
              this._mixBufferRegionAdditive(t, r, 0, e, n),
              (this.cumulativeWeightAdditive += e);
          },
          apply: function (e) {
            var t = this.valueSize,
              n = this.buffer,
              r = e * t + t,
              i = this.cumulativeWeight,
              a = this.cumulativeWeightAdditive,
              o = this.binding;
            (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              i < 1 &&
                this._mixBufferRegion(n, r, t * this._origIndex, 1 - i, t),
              a > 0 &&
                this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
            for (var s = t, c = t + t; s !== c; ++s)
              if (n[s] !== n[s + t]) {
                o.setValue(n, r);
                break;
              }
          },
          saveOriginalState: function () {
            var e = this.buffer,
              t = this.valueSize,
              n = t * this._origIndex;
            this.binding.getValue(e, n);
            for (var r = t, i = n; r !== i; ++r) e[r] = e[n + (r % t)];
            this._setIdentity(),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0);
          },
          restoreOriginalState: function () {
            this.binding.setValue(this.buffer, 3 * this.valueSize);
          },
          _setAdditiveIdentityNumeric: function () {
            for (
              var e = this._addIndex * this.valueSize,
                t = e + this.valueSize,
                n = e;
              n < t;
              n++
            )
              this.buffer[n] = 0;
          },
          _setAdditiveIdentityQuaternion: function () {
            this._setAdditiveIdentityNumeric(),
              (this.buffer[4 * this._addIndex + 3] = 1);
          },
          _setAdditiveIdentityOther: function () {
            for (
              var e = this._origIndex * this.valueSize,
                t = this._addIndex * this.valueSize,
                n = 0;
              n < this.valueSize;
              n++
            )
              this.buffer[t + n] = this.buffer[e + n];
          },
          _select: function (e, t, n, r, i) {
            if (r >= 0.5) for (var a = 0; a !== i; ++a) e[t + a] = e[n + a];
          },
          _slerp: function (e, t, n, r) {
            Jn.slerpFlat(e, t, e, t, e, n, r);
          },
          _slerpAdditive: function (e, t, n, r, i) {
            var a = this._workIndex * i;
            Jn.multiplyQuaternionsFlat(e, a, e, t, e, n),
              Jn.slerpFlat(e, t, e, t, e, a, r);
          },
          _lerp: function (e, t, n, r, i) {
            for (var a = 1 - r, o = 0; o !== i; ++o) {
              var s = t + o;
              e[s] = e[s] * a + e[n + o] * r;
            }
          },
          _lerpAdditive: function (e, t, n, r, i) {
            for (var a = 0; a !== i; ++a) {
              var o = t + a;
              e[o] = e[o] + e[n + a] * r;
            }
          },
        });
      var dd = new RegExp("[\\[\\]\\.:\\/]", "g"),
        pd = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        fd = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        md = /(WCOD+)?/.source.replace("WCOD", pd),
        vd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
          "WC",
          "[^\\[\\]\\.:\\/]"
        ),
        gd = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        yd = new RegExp("^" + fd + md + vd + gd + "$"),
        xd = ["material", "materials", "bones"];
      function bd(e, t, n) {
        var r = n || _d.parseTrackName(t);
        (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
      }
      function _d(e, t, n) {
        (this.path = t),
          (this.parsedPath = n || _d.parseTrackName(t)),
          (this.node = _d.findNode(e, this.parsedPath.nodeName) || e),
          (this.rootNode = e);
      }
      function wd() {
        (this.uuid = kn.generateUUID()),
          (this._objects = Array.prototype.slice.call(arguments)),
          (this.nCachedObjects_ = 0);
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, n = arguments.length; t !== n; ++t)
          e[arguments[t].uuid] = t;
        (this._paths = []),
          (this._parsedPaths = []),
          (this._bindings = []),
          (this._bindingsIndicesByPath = {});
        var r = this;
        this.stats = {
          objects: {
            get total() {
              return r._objects.length;
            },
            get inUse() {
              return this.total - r.nCachedObjects_;
            },
          },
          get bindingsPerObject() {
            return r._bindings.length;
          },
        };
      }
      function Md(e, t, n, r) {
        (this._mixer = e),
          (this._clip = t),
          (this._localRoot = n || null),
          (this.blendMode = r || t.blendMode);
        for (
          var i = t.tracks,
            a = i.length,
            o = new Array(a),
            s = { endingStart: Wt, endingEnd: Wt },
            c = 0;
          c !== a;
          ++c
        ) {
          var u = i[c].createInterpolant(null);
          (o[c] = u), (u.settings = s);
        }
        (this._interpolantSettings = s),
          (this._interpolants = o),
          (this._propertyBindings = new Array(a)),
          (this._cacheIndex = null),
          (this._byClipCacheIndex = null),
          (this._timeScaleInterpolant = null),
          (this._weightInterpolant = null),
          (this.loop = Gt),
          (this._loopCount = -1),
          (this._startTime = null),
          (this.time = 0),
          (this.timeScale = 1),
          (this._effectiveTimeScale = 1),
          (this.weight = 1),
          (this._effectiveWeight = 1),
          (this.repetitions = 1 / 0),
          (this.paused = !1),
          (this.enabled = !0),
          (this.clampWhenFinished = !1),
          (this.zeroSlopeAtStart = !0),
          (this.zeroSlopeAtEnd = !0);
      }
      function Sd(e) {
        (this._root = e),
          this._initMemoryManager(),
          (this._accuIndex = 0),
          (this.time = 0),
          (this.timeScale = 1);
      }
      function Td(e) {
        "string" == typeof e &&
          (console.warn("THREE.Uniform: Type parameter is no longer needed."),
          (e = arguments[1])),
          (this.value = e);
      }
      function Ed(e, t, n) {
        Hs.call(this, e, t), (this.meshPerAttribute = n || 1);
      }
      function Ad(e, t, n, r) {
        (this.ray = new Kr(e, t)),
          (this.near = n || 0),
          (this.far = r || 1 / 0),
          (this.camera = null),
          (this.layers = new hr()),
          (this.params = {
            Mesh: {},
            Line: { threshold: 1 },
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {},
          }),
          Object.defineProperties(this.params, {
            PointCloud: {
              get: function () {
                return (
                  console.warn(
                    "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
                  ),
                  this.Points
                );
              },
            },
          });
      }
      function Ld(e, t) {
        return e.distance - t.distance;
      }
      function Cd(e, t, n, r) {
        if ((e.layers.test(t.layers) && e.raycast(t, n), !0 === r))
          for (var i = e.children, a = 0, o = i.length; a < o; a++)
            Cd(i[a], t, n, !0);
      }
      function Rd(e, t, n) {
        return (
          (this.radius = void 0 !== e ? e : 1),
          (this.phi = void 0 !== t ? t : 0),
          (this.theta = void 0 !== n ? n : 0),
          this
        );
      }
      function Pd(e, t, n) {
        return (
          (this.radius = void 0 !== e ? e : 1),
          (this.theta = void 0 !== t ? t : 0),
          (this.y = void 0 !== n ? n : 0),
          this
        );
      }
      Object.assign(bd.prototype, {
        getValue: function (e, t) {
          this.bind();
          var n = this._bindings[this._targetGroup.nCachedObjects_];
          void 0 !== n && n.getValue(e, t);
        },
        setValue: function (e, t) {
          for (
            var n = this._bindings,
              r = this._targetGroup.nCachedObjects_,
              i = n.length;
            r !== i;
            ++r
          )
            n[r].setValue(e, t);
        },
        bind: function () {
          for (
            var e = this._bindings,
              t = this._targetGroup.nCachedObjects_,
              n = e.length;
            t !== n;
            ++t
          )
            e[t].bind();
        },
        unbind: function () {
          for (
            var e = this._bindings,
              t = this._targetGroup.nCachedObjects_,
              n = e.length;
            t !== n;
            ++t
          )
            e[t].unbind();
        },
      }),
        Object.assign(_d, {
          Composite: bd,
          create: function (e, t, n) {
            return e && e.isAnimationObjectGroup
              ? new _d.Composite(e, t, n)
              : new _d(e, t, n);
          },
          sanitizeNodeName: function (e) {
            return e.replace(/\s/g, "_").replace(dd, "");
          },
          parseTrackName: function (e) {
            var t = yd.exec(e);
            if (!t)
              throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            var n = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6],
              },
              r = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== r && -1 !== r) {
              var i = n.nodeName.substring(r + 1);
              -1 !== xd.indexOf(i) &&
                ((n.nodeName = n.nodeName.substring(0, r)), (n.objectName = i));
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
              throw new Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                  e
              );
            return n;
          },
          findNode: function (e, t) {
            if (
              !t ||
              "" === t ||
              "." === t ||
              -1 === t ||
              t === e.name ||
              t === e.uuid
            )
              return e;
            if (e.skeleton) {
              var n = e.skeleton.getBoneByName(t);
              if (void 0 !== n) return n;
            }
            if (e.children) {
              var r = (function e(n) {
                for (var r = 0; r < n.length; r++) {
                  var i = n[r];
                  if (i.name === t || i.uuid === t) return i;
                  var a = e(i.children);
                  if (a) return a;
                }
                return null;
              })(e.children);
              if (r) return r;
            }
            return null;
          },
        }),
        Object.assign(_d.prototype, {
          _getValue_unavailable: function () {},
          _setValue_unavailable: function () {},
          BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3,
          },
          Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
          GetterByBindingType: [
            function (e, t) {
              e[t] = this.node[this.propertyName];
            },
            function (e, t) {
              for (
                var n = this.resolvedProperty, r = 0, i = n.length;
                r !== i;
                ++r
              )
                e[t++] = n[r];
            },
            function (e, t) {
              e[t] = this.resolvedProperty[this.propertyIndex];
            },
            function (e, t) {
              this.resolvedProperty.toArray(e, t);
            },
          ],
          SetterByBindingTypeAndVersioning: [
            [
              function (e, t) {
                this.targetObject[this.propertyName] = e[t];
              },
              function (e, t) {
                (this.targetObject[this.propertyName] = e[t]),
                  (this.targetObject.needsUpdate = !0);
              },
              function (e, t) {
                (this.targetObject[this.propertyName] = e[t]),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
            [
              function (e, t) {
                for (
                  var n = this.resolvedProperty, r = 0, i = n.length;
                  r !== i;
                  ++r
                )
                  n[r] = e[t++];
              },
              function (e, t) {
                for (
                  var n = this.resolvedProperty, r = 0, i = n.length;
                  r !== i;
                  ++r
                )
                  n[r] = e[t++];
                this.targetObject.needsUpdate = !0;
              },
              function (e, t) {
                for (
                  var n = this.resolvedProperty, r = 0, i = n.length;
                  r !== i;
                  ++r
                )
                  n[r] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0;
              },
            ],
            [
              function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t];
              },
              function (e, t) {
                (this.resolvedProperty[this.propertyIndex] = e[t]),
                  (this.targetObject.needsUpdate = !0);
              },
              function (e, t) {
                (this.resolvedProperty[this.propertyIndex] = e[t]),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
            [
              function (e, t) {
                this.resolvedProperty.fromArray(e, t);
              },
              function (e, t) {
                this.resolvedProperty.fromArray(e, t),
                  (this.targetObject.needsUpdate = !0);
              },
              function (e, t) {
                this.resolvedProperty.fromArray(e, t),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
          ],
          getValue: function (e, t) {
            this.bind(), this.getValue(e, t);
          },
          setValue: function (e, t) {
            this.bind(), this.setValue(e, t);
          },
          bind: function () {
            var e = this.node,
              t = this.parsedPath,
              n = t.objectName,
              r = t.propertyName,
              i = t.propertyIndex;
            if (
              (e ||
                ((e = _d.findNode(this.rootNode, t.nodeName) || this.rootNode),
                (this.node = e)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              e)
            ) {
              if (n) {
                var a = t.objectIndex;
                switch (n) {
                  case "materials":
                    if (!e.material)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                        this
                      );
                    if (!e.material.materials)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                        this
                      );
                    e = e.material.materials;
                    break;
                  case "bones":
                    if (!e.skeleton)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                        this
                      );
                    e = e.skeleton.bones;
                    for (var o = 0; o < e.length; o++)
                      if (e[o].name === a) {
                        a = o;
                        break;
                      }
                    break;
                  default:
                    if (void 0 === e[n])
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                        this
                      );
                    e = e[n];
                }
                if (void 0 !== a) {
                  if (void 0 === e[a])
                    return void console.error(
                      "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                      this,
                      e
                    );
                  e = e[a];
                }
              }
              var s = e[r];
              if (void 0 !== s) {
                var c = this.Versioning.None;
                (this.targetObject = e),
                  void 0 !== e.needsUpdate
                    ? (c = this.Versioning.NeedsUpdate)
                    : void 0 !== e.matrixWorldNeedsUpdate &&
                      (c = this.Versioning.MatrixWorldNeedsUpdate);
                var u = this.BindingType.Direct;
                if (void 0 !== i) {
                  if ("morphTargetInfluences" === r) {
                    if (!e.geometry)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                        this
                      );
                    if (!e.geometry.isBufferGeometry)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                        this
                      );
                    if (!e.geometry.morphAttributes)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                        this
                      );
                    void 0 !== e.morphTargetDictionary[i] &&
                      (i = e.morphTargetDictionary[i]);
                  }
                  (u = this.BindingType.ArrayElement),
                    (this.resolvedProperty = s),
                    (this.propertyIndex = i);
                } else
                  void 0 !== s.fromArray && void 0 !== s.toArray
                    ? ((u = this.BindingType.HasFromToArray),
                      (this.resolvedProperty = s))
                    : Array.isArray(s)
                    ? ((u = this.BindingType.EntireArray),
                      (this.resolvedProperty = s))
                    : (this.propertyName = r);
                (this.getValue = this.GetterByBindingType[u]),
                  (this.setValue = this.SetterByBindingTypeAndVersioning[u][c]);
              } else
                console.error(
                  "THREE.PropertyBinding: Trying to update property for track: " +
                    t.nodeName +
                    "." +
                    r +
                    " but it wasn't found.",
                  e
                );
            } else
              console.error(
                "THREE.PropertyBinding: Trying to update node for track: " +
                  this.path +
                  " but it wasn't found."
              );
          },
          unbind: function () {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          },
        }),
        Object.assign(_d.prototype, {
          _getValue_unbound: _d.prototype.getValue,
          _setValue_unbound: _d.prototype.setValue,
        }),
        Object.assign(wd.prototype, {
          isAnimationObjectGroup: !0,
          add: function () {
            for (
              var e = this._objects,
                t = this._indicesByUUID,
                n = this._paths,
                r = this._parsedPaths,
                i = this._bindings,
                a = i.length,
                o = void 0,
                s = e.length,
                c = this.nCachedObjects_,
                u = 0,
                l = arguments.length;
              u !== l;
              ++u
            ) {
              var h = arguments[u],
                d = h.uuid,
                p = t[d];
              if (void 0 === p) {
                (p = s++), (t[d] = p), e.push(h);
                for (var f = 0, m = a; f !== m; ++f)
                  i[f].push(new _d(h, n[f], r[f]));
              } else if (p < c) {
                o = e[p];
                var v = --c,
                  g = e[v];
                (t[g.uuid] = p), (e[p] = g), (t[d] = v), (e[v] = h);
                for (var y = 0, x = a; y !== x; ++y) {
                  var b = i[y],
                    _ = b[p];
                  (b[p] = b[v]),
                    void 0 === _ && (_ = new _d(h, n[y], r[y])),
                    (b[v] = _);
                }
              } else
                e[p] !== o &&
                  console.error(
                    "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                  );
            }
            this.nCachedObjects_ = c;
          },
          remove: function () {
            for (
              var e = this._objects,
                t = this._indicesByUUID,
                n = this._bindings,
                r = n.length,
                i = this.nCachedObjects_,
                a = 0,
                o = arguments.length;
              a !== o;
              ++a
            ) {
              var s = arguments[a],
                c = s.uuid,
                u = t[c];
              if (void 0 !== u && u >= i) {
                var l = i++,
                  h = e[l];
                (t[h.uuid] = u), (e[u] = h), (t[c] = l), (e[l] = s);
                for (var d = 0, p = r; d !== p; ++d) {
                  var f = n[d],
                    m = f[u];
                  (f[u] = f[l]), (f[l] = m);
                }
              }
            }
            this.nCachedObjects_ = i;
          },
          uncache: function () {
            for (
              var e = this._objects,
                t = this._indicesByUUID,
                n = this._bindings,
                r = n.length,
                i = this.nCachedObjects_,
                a = e.length,
                o = 0,
                s = arguments.length;
              o !== s;
              ++o
            ) {
              var c = arguments[o].uuid,
                u = t[c];
              if (void 0 !== u)
                if ((delete t[c], u < i)) {
                  var l = --i,
                    h = e[l],
                    d = --a,
                    p = e[d];
                  (t[h.uuid] = u),
                    (e[u] = h),
                    (t[p.uuid] = l),
                    (e[l] = p),
                    e.pop();
                  for (var f = 0, m = r; f !== m; ++f) {
                    var v = n[f],
                      g = v[d];
                    (v[u] = v[l]), (v[l] = g), v.pop();
                  }
                } else {
                  var y = --a,
                    x = e[y];
                  (t[x.uuid] = u), (e[u] = x), e.pop();
                  for (var b = 0, _ = r; b !== _; ++b) {
                    var w = n[b];
                    (w[u] = w[y]), w.pop();
                  }
                }
            }
            this.nCachedObjects_ = i;
          },
          subscribe_: function (e, t) {
            var n = this._bindingsIndicesByPath,
              r = n[e],
              i = this._bindings;
            if (void 0 !== r) return i[r];
            var a = this._paths,
              o = this._parsedPaths,
              s = this._objects,
              c = this.nCachedObjects_,
              u = new Array(s.length);
            (r = i.length), (n[e] = r), a.push(e), o.push(t), i.push(u);
            for (var l = c, h = s.length; l !== h; ++l)
              u[l] = new _d(s[l], e, t);
            return u;
          },
          unsubscribe_: function (e) {
            var t = this._bindingsIndicesByPath,
              n = t[e];
            if (void 0 !== n) {
              var r = this._paths,
                i = this._parsedPaths,
                a = this._bindings,
                o = a.length - 1,
                s = a[o];
              (t[e[o]] = n),
                (a[n] = s),
                a.pop(),
                (i[n] = i[o]),
                i.pop(),
                (r[n] = r[o]),
                r.pop();
            }
          },
        }),
        Object.assign(Md.prototype, {
          play: function () {
            return this._mixer._activateAction(this), this;
          },
          stop: function () {
            return this._mixer._deactivateAction(this), this.reset();
          },
          reset: function () {
            return (
              (this.paused = !1),
              (this.enabled = !0),
              (this.time = 0),
              (this._loopCount = -1),
              (this._startTime = null),
              this.stopFading().stopWarping()
            );
          },
          isRunning: function () {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            );
          },
          isScheduled: function () {
            return this._mixer._isActiveAction(this);
          },
          startAt: function (e) {
            return (this._startTime = e), this;
          },
          setLoop: function (e, t) {
            return (this.loop = e), (this.repetitions = t), this;
          },
          setEffectiveWeight: function (e) {
            return (
              (this.weight = e),
              (this._effectiveWeight = this.enabled ? e : 0),
              this.stopFading()
            );
          },
          getEffectiveWeight: function () {
            return this._effectiveWeight;
          },
          fadeIn: function (e) {
            return this._scheduleFading(e, 0, 1);
          },
          fadeOut: function (e) {
            return this._scheduleFading(e, 1, 0);
          },
          crossFadeFrom: function (e, t, n) {
            if ((e.fadeOut(t), this.fadeIn(t), n)) {
              var r = this._clip.duration,
                i = e._clip.duration,
                a = r / i;
              e.warp(1, i / r, t), this.warp(a, 1, t);
            }
            return this;
          },
          crossFadeTo: function (e, t, n) {
            return e.crossFadeFrom(this, t, n);
          },
          stopFading: function () {
            var e = this._weightInterpolant;
            return (
              null !== e &&
                ((this._weightInterpolant = null),
                this._mixer._takeBackControlInterpolant(e)),
              this
            );
          },
          setEffectiveTimeScale: function (e) {
            return (
              (this.timeScale = e),
              (this._effectiveTimeScale = this.paused ? 0 : e),
              this.stopWarping()
            );
          },
          getEffectiveTimeScale: function () {
            return this._effectiveTimeScale;
          },
          setDuration: function (e) {
            return (
              (this.timeScale = this._clip.duration / e), this.stopWarping()
            );
          },
          syncWith: function (e) {
            return (
              (this.time = e.time),
              (this.timeScale = e.timeScale),
              this.stopWarping()
            );
          },
          halt: function (e) {
            return this.warp(this._effectiveTimeScale, 0, e);
          },
          warp: function (e, t, n) {
            var r = this._mixer,
              i = r.time,
              a = this.timeScale,
              o = this._timeScaleInterpolant;
            null === o &&
              ((o = r._lendControlInterpolant()),
              (this._timeScaleInterpolant = o));
            var s = o.parameterPositions,
              c = o.sampleValues;
            return (
              (s[0] = i), (s[1] = i + n), (c[0] = e / a), (c[1] = t / a), this
            );
          },
          stopWarping: function () {
            var e = this._timeScaleInterpolant;
            return (
              null !== e &&
                ((this._timeScaleInterpolant = null),
                this._mixer._takeBackControlInterpolant(e)),
              this
            );
          },
          getMixer: function () {
            return this._mixer;
          },
          getClip: function () {
            return this._clip;
          },
          getRoot: function () {
            return this._localRoot || this._mixer._root;
          },
          _update: function (e, t, n, r) {
            if (this.enabled) {
              var i = this._startTime;
              if (null !== i) {
                var a = (e - i) * n;
                if (a < 0 || 0 === n) return;
                (this._startTime = null), (t = n * a);
              }
              t *= this._updateTimeScale(e);
              var o = this._updateTime(t),
                s = this._updateWeight(e);
              if (s > 0) {
                var c = this._interpolants,
                  u = this._propertyBindings;
                switch (this.blendMode) {
                  case Zt:
                    for (var l = 0, h = c.length; l !== h; ++l)
                      c[l].evaluate(o), u[l].accumulateAdditive(s);
                    break;
                  case Yt:
                  default:
                    for (var d = 0, p = c.length; d !== p; ++d)
                      c[d].evaluate(o), u[d].accumulate(r, s);
                }
              }
            } else this._updateWeight(e);
          },
          _updateWeight: function (e) {
            var t = 0;
            if (this.enabled) {
              t = this.weight;
              var n = this._weightInterpolant;
              if (null !== n) {
                var r = n.evaluate(e)[0];
                (t *= r),
                  e > n.parameterPositions[1] &&
                    (this.stopFading(), 0 === r && (this.enabled = !1));
              }
            }
            return (this._effectiveWeight = t), t;
          },
          _updateTimeScale: function (e) {
            var t = 0;
            if (!this.paused) {
              t = this.timeScale;
              var n = this._timeScaleInterpolant;
              null !== n &&
                ((t *= n.evaluate(e)[0]),
                e > n.parameterPositions[1] &&
                  (this.stopWarping(),
                  0 === t ? (this.paused = !0) : (this.timeScale = t)));
            }
            return (this._effectiveTimeScale = t), t;
          },
          _updateTime: function (e) {
            var t = this._clip.duration,
              n = this.loop,
              r = this.time + e,
              i = this._loopCount,
              a = n === kt;
            if (0 === e) return -1 === i ? r : a && 1 == (1 & i) ? t - r : r;
            if (n === Ut) {
              -1 === i && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
              e: {
                if (r >= t) r = t;
                else {
                  if (!(r < 0)) {
                    this.time = r;
                    break e;
                  }
                  r = 0;
                }
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (this.time = r),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1,
                  });
              }
            } else {
              if (
                (-1 === i &&
                  (e >= 0
                    ? ((i = 0), this._setEndings(!0, 0 === this.repetitions, a))
                    : this._setEndings(0 === this.repetitions, !0, a)),
                r >= t || r < 0)
              ) {
                var o = Math.floor(r / t);
                (r -= t * o), (i += Math.abs(o));
                var s = this.repetitions - i;
                if (s <= 0)
                  this.clampWhenFinished
                    ? (this.paused = !0)
                    : (this.enabled = !1),
                    (r = e > 0 ? t : 0),
                    (this.time = r),
                    this._mixer.dispatchEvent({
                      type: "finished",
                      action: this,
                      direction: e > 0 ? 1 : -1,
                    });
                else {
                  if (1 === s) {
                    var c = e < 0;
                    this._setEndings(c, !c, a);
                  } else this._setEndings(!1, !1, a);
                  (this._loopCount = i),
                    (this.time = r),
                    this._mixer.dispatchEvent({
                      type: "loop",
                      action: this,
                      loopDelta: o,
                    });
                }
              } else this.time = r;
              if (a && 1 == (1 & i)) return t - r;
            }
            return r;
          },
          _setEndings: function (e, t, n) {
            var r = this._interpolantSettings;
            n
              ? ((r.endingStart = qt), (r.endingEnd = qt))
              : ((r.endingStart = e ? (this.zeroSlopeAtStart ? qt : Wt) : Xt),
                (r.endingEnd = t ? (this.zeroSlopeAtEnd ? qt : Wt) : Xt));
          },
          _scheduleFading: function (e, t, n) {
            var r = this._mixer,
              i = r.time,
              a = this._weightInterpolant;
            null === a &&
              ((a = r._lendControlInterpolant()),
              (this._weightInterpolant = a));
            var o = a.parameterPositions,
              s = a.sampleValues;
            return (o[0] = i), (s[0] = t), (o[1] = i + e), (s[1] = n), this;
          },
        }),
        (Sd.prototype = Object.assign(Object.create(zn.prototype), {
          constructor: Sd,
          _bindAction: function (e, t) {
            var n = e._localRoot || this._root,
              r = e._clip.tracks,
              i = r.length,
              a = e._propertyBindings,
              o = e._interpolants,
              s = n.uuid,
              c = this._bindingsByRootAndName,
              u = c[s];
            void 0 === u && ((u = {}), (c[s] = u));
            for (var l = 0; l !== i; ++l) {
              var h = r[l],
                d = h.name,
                p = u[d];
              if (void 0 !== p) a[l] = p;
              else {
                if (void 0 !== (p = a[l])) {
                  null === p._cacheIndex &&
                    (++p.referenceCount, this._addInactiveBinding(p, s, d));
                  continue;
                }
                ++(p = new hd(
                  _d.create(
                    n,
                    d,
                    t && t._propertyBindings[l].binding.parsedPath
                  ),
                  h.ValueTypeName,
                  h.getValueSize()
                )).referenceCount,
                  this._addInactiveBinding(p, s, d),
                  (a[l] = p);
              }
              o[l].resultBuffer = p.buffer;
            }
          },
          _activateAction: function (e) {
            if (!this._isActiveAction(e)) {
              if (null === e._cacheIndex) {
                var t = (e._localRoot || this._root).uuid,
                  n = e._clip.uuid,
                  r = this._actionsByClip[n];
                this._bindAction(e, r && r.knownActions[0]),
                  this._addInactiveAction(e, n, t);
              }
              for (
                var i = e._propertyBindings, a = 0, o = i.length;
                a !== o;
                ++a
              ) {
                var s = i[a];
                0 == s.useCount++ &&
                  (this._lendBinding(s), s.saveOriginalState());
              }
              this._lendAction(e);
            }
          },
          _deactivateAction: function (e) {
            if (this._isActiveAction(e)) {
              for (
                var t = e._propertyBindings, n = 0, r = t.length;
                n !== r;
                ++n
              ) {
                var i = t[n];
                0 == --i.useCount &&
                  (i.restoreOriginalState(), this._takeBackBinding(i));
              }
              this._takeBackAction(e);
            }
          },
          _initMemoryManager: function () {
            (this._actions = []),
              (this._nActiveActions = 0),
              (this._actionsByClip = {}),
              (this._bindings = []),
              (this._nActiveBindings = 0),
              (this._bindingsByRootAndName = {}),
              (this._controlInterpolants = []),
              (this._nActiveControlInterpolants = 0);
            var e = this;
            this.stats = {
              actions: {
                get total() {
                  return e._actions.length;
                },
                get inUse() {
                  return e._nActiveActions;
                },
              },
              bindings: {
                get total() {
                  return e._bindings.length;
                },
                get inUse() {
                  return e._nActiveBindings;
                },
              },
              controlInterpolants: {
                get total() {
                  return e._controlInterpolants.length;
                },
                get inUse() {
                  return e._nActiveControlInterpolants;
                },
              },
            };
          },
          _isActiveAction: function (e) {
            var t = e._cacheIndex;
            return null !== t && t < this._nActiveActions;
          },
          _addInactiveAction: function (e, t, n) {
            var r = this._actions,
              i = this._actionsByClip,
              a = i[t];
            if (void 0 === a)
              (a = { knownActions: [e], actionByRoot: {} }),
                (e._byClipCacheIndex = 0),
                (i[t] = a);
            else {
              var o = a.knownActions;
              (e._byClipCacheIndex = o.length), o.push(e);
            }
            (e._cacheIndex = r.length), r.push(e), (a.actionByRoot[n] = e);
          },
          _removeInactiveAction: function (e) {
            var t = this._actions,
              n = t[t.length - 1],
              r = e._cacheIndex;
            (n._cacheIndex = r), (t[r] = n), t.pop(), (e._cacheIndex = null);
            var i = e._clip.uuid,
              a = this._actionsByClip,
              o = a[i],
              s = o.knownActions,
              c = s[s.length - 1],
              u = e._byClipCacheIndex;
            (c._byClipCacheIndex = u),
              (s[u] = c),
              s.pop(),
              (e._byClipCacheIndex = null),
              delete o.actionByRoot[(e._localRoot || this._root).uuid],
              0 === s.length && delete a[i],
              this._removeInactiveBindingsForAction(e);
          },
          _removeInactiveBindingsForAction: function (e) {
            for (
              var t = e._propertyBindings, n = 0, r = t.length;
              n !== r;
              ++n
            ) {
              var i = t[n];
              0 == --i.referenceCount && this._removeInactiveBinding(i);
            }
          },
          _lendAction: function (e) {
            var t = this._actions,
              n = e._cacheIndex,
              r = this._nActiveActions++,
              i = t[r];
            (e._cacheIndex = r), (t[r] = e), (i._cacheIndex = n), (t[n] = i);
          },
          _takeBackAction: function (e) {
            var t = this._actions,
              n = e._cacheIndex,
              r = --this._nActiveActions,
              i = t[r];
            (e._cacheIndex = r), (t[r] = e), (i._cacheIndex = n), (t[n] = i);
          },
          _addInactiveBinding: function (e, t, n) {
            var r = this._bindingsByRootAndName,
              i = this._bindings,
              a = r[t];
            void 0 === a && ((a = {}), (r[t] = a)),
              (a[n] = e),
              (e._cacheIndex = i.length),
              i.push(e);
          },
          _removeInactiveBinding: function (e) {
            var t = this._bindings,
              n = e.binding,
              r = n.rootNode.uuid,
              i = n.path,
              a = this._bindingsByRootAndName,
              o = a[r],
              s = t[t.length - 1],
              c = e._cacheIndex;
            (s._cacheIndex = c),
              (t[c] = s),
              t.pop(),
              delete o[i],
              0 === Object.keys(o).length && delete a[r];
          },
          _lendBinding: function (e) {
            var t = this._bindings,
              n = e._cacheIndex,
              r = this._nActiveBindings++,
              i = t[r];
            (e._cacheIndex = r), (t[r] = e), (i._cacheIndex = n), (t[n] = i);
          },
          _takeBackBinding: function (e) {
            var t = this._bindings,
              n = e._cacheIndex,
              r = --this._nActiveBindings,
              i = t[r];
            (e._cacheIndex = r), (t[r] = e), (i._cacheIndex = n), (t[n] = i);
          },
          _lendControlInterpolant: function () {
            var e = this._controlInterpolants,
              t = this._nActiveControlInterpolants++,
              n = e[t];
            return (
              void 0 === n &&
                (((n = new wl(
                  new Float32Array(2),
                  new Float32Array(2),
                  1,
                  this._controlInterpolantsResultBuffer
                )).__cacheIndex = t),
                (e[t] = n)),
              n
            );
          },
          _takeBackControlInterpolant: function (e) {
            var t = this._controlInterpolants,
              n = e.__cacheIndex,
              r = --this._nActiveControlInterpolants,
              i = t[r];
            (e.__cacheIndex = r), (t[r] = e), (i.__cacheIndex = n), (t[n] = i);
          },
          _controlInterpolantsResultBuffer: new Float32Array(1),
          clipAction: function (e, t, n) {
            var r = t || this._root,
              i = r.uuid,
              a = "string" == typeof e ? Ol.findByName(r, e) : e,
              o = null !== a ? a.uuid : e,
              s = this._actionsByClip[o],
              c = null;
            if (
              (void 0 === n && (n = null !== a ? a.blendMode : Yt),
              void 0 !== s)
            ) {
              var u = s.actionByRoot[i];
              if (void 0 !== u && u.blendMode === n) return u;
              (c = s.knownActions[0]), null === a && (a = c._clip);
            }
            if (null === a) return null;
            var l = new Md(this, a, t, n);
            return this._bindAction(l, c), this._addInactiveAction(l, o, i), l;
          },
          existingAction: function (e, t) {
            var n = t || this._root,
              r = n.uuid,
              i = "string" == typeof e ? Ol.findByName(n, e) : e,
              a = this._actionsByClip[i ? i.uuid : e];
            return (void 0 !== a && a.actionByRoot[r]) || null;
          },
          stopAllAction: function () {
            for (
              var e = this._actions, t = this._nActiveActions - 1;
              t >= 0;
              --t
            )
              e[t].stop();
            return this;
          },
          update: function (e) {
            for (
              var t = this._actions,
                n = this._nActiveActions,
                r = (this.time += e *= this.timeScale),
                i = Math.sign(e),
                a = (this._accuIndex ^= 1),
                o = 0;
              o !== n;
              ++o
            )
              t[o]._update(r, e, i, a);
            for (
              var s = this._bindings, c = this._nActiveBindings, u = 0;
              u !== c;
              ++u
            )
              s[u].apply(a);
            return this;
          },
          setTime: function (e) {
            this.time = 0;
            for (var t = 0; t < this._actions.length; t++)
              this._actions[t].time = 0;
            return this.update(e);
          },
          getRoot: function () {
            return this._root;
          },
          uncacheClip: function (e) {
            var t = this._actions,
              n = e.uuid,
              r = this._actionsByClip,
              i = r[n];
            if (void 0 !== i) {
              for (var a = i.knownActions, o = 0, s = a.length; o !== s; ++o) {
                var c = a[o];
                this._deactivateAction(c);
                var u = c._cacheIndex,
                  l = t[t.length - 1];
                (c._cacheIndex = null),
                  (c._byClipCacheIndex = null),
                  (l._cacheIndex = u),
                  (t[u] = l),
                  t.pop(),
                  this._removeInactiveBindingsForAction(c);
              }
              delete r[n];
            }
          },
          uncacheRoot: function (e) {
            var t = e.uuid,
              n = this._actionsByClip;
            for (var r in n) {
              var i = n[r].actionByRoot[t];
              void 0 !== i &&
                (this._deactivateAction(i), this._removeInactiveAction(i));
            }
            var a = this._bindingsByRootAndName[t];
            if (void 0 !== a)
              for (var o in a) {
                var s = a[o];
                s.restoreOriginalState(), this._removeInactiveBinding(s);
              }
          },
          uncacheAction: function (e, t) {
            var n = this.existingAction(e, t);
            null !== n &&
              (this._deactivateAction(n), this._removeInactiveAction(n));
          },
        })),
        (Td.prototype.clone = function () {
          return new Td(
            void 0 === this.value.clone ? this.value : this.value.clone()
          );
        }),
        (Ed.prototype = Object.assign(Object.create(Hs.prototype), {
          constructor: Ed,
          isInstancedInterleavedBuffer: !0,
          copy: function (e) {
            return (
              Hs.prototype.copy.call(this, e),
              (this.meshPerAttribute = e.meshPerAttribute),
              this
            );
          },
          clone: function (e) {
            var t = Hs.prototype.clone.call(this, e);
            return (t.meshPerAttribute = this.meshPerAttribute), t;
          },
          toJSON: function (e) {
            var t = Hs.prototype.toJSON.call(this, e);
            return (
              (t.isInstancedInterleavedBuffer = !0),
              (t.meshPerAttribute = this.meshPerAttribute),
              t
            );
          },
        })),
        Object.assign(Ad.prototype, {
          set: function (e, t) {
            this.ray.set(e, t);
          },
          setFromCamera: function (e, t) {
            t && t.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                this.ray.direction
                  .set(e.x, e.y, 0.5)
                  .unproject(t)
                  .sub(this.ray.origin)
                  .normalize(),
                (this.camera = t))
              : t && t.isOrthographicCamera
              ? (this.ray.origin
                  .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
                  .unproject(t),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(t.matrixWorld),
                (this.camera = t))
              : console.error("THREE.Raycaster: Unsupported camera type.");
          },
          intersectObject: function (e, t, n) {
            var r = n || [];
            return Cd(e, this, r, t), r.sort(Ld), r;
          },
          intersectObjects: function (e, t, n) {
            var r = n || [];
            if (!1 === Array.isArray(e))
              return (
                console.warn(
                  "THREE.Raycaster.intersectObjects: objects is not an Array."
                ),
                r
              );
            for (var i = 0, a = e.length; i < a; i++) Cd(e[i], this, r, t);
            return r.sort(Ld), r;
          },
        }),
        Object.assign(Rd.prototype, {
          set: function (e, t, n) {
            return (this.radius = e), (this.phi = t), (this.theta = n), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (
              (this.radius = e.radius),
              (this.phi = e.phi),
              (this.theta = e.theta),
              this
            );
          },
          makeSafe: function () {
            return (
              (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
              this
            );
          },
          setFromVector3: function (e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z);
          },
          setFromCartesianCoords: function (e, t, n) {
            return (
              (this.radius = Math.sqrt(e * e + t * t + n * n)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(e, n)),
                  (this.phi = Math.acos(kn.clamp(t / this.radius, -1, 1)))),
              this
            );
          },
        }),
        Object.assign(Pd.prototype, {
          set: function (e, t, n) {
            return (this.radius = e), (this.theta = t), (this.y = n), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (
              (this.radius = e.radius),
              (this.theta = e.theta),
              (this.y = e.y),
              this
            );
          },
          setFromVector3: function (e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z);
          },
          setFromCartesianCoords: function (e, t, n) {
            return (
              (this.radius = Math.sqrt(e * e + n * n)),
              (this.theta = Math.atan2(e, n)),
              (this.y = t),
              this
            );
          },
        });
      var Od = new Hn();
      function Dd(e, t) {
        (this.min = void 0 !== e ? e : new Hn(1 / 0, 1 / 0)),
          (this.max = void 0 !== t ? t : new Hn(-1 / 0, -1 / 0));
      }
      Object.assign(Dd.prototype, {
        set: function (e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        },
        setFromPoints: function (e) {
          this.makeEmpty();
          for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        },
        setFromCenterAndSize: function (e, t) {
          var n = Od.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        },
        makeEmpty: function () {
          return (
            (this.min.x = this.min.y = 1 / 0),
            (this.max.x = this.max.y = -1 / 0),
            this
          );
        },
        isEmpty: function () {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        },
        getCenter: function (e) {
          return (
            void 0 === e &&
              (console.warn("THREE.Box2: .getCenter() target is now required"),
              (e = new Hn())),
            this.isEmpty()
              ? e.set(0, 0)
              : e.addVectors(this.min, this.max).multiplyScalar(0.5)
          );
        },
        getSize: function (e) {
          return (
            void 0 === e &&
              (console.warn("THREE.Box2: .getSize() target is now required"),
              (e = new Hn())),
            this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
          );
        },
        expandByPoint: function (e) {
          return this.min.min(e), this.max.max(e), this;
        },
        expandByVector: function (e) {
          return this.min.sub(e), this.max.add(e), this;
        },
        expandByScalar: function (e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        },
        containsPoint: function (e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y
          );
        },
        containsBox: function (e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y
          );
        },
        getParameter: function (e, t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Box2: .getParameter() target is now required"
              ),
              (t = new Hn())),
            t.set(
              (e.x - this.min.x) / (this.max.x - this.min.x),
              (e.y - this.min.y) / (this.max.y - this.min.y)
            )
          );
        },
        intersectsBox: function (e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y
          );
        },
        clampPoint: function (e, t) {
          return (
            void 0 === t &&
              (console.warn("THREE.Box2: .clampPoint() target is now required"),
              (t = new Hn())),
            t.copy(e).clamp(this.min, this.max)
          );
        },
        distanceToPoint: function (e) {
          return Od.copy(e).clamp(this.min, this.max).sub(e).length();
        },
        intersect: function (e) {
          return this.min.max(e.min), this.max.min(e.max), this;
        },
        union: function (e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        },
        translate: function (e) {
          return this.min.add(e), this.max.add(e), this;
        },
        equals: function (e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        },
      });
      var Id = new $n(),
        Nd = new $n();
      function Bd(e, t) {
        (this.start = void 0 !== e ? e : new $n()),
          (this.end = void 0 !== t ? t : new $n());
      }
      function zd(e) {
        Tr.call(this),
          (this.material = e),
          (this.render = function () {}),
          (this.hasPositions = !1),
          (this.hasNormals = !1),
          (this.hasColors = !1),
          (this.hasUvs = !1),
          (this.positionArray = null),
          (this.normalArray = null),
          (this.colorArray = null),
          (this.uvArray = null),
          (this.count = 0);
      }
      Object.assign(Bd.prototype, {
        set: function (e, t) {
          return this.start.copy(e), this.end.copy(t), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (e) {
          return this.start.copy(e.start), this.end.copy(e.end), this;
        },
        getCenter: function (e) {
          return (
            void 0 === e &&
              (console.warn("THREE.Line3: .getCenter() target is now required"),
              (e = new $n())),
            e.addVectors(this.start, this.end).multiplyScalar(0.5)
          );
        },
        delta: function (e) {
          return (
            void 0 === e &&
              (console.warn("THREE.Line3: .delta() target is now required"),
              (e = new $n())),
            e.subVectors(this.end, this.start)
          );
        },
        distanceSq: function () {
          return this.start.distanceToSquared(this.end);
        },
        distance: function () {
          return this.start.distanceTo(this.end);
        },
        at: function (e, t) {
          return (
            void 0 === t &&
              (console.warn("THREE.Line3: .at() target is now required"),
              (t = new $n())),
            this.delta(t).multiplyScalar(e).add(this.start)
          );
        },
        closestPointToPointParameter: function (e, t) {
          Id.subVectors(e, this.start), Nd.subVectors(this.end, this.start);
          var n = Nd.dot(Nd),
            r = Nd.dot(Id) / n;
          return t && (r = kn.clamp(r, 0, 1)), r;
        },
        closestPointToPoint: function (e, t, n) {
          var r = this.closestPointToPointParameter(e, t);
          return (
            void 0 === n &&
              (console.warn(
                "THREE.Line3: .closestPointToPoint() target is now required"
              ),
              (n = new $n())),
            this.delta(n).multiplyScalar(r).add(this.start)
          );
        },
        applyMatrix4: function (e) {
          return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
        },
        equals: function (e) {
          return e.start.equals(this.start) && e.end.equals(this.end);
        },
      }),
        ((zd.prototype = Object.create(Tr.prototype)).constructor = zd),
        (zd.prototype.isImmediateRenderObject = !0);
      var Fd = new $n();
      function Ud(e, t) {
        Tr.call(this),
          (this.light = e),
          this.light.updateMatrixWorld(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = t);
        for (
          var n = new Wi(),
            r = [
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              1,
              0,
              0,
              0,
              -1,
              0,
              1,
              0,
              0,
              0,
              0,
              1,
              1,
              0,
              0,
              0,
              0,
              -1,
              1,
            ],
            i = 0,
            a = 1;
          i < 32;
          i++, a++
        ) {
          var o = (i / 32) * Math.PI * 2,
            s = (a / 32) * Math.PI * 2;
          r.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1);
        }
        n.setAttribute("position", new Ii(r, 3));
        var c = new Tc({ fog: !1, toneMapped: !1 });
        (this.cone = new Ic(n, c)), this.add(this.cone), this.update();
      }
      ((Ud.prototype = Object.create(Tr.prototype)).constructor = Ud),
        (Ud.prototype.dispose = function () {
          this.cone.geometry.dispose(), this.cone.material.dispose();
        }),
        (Ud.prototype.update = function () {
          this.light.updateMatrixWorld();
          var e = this.light.distance ? this.light.distance : 1e3,
            t = e * Math.tan(this.light.angle);
          this.cone.scale.set(t, t, e),
            Fd.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(Fd),
            void 0 !== this.color
              ? this.cone.material.color.set(this.color)
              : this.cone.material.color.copy(this.light.color);
        });
      var Gd = new $n(),
        kd = new sr(),
        Hd = new sr();
      function jd(e) {
        for (
          var t = (function e(t) {
              var n = [];
              t && t.isBone && n.push(t);
              for (var r = 0; r < t.children.length; r++)
                n.push.apply(n, e(t.children[r]));
              return n;
            })(e),
            n = new Wi(),
            r = [],
            i = [],
            a = new vi(0, 0, 1),
            o = new vi(0, 1, 0),
            s = 0;
          s < t.length;
          s++
        ) {
          var c = t[s];
          c.parent &&
            c.parent.isBone &&
            (r.push(0, 0, 0),
            r.push(0, 0, 0),
            i.push(a.r, a.g, a.b),
            i.push(o.r, o.g, o.b));
        }
        n.setAttribute("position", new Ii(r, 3)),
          n.setAttribute("color", new Ii(i, 3));
        var u = new Tc({
          vertexColors: !0,
          depthTest: !1,
          depthWrite: !1,
          toneMapped: !1,
          transparent: !0,
        });
        Ic.call(this, n, u),
          (this.type = "SkeletonHelper"),
          (this.root = e),
          (this.bones = t),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1);
      }
      function Vd(e, t, n) {
        (this.light = e), this.light.updateMatrixWorld(), (this.color = n);
        var r = new qu(t, 4, 2),
          i = new Mi({ wireframe: !0, fog: !1, toneMapped: !1 });
        ua.call(this, r, i),
          (this.type = "PointLightHelper"),
          (this.matrix = this.light.matrixWorld),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      ((jd.prototype = Object.create(Ic.prototype)).constructor = jd),
        (jd.prototype.isSkeletonHelper = !0),
        (jd.prototype.updateMatrixWorld = function (e) {
          var t = this.bones,
            n = this.geometry,
            r = n.getAttribute("position");
          Hd.getInverse(this.root.matrixWorld);
          for (var i = 0, a = 0; i < t.length; i++) {
            var o = t[i];
            o.parent &&
              o.parent.isBone &&
              (kd.multiplyMatrices(Hd, o.matrixWorld),
              Gd.setFromMatrixPosition(kd),
              r.setXYZ(a, Gd.x, Gd.y, Gd.z),
              kd.multiplyMatrices(Hd, o.parent.matrixWorld),
              Gd.setFromMatrixPosition(kd),
              r.setXYZ(a + 1, Gd.x, Gd.y, Gd.z),
              (a += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            Tr.prototype.updateMatrixWorld.call(this, e);
        }),
        ((Vd.prototype = Object.create(ua.prototype)).constructor = Vd),
        (Vd.prototype.dispose = function () {
          this.geometry.dispose(), this.material.dispose();
        }),
        (Vd.prototype.update = function () {
          void 0 !== this.color
            ? this.material.color.set(this.color)
            : this.material.color.copy(this.light.color);
        });
      var Wd = new $n(),
        qd = new vi(),
        Xd = new vi();
      function Yd(e, t, n) {
        Tr.call(this),
          (this.light = e),
          this.light.updateMatrixWorld(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = n);
        var r = new tu(t);
        r.rotateY(0.5 * Math.PI),
          (this.material = new Mi({ wireframe: !0, fog: !1, toneMapped: !1 })),
          void 0 === this.color && (this.material.vertexColors = !0);
        var i = r.getAttribute("position"),
          a = new Float32Array(3 * i.count);
        r.setAttribute("color", new Ei(a, 3)),
          this.add(new ua(r, this.material)),
          this.update();
      }
      function Zd(e, t, n, r) {
        (e = e || 10),
          (t = t || 10),
          (n = new vi(void 0 !== n ? n : 4473924)),
          (r = new vi(void 0 !== r ? r : 8947848));
        for (
          var i = t / 2,
            a = e / t,
            o = e / 2,
            s = [],
            c = [],
            u = 0,
            l = 0,
            h = -o;
          u <= t;
          u++, h += a
        ) {
          s.push(-o, 0, h, o, 0, h), s.push(h, 0, -o, h, 0, o);
          var d = u === i ? n : r;
          d.toArray(c, l),
            (l += 3),
            d.toArray(c, l),
            (l += 3),
            d.toArray(c, l),
            (l += 3),
            d.toArray(c, l),
            (l += 3);
        }
        var p = new Wi();
        p.setAttribute("position", new Ii(s, 3)),
          p.setAttribute("color", new Ii(c, 3));
        var f = new Tc({ vertexColors: !0, toneMapped: !1 });
        Ic.call(this, p, f), (this.type = "GridHelper");
      }
      function Jd(e, t, n, r, i, a) {
        (e = e || 10),
          (t = t || 16),
          (n = n || 8),
          (r = r || 64),
          (i = new vi(void 0 !== i ? i : 4473924)),
          (a = new vi(void 0 !== a ? a : 8947848));
        for (var o = [], s = [], c = 0; c <= t; c++) {
          var u = (c / t) * (2 * Math.PI),
            l = Math.sin(u) * e,
            h = Math.cos(u) * e;
          o.push(0, 0, 0), o.push(l, 0, h);
          var d = 1 & c ? i : a;
          s.push(d.r, d.g, d.b), s.push(d.r, d.g, d.b);
        }
        for (var p = 0; p <= n; p++)
          for (var f = 1 & p ? i : a, m = e - (e / n) * p, v = 0; v < r; v++) {
            var g = (v / r) * (2 * Math.PI),
              y = Math.sin(g) * m,
              x = Math.cos(g) * m;
            o.push(y, 0, x),
              s.push(f.r, f.g, f.b),
              (g = ((v + 1) / r) * (2 * Math.PI)),
              (y = Math.sin(g) * m),
              (x = Math.cos(g) * m),
              o.push(y, 0, x),
              s.push(f.r, f.g, f.b);
          }
        var b = new Wi();
        b.setAttribute("position", new Ii(o, 3)),
          b.setAttribute("color", new Ii(s, 3));
        var _ = new Tc({ vertexColors: !0, toneMapped: !1 });
        Ic.call(this, b, _), (this.type = "PolarGridHelper");
      }
      ((Yd.prototype = Object.create(Tr.prototype)).constructor = Yd),
        (Yd.prototype.dispose = function () {
          this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
        }),
        (Yd.prototype.update = function () {
          var e = this.children[0];
          if (void 0 !== this.color) this.material.color.set(this.color);
          else {
            var t = e.geometry.getAttribute("color");
            qd.copy(this.light.color), Xd.copy(this.light.groundColor);
            for (var n = 0, r = t.count; n < r; n++) {
              var i = n < r / 2 ? qd : Xd;
              t.setXYZ(n, i.r, i.g, i.b);
            }
            t.needsUpdate = !0;
          }
          e.lookAt(Wd.setFromMatrixPosition(this.light.matrixWorld).negate());
        }),
        (Zd.prototype = Object.assign(Object.create(Ic.prototype), {
          constructor: Zd,
          copy: function (e) {
            return (
              Ic.prototype.copy.call(this, e),
              this.geometry.copy(e.geometry),
              this.material.copy(e.material),
              this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
        })),
        ((Jd.prototype = Object.create(Ic.prototype)).constructor = Jd);
      var Kd = new $n(),
        Qd = new $n(),
        $d = new $n();
      function ep(e, t, n) {
        Tr.call(this),
          (this.light = e),
          this.light.updateMatrixWorld(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = n),
          void 0 === t && (t = 1);
        var r = new Wi();
        r.setAttribute(
          "position",
          new Ii([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
        );
        var i = new Tc({ fog: !1, toneMapped: !1 });
        (this.lightPlane = new Pc(r, i)),
          this.add(this.lightPlane),
          (r = new Wi()).setAttribute(
            "position",
            new Ii([0, 0, 0, 0, 0, 1], 3)
          ),
          (this.targetLine = new Pc(r, i)),
          this.add(this.targetLine),
          this.update();
      }
      ((ep.prototype = Object.create(Tr.prototype)).constructor = ep),
        (ep.prototype.dispose = function () {
          this.lightPlane.geometry.dispose(),
            this.lightPlane.material.dispose(),
            this.targetLine.geometry.dispose(),
            this.targetLine.material.dispose();
        }),
        (ep.prototype.update = function () {
          Kd.setFromMatrixPosition(this.light.matrixWorld),
            Qd.setFromMatrixPosition(this.light.target.matrixWorld),
            $d.subVectors(Qd, Kd),
            this.lightPlane.lookAt(Qd),
            void 0 !== this.color
              ? (this.lightPlane.material.color.set(this.color),
                this.targetLine.material.color.set(this.color))
              : (this.lightPlane.material.color.copy(this.light.color),
                this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(Qd),
            (this.targetLine.scale.z = $d.length());
        });
      var tp = new $n(),
        np = new Ma();
      function rp(e) {
        var t = new Wi(),
          n = new Tc({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
          r = [],
          i = [],
          a = {},
          o = new vi(16755200),
          s = new vi(16711680),
          c = new vi(43775),
          u = new vi(16777215),
          l = new vi(3355443);
        function h(e, t, n) {
          d(e, n), d(t, n);
        }
        function d(e, t) {
          r.push(0, 0, 0),
            i.push(t.r, t.g, t.b),
            void 0 === a[e] && (a[e] = []),
            a[e].push(r.length / 3 - 1);
        }
        h("n1", "n2", o),
          h("n2", "n4", o),
          h("n4", "n3", o),
          h("n3", "n1", o),
          h("f1", "f2", o),
          h("f2", "f4", o),
          h("f4", "f3", o),
          h("f3", "f1", o),
          h("n1", "f1", o),
          h("n2", "f2", o),
          h("n3", "f3", o),
          h("n4", "f4", o),
          h("p", "n1", s),
          h("p", "n2", s),
          h("p", "n3", s),
          h("p", "n4", s),
          h("u1", "u2", c),
          h("u2", "u3", c),
          h("u3", "u1", c),
          h("c", "t", u),
          h("p", "c", l),
          h("cn1", "cn2", l),
          h("cn3", "cn4", l),
          h("cf1", "cf2", l),
          h("cf3", "cf4", l),
          t.setAttribute("position", new Ii(r, 3)),
          t.setAttribute("color", new Ii(i, 3)),
          Ic.call(this, t, n),
          (this.type = "CameraHelper"),
          (this.camera = e),
          this.camera.updateProjectionMatrix &&
            this.camera.updateProjectionMatrix(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.pointMap = a),
          this.update();
      }
      function ip(e, t, n, r, i, a, o) {
        tp.set(i, a, o).unproject(r);
        var s = t[e];
        if (void 0 !== s)
          for (
            var c = n.getAttribute("position"), u = 0, l = s.length;
            u < l;
            u++
          )
            c.setXYZ(s[u], tp.x, tp.y, tp.z);
      }
      ((rp.prototype = Object.create(Ic.prototype)).constructor = rp),
        (rp.prototype.update = function () {
          var e = this.geometry,
            t = this.pointMap;
          np.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
            ip("c", t, e, np, 0, 0, -1),
            ip("t", t, e, np, 0, 0, 1),
            ip("n1", t, e, np, -1, -1, -1),
            ip("n2", t, e, np, 1, -1, -1),
            ip("n3", t, e, np, -1, 1, -1),
            ip("n4", t, e, np, 1, 1, -1),
            ip("f1", t, e, np, -1, -1, 1),
            ip("f2", t, e, np, 1, -1, 1),
            ip("f3", t, e, np, -1, 1, 1),
            ip("f4", t, e, np, 1, 1, 1),
            ip("u1", t, e, np, 0.7, 1.1, -1),
            ip("u2", t, e, np, -0.7, 1.1, -1),
            ip("u3", t, e, np, 0, 2, -1),
            ip("cf1", t, e, np, -1, 0, 1),
            ip("cf2", t, e, np, 1, 0, 1),
            ip("cf3", t, e, np, 0, -1, 1),
            ip("cf4", t, e, np, 0, 1, 1),
            ip("cn1", t, e, np, -1, 0, -1),
            ip("cn2", t, e, np, 1, 0, -1),
            ip("cn3", t, e, np, 0, -1, -1),
            ip("cn4", t, e, np, 0, 1, -1),
            (e.getAttribute("position").needsUpdate = !0);
        });
      var ap = new Gr();
      function op(e, t) {
        (this.object = e), void 0 === t && (t = 16776960);
        var n = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7,
          ]),
          r = new Float32Array(24),
          i = new Wi();
        i.setIndex(new Ei(n, 1)),
          i.setAttribute("position", new Ei(r, 3)),
          Ic.call(this, i, new Tc({ color: t, toneMapped: !1 })),
          (this.type = "BoxHelper"),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      function sp(e, t) {
        (this.type = "Box3Helper"), (this.box = e), (t = t || 16776960);
        var n = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7,
          ]),
          r = new Wi();
        r.setIndex(new Ei(n, 1)),
          r.setAttribute(
            "position",
            new Ii(
              [
                1,
                1,
                1,
                -1,
                1,
                1,
                -1,
                -1,
                1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                -1,
              ],
              3
            )
          ),
          Ic.call(this, r, new Tc({ color: t, toneMapped: !1 })),
          (this.type = "Box3Helper"),
          this.geometry.computeBoundingSphere();
      }
      function cp(e, t, n) {
        (this.plane = e), (this.size = void 0 === t ? 1 : t);
        var r = void 0 !== n ? n : 16776960,
          i = new Wi();
        i.setAttribute(
          "position",
          new Ii(
            [
              1,
              -1,
              1,
              -1,
              1,
              1,
              -1,
              -1,
              1,
              1,
              1,
              1,
              -1,
              1,
              1,
              -1,
              -1,
              1,
              1,
              -1,
              1,
              1,
              1,
              1,
              0,
              0,
              1,
              0,
              0,
              0,
            ],
            3
          )
        ),
          i.computeBoundingSphere(),
          Pc.call(this, i, new Tc({ color: r, toneMapped: !1 })),
          (this.type = "PlaneHelper");
        var a = new Wi();
        a.setAttribute(
          "position",
          new Ii(
            [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
            3
          )
        ),
          a.computeBoundingSphere(),
          this.add(
            new ua(
              a,
              new Mi({
                color: r,
                opacity: 0.2,
                transparent: !0,
                depthWrite: !1,
                toneMapped: !1,
              })
            )
          );
      }
      ((op.prototype = Object.create(Ic.prototype)).constructor = op),
        (op.prototype.update = function (e) {
          if (
            (void 0 !== e &&
              console.warn(
                "THREE.BoxHelper: .update() has no longer arguments."
              ),
            void 0 !== this.object && ap.setFromObject(this.object),
            !ap.isEmpty())
          ) {
            var t = ap.min,
              n = ap.max,
              r = this.geometry.attributes.position,
              i = r.array;
            (i[0] = n.x),
              (i[1] = n.y),
              (i[2] = n.z),
              (i[3] = t.x),
              (i[4] = n.y),
              (i[5] = n.z),
              (i[6] = t.x),
              (i[7] = t.y),
              (i[8] = n.z),
              (i[9] = n.x),
              (i[10] = t.y),
              (i[11] = n.z),
              (i[12] = n.x),
              (i[13] = n.y),
              (i[14] = t.z),
              (i[15] = t.x),
              (i[16] = n.y),
              (i[17] = t.z),
              (i[18] = t.x),
              (i[19] = t.y),
              (i[20] = t.z),
              (i[21] = n.x),
              (i[22] = t.y),
              (i[23] = t.z),
              (r.needsUpdate = !0),
              this.geometry.computeBoundingSphere();
          }
        }),
        (op.prototype.setFromObject = function (e) {
          return (this.object = e), this.update(), this;
        }),
        (op.prototype.copy = function (e) {
          return (
            Ic.prototype.copy.call(this, e), (this.object = e.object), this
          );
        }),
        (op.prototype.clone = function () {
          return new this.constructor().copy(this);
        }),
        ((sp.prototype = Object.create(Ic.prototype)).constructor = sp),
        (sp.prototype.updateMatrixWorld = function (e) {
          var t = this.box;
          t.isEmpty() ||
            (t.getCenter(this.position),
            t.getSize(this.scale),
            this.scale.multiplyScalar(0.5),
            Tr.prototype.updateMatrixWorld.call(this, e));
        }),
        ((cp.prototype = Object.create(Pc.prototype)).constructor = cp),
        (cp.prototype.updateMatrixWorld = function (e) {
          var t = -this.plane.constant;
          Math.abs(t) < 1e-8 && (t = 1e-8),
            this.scale.set(0.5 * this.size, 0.5 * this.size, t),
            (this.children[0].material.side = t < 0 ? y : g),
            this.lookAt(this.plane.normal),
            Tr.prototype.updateMatrixWorld.call(this, e);
        });
      var up,
        lp,
        hp = new $n();
      function dp(e, t, n, r, i, a) {
        Tr.call(this),
          (this.type = "ArrowHelper"),
          void 0 === e && (e = new $n(0, 0, 1)),
          void 0 === t && (t = new $n(0, 0, 0)),
          void 0 === n && (n = 1),
          void 0 === r && (r = 16776960),
          void 0 === i && (i = 0.2 * n),
          void 0 === a && (a = 0.2 * i),
          void 0 === up &&
            ((up = new Wi()).setAttribute(
              "position",
              new Ii([0, 0, 0, 0, 1, 0], 3)
            ),
            (lp = new nl(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
          this.position.copy(t),
          (this.line = new Pc(up, new Tc({ color: r, toneMapped: !1 }))),
          (this.line.matrixAutoUpdate = !1),
          this.add(this.line),
          (this.cone = new ua(lp, new Mi({ color: r, toneMapped: !1 }))),
          (this.cone.matrixAutoUpdate = !1),
          this.add(this.cone),
          this.setDirection(e),
          this.setLength(n, i, a);
      }
      function pp(e) {
        var t = [
            0,
            0,
            0,
            (e = e || 1),
            0,
            0,
            0,
            0,
            0,
            0,
            e,
            0,
            0,
            0,
            0,
            0,
            0,
            e,
          ],
          n = new Wi();
        n.setAttribute("position", new Ii(t, 3)),
          n.setAttribute(
            "color",
            new Ii(
              [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
              3
            )
          );
        var r = new Tc({ vertexColors: !0, toneMapped: !1 });
        Ic.call(this, n, r), (this.type = "AxesHelper");
      }
      ((dp.prototype = Object.create(Tr.prototype)).constructor = dp),
        (dp.prototype.setDirection = function (e) {
          if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
          else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
          else {
            hp.set(e.z, 0, -e.x).normalize();
            var t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(hp, t);
          }
        }),
        (dp.prototype.setLength = function (e, t, n) {
          void 0 === t && (t = 0.2 * e),
            void 0 === n && (n = 0.2 * t),
            this.line.scale.set(1, Math.max(1e-4, e - t), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(n, t, n),
            (this.cone.position.y = e),
            this.cone.updateMatrix();
        }),
        (dp.prototype.setColor = function (e) {
          this.line.material.color.set(e), this.cone.material.color.set(e);
        }),
        (dp.prototype.copy = function (e) {
          return (
            Tr.prototype.copy.call(this, e, !1),
            this.line.copy(e.line),
            this.cone.copy(e.cone),
            this
          );
        }),
        (dp.prototype.clone = function () {
          return new this.constructor().copy(this);
        }),
        ((pp.prototype = Object.create(Ic.prototype)).constructor = pp);
      var fp = Math.pow(2, 8),
        mp = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        vp = 5 + mp.length,
        gp =
          (_defineProperty((r = {}), $t, 0),
          _defineProperty(r, en, 1),
          _defineProperty(r, nn, 2),
          _defineProperty(r, an, 3),
          _defineProperty(r, on, 4),
          _defineProperty(r, sn, 5),
          _defineProperty(r, tn, 6),
          r),
        yp = new wh(),
        xp = (function () {
          for (var e = [], t = [], n = [], r = 8, i = 0; i < vp; i++) {
            var a = Math.pow(2, r);
            t.push(a);
            var o = 1 / a;
            i > 4 ? (o = mp[i - 8 + 4 - 1]) : 0 == i && (o = 0), n.push(o);
            for (
              var s = 1 / (a - 1),
                c = -s / 2,
                u = 1 + s / 2,
                l = [c, c, u, c, u, u, c, c, u, u, c, u],
                h = new Float32Array(108),
                d = new Float32Array(72),
                p = new Float32Array(36),
                f = 0;
              f < 6;
              f++
            ) {
              var m = ((f % 3) * 2) / 3 - 1,
                v = f > 2 ? 0 : -1;
              h.set(
                [
                  m,
                  v,
                  0,
                  m + 2 / 3,
                  v,
                  0,
                  m + 2 / 3,
                  v + 1,
                  0,
                  m,
                  v,
                  0,
                  m + 2 / 3,
                  v + 1,
                  0,
                  m,
                  v + 1,
                  0,
                ],
                18 * f
              ),
                d.set(l, 12 * f),
                p.set([f, f, f, f, f, f], 6 * f);
            }
            var g = new Wi();
            g.setAttribute("position", new Ei(h, 3)),
              g.setAttribute("uv", new Ei(d, 2)),
              g.setAttribute("faceIndex", new Ei(p, 1)),
              e.push(g),
              r > 4 && r--;
          }
          return { _lodPlanes: e, _sizeLods: t, _sigmas: n };
        })(),
        bp = xp._lodPlanes,
        _p = xp._sizeLods,
        wp = xp._sigmas,
        Mp = null,
        Sp = (1 + Math.sqrt(5)) / 2,
        Tp = 1 / Sp,
        Ep = [
          new $n(1, 1, 1),
          new $n(-1, 1, 1),
          new $n(1, 1, -1),
          new $n(-1, 1, -1),
          new $n(0, Sp, Tp),
          new $n(0, Sp, -Tp),
          new $n(Tp, 0, Sp),
          new $n(-Tp, 0, Sp),
          new $n(Sp, Tp, 0),
          new $n(-Sp, Tp, 0),
        ];
      function Ap(e) {
        (this._renderer = e),
          (this._pingPongRenderTarget = null),
          (this._blurMaterial = new ul({
            name: "SphericalGaussianBlur",
            defines: { n: 20 },
            uniforms: {
              envMap: { value: null },
              samples: { value: 1 },
              weights: { value: new Float32Array(20) },
              latitudinal: { value: !1 },
              dTheta: { value: 0 },
              mipInt: { value: 0 },
              poleAxis: { value: new $n(0, 1, 0) },
              inputEncoding: { value: gp[$t] },
              outputEncoding: { value: gp[$t] },
            },
            vertexShader:
              "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
            fragmentShader:
              "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
            blending: w,
            depthTest: !1,
            depthWrite: !1,
          })),
          (this._equirectShader = null),
          (this._cubemapShader = null),
          this._compileMaterial(this._blurMaterial);
      }
      function Lp(e) {
        return (
          void 0 !== e &&
          e.type === Ae &&
          (e.encoding === $t || e.encoding === en || e.encoding === tn)
        );
      }
      function Cp(e) {
        var t = new Yn(3 * fp, 3 * fp, e);
        return (
          (t.texture.mapping = de),
          (t.texture.name = "PMREM.cubeUv"),
          (t.scissorTest = !0),
          t
        );
      }
      function Rp(e, t, n, r, i) {
        e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i);
      }
      function Pp() {
        return new ul({
          name: "EquirectangularToCubeUV",
          uniforms: {
            envMap: { value: null },
            texelSize: { value: new Hn(1, 1) },
            inputEncoding: { value: gp[$t] },
            outputEncoding: { value: gp[$t] },
          },
          vertexShader:
            "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
          fragmentShader:
            "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\n#include <common>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv = equirectUv( outputDirection );\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
          blending: w,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Op() {
        return new ul({
          name: "CubemapToCubeUV",
          uniforms: {
            envMap: { value: null },
            inputEncoding: { value: gp[$t] },
            outputEncoding: { value: gp[$t] },
          },
          vertexShader:
            "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
          fragmentShader:
            "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
          blending: w,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Dp(e, t, n, r, i, a, o) {
        return (
          console.warn(
            "THREE.Face4 has been removed. A THREE.Face3 will be created instead."
          ),
          new bi(e, t, n, i, a, o)
        );
      }
      Ap.prototype = {
        constructor: Ap,
        fromScene: function (e) {
          var t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 0,
            n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : 0.1,
            r =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : 100;
          Mp = this._renderer.getRenderTarget();
          var i = this._allocateTargets();
          return (
            this._sceneToCubeUV(e, n, r, i),
            t > 0 && this._blur(i, 0, 0, t),
            this._applyPMREM(i),
            this._cleanup(i),
            i
          );
        },
        fromEquirectangular: function (e) {
          return this._fromTexture(e);
        },
        fromCubemap: function (e) {
          return this._fromTexture(e);
        },
        compileCubemapShader: function () {
          null === this._cubemapShader &&
            ((this._cubemapShader = Op()),
            this._compileMaterial(this._cubemapShader));
        },
        compileEquirectangularShader: function () {
          null === this._equirectShader &&
            ((this._equirectShader = Pp()),
            this._compileMaterial(this._equirectShader));
        },
        dispose: function () {
          this._blurMaterial.dispose(),
            null !== this._cubemapShader && this._cubemapShader.dispose(),
            null !== this._equirectShader && this._equirectShader.dispose();
          for (var e = 0; e < bp.length; e++) bp[e].dispose();
        },
        _cleanup: function (e) {
          this._pingPongRenderTarget.dispose(),
            this._renderer.setRenderTarget(Mp),
            (e.scissorTest = !1),
            Rp(e, 0, 0, e.width, e.height);
        },
        _fromTexture: function (e) {
          Mp = this._renderer.getRenderTarget();
          var t = this._allocateTargets(e);
          return (
            this._textureToCubeUV(e, t),
            this._applyPMREM(t),
            this._cleanup(t),
            t
          );
        },
        _allocateTargets: function (e) {
          var t = {
              magFilter: ge,
              minFilter: ge,
              generateMipmaps: !1,
              type: Ae,
              format: Ve,
              encoding: Lp(e) ? e.encoding : nn,
              depthBuffer: !1,
              stencilBuffer: !1,
            },
            n = Cp(t);
          return (n.depthBuffer = !e), (this._pingPongRenderTarget = Cp(t)), n;
        },
        _compileMaterial: function (e) {
          var t = new ua(bp[0], e);
          this._renderer.compile(t, yp);
        },
        _sceneToCubeUV: function (e, t, n, r) {
          var i = new Sa(90, 1, t, n),
            a = [1, -1, 1, 1, 1, 1],
            o = [1, 1, 1, -1, -1, -1],
            s = this._renderer,
            c = s.outputEncoding,
            u = s.toneMapping,
            l = s.getClearColor(),
            h = s.getClearAlpha();
          (s.toneMapping = te), (s.outputEncoding = $t);
          var d = e.background;
          if (d && d.isColor) {
            d.convertSRGBToLinear();
            var p = Math.max(d.r, d.g, d.b),
              f = Math.min(Math.max(Math.ceil(Math.log2(p)), -128), 127);
            (d = d.multiplyScalar(Math.pow(2, -f))),
              s.setClearColor(d, (f + 128) / 255),
              (e.background = null);
          }
          for (var m = 0; m < 6; m++) {
            var v = m % 3;
            0 == v
              ? (i.up.set(0, a[m], 0), i.lookAt(o[m], 0, 0))
              : 1 == v
              ? (i.up.set(0, 0, a[m]), i.lookAt(0, o[m], 0))
              : (i.up.set(0, a[m], 0), i.lookAt(0, 0, o[m])),
              Rp(r, v * fp, m > 2 ? fp : 0, fp, fp),
              s.setRenderTarget(r),
              s.render(e, i);
          }
          (s.toneMapping = u), (s.outputEncoding = c), s.setClearColor(l, h);
        },
        _textureToCubeUV: function (e, t) {
          var n = this._renderer;
          e.isCubeTexture
            ? null == this._cubemapShader && (this._cubemapShader = Op())
            : null == this._equirectShader && (this._equirectShader = Pp());
          var r = e.isCubeTexture ? this._cubemapShader : this._equirectShader,
            i = new ua(bp[0], r),
            a = r.uniforms;
          (a.envMap.value = e),
            e.isCubeTexture ||
              a.texelSize.value.set(1 / e.image.width, 1 / e.image.height),
            (a.inputEncoding.value = gp[e.encoding]),
            (a.outputEncoding.value = gp[t.texture.encoding]),
            Rp(t, 0, 0, 3 * fp, 2 * fp),
            n.setRenderTarget(t),
            n.render(i, yp);
        },
        _applyPMREM: function (e) {
          var t = this._renderer,
            n = t.autoClear;
          t.autoClear = !1;
          for (var r = 1; r < vp; r++) {
            var i = Math.sqrt(wp[r] * wp[r] - wp[r - 1] * wp[r - 1]);
            this._blur(e, r - 1, r, i, Ep[(r - 1) % Ep.length]);
          }
          t.autoClear = n;
        },
        _blur: function (e, t, n, r, i) {
          var a = this._pingPongRenderTarget;
          this._halfBlur(e, a, t, n, r, "latitudinal", i),
            this._halfBlur(a, e, n, n, r, "longitudinal", i);
        },
        _halfBlur: function (e, t, n, r, i, a, o) {
          var s = this._renderer,
            c = this._blurMaterial;
          "latitudinal" !== a &&
            "longitudinal" !== a &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          var u = new ua(bp[r], c),
            l = c.uniforms,
            h = _p[n] - 1,
            d = isFinite(i) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
            p = i / d,
            f = isFinite(i) ? 1 + Math.floor(3 * p) : 20;
          f > 20 &&
            console.warn(
              "sigmaRadians, "
                .concat(i, ", is too large and will clip, as it requested ")
                .concat(f, " samples when the maximum is set to 20")
            );
          for (var m = [], v = 0, g = 0; g < 20; ++g) {
            var y = g / p,
              x = Math.exp((-y * y) / 2);
            m.push(x), 0 == g ? (v += x) : g < f && (v += 2 * x);
          }
          for (var b = 0; b < m.length; b++) m[b] = m[b] / v;
          (l.envMap.value = e.texture),
            (l.samples.value = f),
            (l.weights.value = m),
            (l.latitudinal.value = "latitudinal" === a),
            o && (l.poleAxis.value = o),
            (l.dTheta.value = d),
            (l.mipInt.value = 8 - n),
            (l.inputEncoding.value = gp[e.texture.encoding]),
            (l.outputEncoding.value = gp[e.texture.encoding]);
          var _ = _p[r];
          Rp(
            t,
            3 * Math.max(0, fp - 2 * _),
            (0 === r ? 0 : 2 * fp) + 2 * _ * (r > 4 ? r - 8 + 4 : 0),
            3 * _,
            2 * _
          ),
            s.setRenderTarget(t),
            s.render(u, yp);
        },
      };
      var Ip = 0,
        Np = 1,
        Bp = 0,
        zp = 1,
        Fp = 2;
      function Up(e) {
        return (
          console.warn(
            "THREE.MeshFaceMaterial has been removed. Use an Array instead."
          ),
          e
        );
      }
      function Gp(e) {
        return (
          void 0 === e && (e = []),
          console.warn(
            "THREE.MultiMaterial has been removed. Use an Array instead."
          ),
          (e.isMultiMaterial = !0),
          (e.materials = e),
          (e.clone = function () {
            return e.slice();
          }),
          e
        );
      }
      function kp(e, t) {
        return (
          console.warn("THREE.PointCloud has been renamed to THREE.Points."),
          new kc(e, t)
        );
      }
      function Hp(e) {
        return (
          console.warn("THREE.Particle has been renamed to THREE.Sprite."),
          new ac(e)
        );
      }
      function jp(e, t) {
        return (
          console.warn(
            "THREE.ParticleSystem has been renamed to THREE.Points."
          ),
          new kc(e, t)
        );
      }
      function Vp(e) {
        return (
          console.warn(
            "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Bc(e)
        );
      }
      function Wp(e) {
        return (
          console.warn(
            "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Bc(e)
        );
      }
      function qp(e) {
        return (
          console.warn(
            "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Bc(e)
        );
      }
      function Xp(e, t, n) {
        return (
          console.warn(
            "THREE.Vertex has been removed. Use THREE.Vector3 instead."
          ),
          new $n(e, t, n)
        );
      }
      function Yp(e, t) {
        return (
          console.warn(
            "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
          ),
          new Ei(e, t).setUsage(Cn)
        );
      }
      function Zp(e, t) {
        return (
          console.warn(
            "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
          ),
          new Ai(e, t)
        );
      }
      function Jp(e, t) {
        return (
          console.warn(
            "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
          ),
          new Li(e, t)
        );
      }
      function Kp(e, t) {
        return (
          console.warn(
            "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
          ),
          new Ci(e, t)
        );
      }
      function Qp(e, t) {
        return (
          console.warn(
            "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
          ),
          new Ri(e, t)
        );
      }
      function $p(e, t) {
        return (
          console.warn(
            "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
          ),
          new Pi(e, t)
        );
      }
      function ef(e, t) {
        return (
          console.warn(
            "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
          ),
          new Oi(e, t)
        );
      }
      function tf(e, t) {
        return (
          console.warn(
            "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
          ),
          new Di(e, t)
        );
      }
      function nf(e, t) {
        return (
          console.warn(
            "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
          ),
          new Ii(e, t)
        );
      }
      function rf(e, t) {
        return (
          console.warn(
            "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
          ),
          new Ni(e, t)
        );
      }
      function af(e) {
        console.warn(
          "THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
        ),
          eh.call(this, e),
          (this.type = "catmullrom"),
          (this.closed = !0);
      }
      function of(e) {
        console.warn(
          "THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
        ),
          eh.call(this, e),
          (this.type = "catmullrom");
      }
      function sf(e) {
        console.warn(
          "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
        ),
          eh.call(this, e),
          (this.type = "catmullrom");
      }
      function cf(e) {
        return (
          console.warn(
            "THREE.AxisHelper has been renamed to THREE.AxesHelper."
          ),
          new pp(e)
        );
      }
      function uf(e, t) {
        return (
          console.warn(
            "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
          ),
          new op(e, t)
        );
      }
      function lf(e, t) {
        return (
          console.warn(
            "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
          ),
          new Ic(
            new el(e.geometry),
            new Tc({ color: void 0 !== t ? t : 16777215 })
          )
        );
      }
      function hf(e, t) {
        return (
          console.warn(
            "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
          ),
          new Ic(
            new Xc(e.geometry),
            new Tc({ color: void 0 !== t ? t : 16777215 })
          )
        );
      }
      function df(e) {
        return (
          console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
          new Ul(e)
        );
      }
      function pf(e) {
        return (
          console.warn(
            "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
          ),
          new Hl(e)
        );
      }
      function ff(e, t, n) {
        return (
          console.warn(
            "THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
          ),
          new Ea(e, n)
        );
      }
      (ql.create = function (e, t) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (e.prototype = Object.create(ql.prototype)),
          (e.prototype.constructor = e),
          (e.prototype.getPoint = t),
          e
        );
      }),
        Object.assign(dh.prototype, {
          createPointsGeometry: function (e) {
            console.warn(
              "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
            );
            var t = this.getPoints(e);
            return this.createGeometry(t);
          },
          createSpacedPointsGeometry: function (e) {
            console.warn(
              "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
            );
            var t = this.getSpacedPoints(e);
            return this.createGeometry(t);
          },
          createGeometry: function (e) {
            console.warn(
              "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
            );
            for (var t = new va(), n = 0, r = e.length; n < r; n++) {
              var i = e[n];
              t.vertices.push(new $n(i.x, i.y, i.z || 0));
            }
            return t;
          },
        }),
        Object.assign(ph.prototype, {
          fromPoints: function (e) {
            return (
              console.warn(
                "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
              ),
              this.setFromPoints(e)
            );
          },
        }),
        (af.prototype = Object.create(eh.prototype)),
        (of.prototype = Object.create(eh.prototype)),
        (sf.prototype = Object.create(eh.prototype)),
        Object.assign(sf.prototype, {
          initFromArray: function () {
            console.error("THREE.Spline: .initFromArray() has been removed.");
          },
          getControlPointsArray: function () {
            console.error(
              "THREE.Spline: .getControlPointsArray() has been removed."
            );
          },
          reparametrizeByArcLength: function () {
            console.error(
              "THREE.Spline: .reparametrizeByArcLength() has been removed."
            );
          },
        }),
        (Zd.prototype.setColors = function () {
          console.error(
            "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
          );
        }),
        (jd.prototype.update = function () {
          console.error(
            "THREE.SkeletonHelper: update() no longer needs to be called."
          );
        }),
        Object.assign(zl.prototype, {
          extractUrlBase: function (e) {
            return (
              console.warn(
                "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
              ),
              Rh.extractUrlBase(e)
            );
          },
        }),
        (zl.Handlers = {
          add: function () {
            console.error(
              "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
            );
          },
          get: function () {
            console.error(
              "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
            );
          },
        }),
        Object.assign(Nh.prototype, {
          setTexturePath: function (e) {
            return (
              console.warn(
                "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
              ),
              this.setResourcePath(e)
            );
          },
        }),
        Object.assign(Dd.prototype, {
          center: function (e) {
            return (
              console.warn(
                "THREE.Box2: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(e)
            );
          },
          empty: function () {
            return (
              console.warn(
                "THREE.Box2: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          },
          isIntersectionBox: function (e) {
            return (
              console.warn(
                "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(e)
            );
          },
          size: function (e) {
            return (
              console.warn(
                "THREE.Box2: .size() has been renamed to .getSize()."
              ),
              this.getSize(e)
            );
          },
        }),
        Object.assign(Gr.prototype, {
          center: function (e) {
            return (
              console.warn(
                "THREE.Box3: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(e)
            );
          },
          empty: function () {
            return (
              console.warn(
                "THREE.Box3: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          },
          isIntersectionBox: function (e) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(e)
            );
          },
          isIntersectionSphere: function (e) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(e)
            );
          },
          size: function (e) {
            return (
              console.warn(
                "THREE.Box3: .size() has been renamed to .getSize()."
              ),
              this.getSize(e)
            );
          },
        }),
        Object.assign(jr.prototype, {
          empty: function () {
            return (
              console.warn(
                "THREE.Sphere: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          },
        }),
        (Ra.prototype.setFromMatrix = function (e) {
          return (
            console.warn(
              "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
            ),
            this.setFromProjectionMatrix(e)
          );
        }),
        (Bd.prototype.center = function (e) {
          return (
            console.warn(
              "THREE.Line3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(e)
          );
        }),
        Object.assign(kn, {
          random16: function () {
            return (
              console.warn(
                "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
              ),
              Math.random()
            );
          },
          nearestPowerOfTwo: function (e) {
            return (
              console.warn(
                "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
              ),
              kn.floorPowerOfTwo(e)
            );
          },
          nextPowerOfTwo: function (e) {
            return (
              console.warn(
                "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
              ),
              kn.ceilPowerOfTwo(e)
            );
          },
        }),
        Object.assign(jn.prototype, {
          flattenToArrayOffset: function (e, t) {
            return (
              console.warn(
                "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(e, t)
            );
          },
          multiplyVector3: function (e) {
            return (
              console.warn(
                "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
              ),
              e.applyMatrix3(this)
            );
          },
          multiplyVector3Array: function () {
            console.error(
              "THREE.Matrix3: .multiplyVector3Array() has been removed."
            );
          },
          applyToBufferAttribute: function (e) {
            return (
              console.warn(
                "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
              ),
              e.applyMatrix3(this)
            );
          },
          applyToVector3Array: function () {
            console.error(
              "THREE.Matrix3: .applyToVector3Array() has been removed."
            );
          },
        }),
        Object.assign(sr.prototype, {
          extractPosition: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
              ),
              this.copyPosition(e)
            );
          },
          flattenToArrayOffset: function (e, t) {
            return (
              console.warn(
                "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(e, t)
            );
          },
          getPosition: function () {
            return (
              console.warn(
                "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
              ),
              new $n().setFromMatrixColumn(this, 3)
            );
          },
          setRotationFromQuaternion: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
              ),
              this.makeRotationFromQuaternion(e)
            );
          },
          multiplyToArray: function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
          },
          multiplyVector3: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              e.applyMatrix4(this)
            );
          },
          multiplyVector4: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              e.applyMatrix4(this)
            );
          },
          multiplyVector3Array: function () {
            console.error(
              "THREE.Matrix4: .multiplyVector3Array() has been removed."
            );
          },
          rotateAxis: function (e) {
            console.warn(
              "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
            ),
              e.transformDirection(this);
          },
          crossVector: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              e.applyMatrix4(this)
            );
          },
          translate: function () {
            console.error("THREE.Matrix4: .translate() has been removed.");
          },
          rotateX: function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
          },
          rotateY: function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
          },
          rotateZ: function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
          },
          rotateByAxis: function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
          },
          applyToBufferAttribute: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
              ),
              e.applyMatrix4(this)
            );
          },
          applyToVector3Array: function () {
            console.error(
              "THREE.Matrix4: .applyToVector3Array() has been removed."
            );
          },
          makeFrustum: function (e, t, n, r, i, a) {
            return (
              console.warn(
                "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
              ),
              this.makePerspective(e, t, r, n, i, a)
            );
          },
        }),
        (ti.prototype.isIntersectionLine = function (e) {
          return (
            console.warn(
              "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
            ),
            this.intersectsLine(e)
          );
        }),
        (Jn.prototype.multiplyVector3 = function (e) {
          return (
            console.warn(
              "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
            ),
            e.applyQuaternion(this)
          );
        }),
        Object.assign(Kr.prototype, {
          isIntersectionBox: function (e) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(e)
            );
          },
          isIntersectionPlane: function (e) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
              ),
              this.intersectsPlane(e)
            );
          },
          isIntersectionSphere: function (e) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(e)
            );
          },
        }),
        Object.assign(di.prototype, {
          area: function () {
            return (
              console.warn(
                "THREE.Triangle: .area() has been renamed to .getArea()."
              ),
              this.getArea()
            );
          },
          barycoordFromPoint: function (e, t) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              this.getBarycoord(e, t)
            );
          },
          midpoint: function (e) {
            return (
              console.warn(
                "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
              ),
              this.getMidpoint(e)
            );
          },
          normal: function (e) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              this.getNormal(e)
            );
          },
          plane: function (e) {
            return (
              console.warn(
                "THREE.Triangle: .plane() has been renamed to .getPlane()."
              ),
              this.getPlane(e)
            );
          },
        }),
        Object.assign(di, {
          barycoordFromPoint: function (e, t, n, r, i) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              di.getBarycoord(e, t, n, r, i)
            );
          },
          normal: function (e, t, n, r) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              di.getNormal(e, t, n, r)
            );
          },
        }),
        Object.assign(fh.prototype, {
          extractAllPoints: function (e) {
            return (
              console.warn(
                "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
              ),
              this.extractPoints(e)
            );
          },
          extrude: function (e) {
            return (
              console.warn(
                "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
              ),
              new Uu(this, e)
            );
          },
          makeGeometry: function (e) {
            return (
              console.warn(
                "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
              ),
              new Ku(this, e)
            );
          },
        }),
        Object.assign(Hn.prototype, {
          fromAttribute: function (e, t, n) {
            return (
              console.warn(
                "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(e, t, n)
            );
          },
          distanceToManhattan: function (e) {
            return (
              console.warn(
                "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(e)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign($n.prototype, {
          setEulerFromRotationMatrix: function () {
            console.error(
              "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
            );
          },
          setEulerFromQuaternion: function () {
            console.error(
              "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
            );
          },
          getPositionFromMatrix: function (e) {
            return (
              console.warn(
                "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
              ),
              this.setFromMatrixPosition(e)
            );
          },
          getScaleFromMatrix: function (e) {
            return (
              console.warn(
                "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
              ),
              this.setFromMatrixScale(e)
            );
          },
          getColumnFromMatrix: function (e, t) {
            return (
              console.warn(
                "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
              ),
              this.setFromMatrixColumn(t, e)
            );
          },
          applyProjection: function (e) {
            return (
              console.warn(
                "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
              ),
              this.applyMatrix4(e)
            );
          },
          fromAttribute: function (e, t, n) {
            return (
              console.warn(
                "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(e, t, n)
            );
          },
          distanceToManhattan: function (e) {
            return (
              console.warn(
                "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(e)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign(Xn.prototype, {
          fromAttribute: function (e, t, n) {
            return (
              console.warn(
                "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(e, t, n)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign(va.prototype, {
          computeTangents: function () {
            console.error(
              "THREE.Geometry: .computeTangents() has been removed."
            );
          },
          computeLineDistances: function () {
            console.error(
              "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
            );
          },
          applyMatrix: function (e) {
            return (
              console.warn(
                "THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(e)
            );
          },
        }),
        Object.assign(Tr.prototype, {
          getChildByName: function (e) {
            return (
              console.warn(
                "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
              ),
              this.getObjectByName(e)
            );
          },
          renderDepth: function () {
            console.warn(
              "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
            );
          },
          translate: function (e, t) {
            return (
              console.warn(
                "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
              ),
              this.translateOnAxis(t, e)
            );
          },
          getWorldRotation: function () {
            console.error(
              "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
            );
          },
          applyMatrix: function (e) {
            return (
              console.warn(
                "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(e)
            );
          },
        }),
        Object.defineProperties(Tr.prototype, {
          eulerOrder: {
            get: function () {
              return (
                console.warn(
                  "THREE.Object3D: .eulerOrder is now .rotation.order."
                ),
                this.rotation.order
              );
            },
            set: function (e) {
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
                (this.rotation.order = e);
            },
          },
          useQuaternion: {
            get: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
            set: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
          },
        }),
        Object.assign(ua.prototype, {
          setDrawMode: function () {
            console.error(
              "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        }),
        Object.defineProperties(ua.prototype, {
          drawMode: {
            get: function () {
              return (
                console.error(
                  "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
                ),
                Jt
              );
            },
            set: function () {
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
              );
            },
          },
        }),
        Object.defineProperties(fc.prototype, {
          objects: {
            get: function () {
              return (
                console.warn(
                  "THREE.LOD: .objects has been renamed to .levels."
                ),
                this.levels
              );
            },
          },
        }),
        Object.defineProperty(yc.prototype, "useVertexTexture", {
          get: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
          },
          set: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
          },
        }),
        (mc.prototype.initBones = function () {
          console.error("THREE.SkinnedMesh: initBones() has been removed.");
        }),
        Object.defineProperty(ql.prototype, "__arcLengthDivisions", {
          get: function () {
            return (
              console.warn(
                "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
              ),
              this.arcLengthDivisions
            );
          },
          set: function (e) {
            console.warn(
              "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
            ),
              (this.arcLengthDivisions = e);
          },
        }),
        (Sa.prototype.setLens = function (e, t) {
          console.warn(
            "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
          ),
            void 0 !== t && (this.filmGauge = t),
            this.setFocalLength(e);
        }),
        Object.defineProperties(mh.prototype, {
          onlyShadow: {
            set: function () {
              console.warn("THREE.Light: .onlyShadow has been removed.");
            },
          },
          shadowCameraFov: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
              ),
                (this.shadow.camera.fov = e);
            },
          },
          shadowCameraLeft: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
              ),
                (this.shadow.camera.left = e);
            },
          },
          shadowCameraRight: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
              ),
                (this.shadow.camera.right = e);
            },
          },
          shadowCameraTop: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
              ),
                (this.shadow.camera.top = e);
            },
          },
          shadowCameraBottom: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
              ),
                (this.shadow.camera.bottom = e);
            },
          },
          shadowCameraNear: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
              ),
                (this.shadow.camera.near = e);
            },
          },
          shadowCameraFar: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
              ),
                (this.shadow.camera.far = e);
            },
          },
          shadowCameraVisible: {
            set: function () {
              console.warn(
                "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
              );
            },
          },
          shadowBias: {
            set: function (e) {
              console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                (this.shadow.bias = e);
            },
          },
          shadowDarkness: {
            set: function () {
              console.warn("THREE.Light: .shadowDarkness has been removed.");
            },
          },
          shadowMapWidth: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
              ),
                (this.shadow.mapSize.width = e);
            },
          },
          shadowMapHeight: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
              ),
                (this.shadow.mapSize.height = e);
            },
          },
        }),
        Object.defineProperties(Ei.prototype, {
          length: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                ),
                this.array.length
              );
            },
          },
          dynamic: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                ),
                this.usage === Cn
              );
            },
            set: function () {
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
                this.setUsage(Cn);
            },
          },
        }),
        Object.assign(Ei.prototype, {
          setDynamic: function (e) {
            return (
              console.warn(
                "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
              ),
              this.setUsage(!0 === e ? Cn : Ln),
              this
            );
          },
          copyIndicesArray: function () {
            console.error(
              "THREE.BufferAttribute: .copyIndicesArray() has been removed."
            );
          },
          setArray: function () {
            console.error(
              "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
          },
        }),
        Object.assign(Wi.prototype, {
          addIndex: function (e) {
            console.warn(
              "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
            ),
              this.setIndex(e);
          },
          addAttribute: function (e, t) {
            return (
              console.warn(
                "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
              ),
              (t && t.isBufferAttribute) ||
              (t && t.isInterleavedBufferAttribute)
                ? "index" === e
                  ? (console.warn(
                      "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                    ),
                    this.setIndex(t),
                    this)
                  : this.setAttribute(e, t)
                : (console.warn(
                    "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                  ),
                  this.setAttribute(e, new Ei(arguments[1], arguments[2])))
            );
          },
          addDrawCall: function (e, t, n) {
            void 0 !== n &&
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
              ),
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
              ),
              this.addGroup(e, t);
          },
          clearDrawCalls: function () {
            console.warn(
              "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
            ),
              this.clearGroups();
          },
          computeTangents: function () {
            console.warn(
              "THREE.BufferGeometry: .computeTangents() has been removed."
            );
          },
          computeOffsets: function () {
            console.warn(
              "THREE.BufferGeometry: .computeOffsets() has been removed."
            );
          },
          removeAttribute: function (e) {
            return (
              console.warn(
                "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
              ),
              this.deleteAttribute(e)
            );
          },
          applyMatrix: function (e) {
            return (
              console.warn(
                "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(e)
            );
          },
        }),
        Object.defineProperties(Wi.prototype, {
          drawcalls: {
            get: function () {
              return (
                console.error(
                  "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
          offsets: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferGeometry: .offsets has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
        }),
        Object.defineProperties(Ph.prototype, {
          maxInstancedCount: {
            get: function () {
              return (
                console.warn(
                  "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
                ),
                this.instanceCount
              );
            },
            set: function (e) {
              console.warn(
                "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
              ),
                (this.instanceCount = e);
            },
          },
        }),
        Object.defineProperties(Ad.prototype, {
          linePrecision: {
            get: function () {
              return (
                console.warn(
                  "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
                ),
                this.params.Line.threshold
              );
            },
            set: function (e) {
              console.warn(
                "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
              ),
                (this.params.Line.threshold = e);
            },
          },
        }),
        Object.defineProperties(Hs.prototype, {
          dynamic: {
            get: function () {
              return (
                console.warn(
                  "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
                ),
                this.usage === Cn
              );
            },
            set: function (e) {
              console.warn(
                "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
              ),
                this.setUsage(e);
            },
          },
        }),
        Object.assign(Hs.prototype, {
          setDynamic: function (e) {
            return (
              console.warn(
                "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
              ),
              this.setUsage(!0 === e ? Cn : Ln),
              this
            );
          },
          setArray: function () {
            console.error(
              "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
          },
        }),
        Object.assign(Gu.prototype, {
          getArrays: function () {
            console.error(
              "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
            );
          },
          addShapeList: function () {
            console.error(
              "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
            );
          },
          addShape: function () {
            console.error(
              "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
            );
          },
        }),
        Object.defineProperties(Td.prototype, {
          dynamic: {
            set: function () {
              console.warn(
                "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
              );
            },
          },
          onUpdate: {
            value: function () {
              return (
                console.warn(
                  "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
                ),
                this
              );
            },
          },
        }),
        Object.defineProperties(wi.prototype, {
          wrapAround: {
            get: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
            set: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
          },
          overdraw: {
            get: function () {
              console.warn("THREE.Material: .overdraw has been removed.");
            },
            set: function () {
              console.warn("THREE.Material: .overdraw has been removed.");
            },
          },
          wrapRGB: {
            get: function () {
              return (
                console.warn("THREE.Material: .wrapRGB has been removed."),
                new vi()
              );
            },
          },
          shading: {
            get: function () {
              console.error(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              );
            },
            set: function (e) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              ),
                (this.flatShading = e === b);
            },
          },
          stencilMask: {
            get: function () {
              return (
                console.warn(
                  "THREE." +
                    this.type +
                    ": .stencilMask has been removed. Use .stencilFuncMask instead."
                ),
                this.stencilFuncMask
              );
            },
            set: function (e) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
                (this.stencilFuncMask = e);
            },
          },
        }),
        Object.defineProperties(dl.prototype, {
          metal: {
            get: function () {
              return (
                console.warn(
                  "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
                ),
                !1
              );
            },
            set: function () {
              console.warn(
                "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
              );
            },
          },
        }),
        Object.defineProperties(wa.prototype, {
          derivatives: {
            get: function () {
              return (
                console.warn(
                  "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                ),
                this.extensions.derivatives
              );
            },
            set: function (e) {
              console.warn(
                "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
                (this.extensions.derivatives = e);
            },
          },
        }),
        Object.assign(Fs.prototype, {
          clearTarget: function (e, t, n, r) {
            console.warn(
              "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
            ),
              this.setRenderTarget(e),
              this.clear(t, n, r);
          },
          animate: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
            ),
              this.setAnimationLoop(e);
          },
          getCurrentRenderTarget: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
              ),
              this.getRenderTarget()
            );
          },
          getMaxAnisotropy: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
              ),
              this.capabilities.getMaxAnisotropy()
            );
          },
          getPrecision: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
              ),
              this.capabilities.precision
            );
          },
          resetGLState: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
              ),
              this.state.reset()
            );
          },
          supportsFloatTextures: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
              ),
              this.extensions.get("OES_texture_float")
            );
          },
          supportsHalfFloatTextures: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
              ),
              this.extensions.get("OES_texture_half_float")
            );
          },
          supportsStandardDerivatives: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
              ),
              this.extensions.get("OES_standard_derivatives")
            );
          },
          supportsCompressedTextureS3TC: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_s3tc")
            );
          },
          supportsCompressedTexturePVRTC: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_pvrtc")
            );
          },
          supportsBlendMinMax: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
              ),
              this.extensions.get("EXT_blend_minmax")
            );
          },
          supportsVertexTextures: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
              ),
              this.capabilities.vertexTextures
            );
          },
          supportsInstancedArrays: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
              ),
              this.extensions.get("ANGLE_instanced_arrays")
            );
          },
          enableScissorTest: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
            ),
              this.setScissorTest(e);
          },
          initMaterial: function () {
            console.warn(
              "THREE.WebGLRenderer: .initMaterial() has been removed."
            );
          },
          addPrePlugin: function () {
            console.warn(
              "THREE.WebGLRenderer: .addPrePlugin() has been removed."
            );
          },
          addPostPlugin: function () {
            console.warn(
              "THREE.WebGLRenderer: .addPostPlugin() has been removed."
            );
          },
          updateShadowMap: function () {
            console.warn(
              "THREE.WebGLRenderer: .updateShadowMap() has been removed."
            );
          },
          setFaceCulling: function () {
            console.warn(
              "THREE.WebGLRenderer: .setFaceCulling() has been removed."
            );
          },
          allocTextureUnit: function () {
            console.warn(
              "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
            );
          },
          setTexture: function () {
            console.warn(
              "THREE.WebGLRenderer: .setTexture() has been removed."
            );
          },
          setTexture2D: function () {
            console.warn(
              "THREE.WebGLRenderer: .setTexture2D() has been removed."
            );
          },
          setTextureCube: function () {
            console.warn(
              "THREE.WebGLRenderer: .setTextureCube() has been removed."
            );
          },
          getActiveMipMapLevel: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
              ),
              this.getActiveMipmapLevel()
            );
          },
        }),
        Object.defineProperties(Fs.prototype, {
          shadowMapEnabled: {
            get: function () {
              return this.shadowMap.enabled;
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
              ),
                (this.shadowMap.enabled = e);
            },
          },
          shadowMapType: {
            get: function () {
              return this.shadowMap.type;
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
              ),
                (this.shadowMap.type = e);
            },
          },
          shadowMapCullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
          context: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
                ),
                this.getContext()
              );
            },
          },
          vr: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .vr has been renamed to .xr"
                ),
                this.xr
              );
            },
          },
          gammaInput: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                ),
                !1
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              );
            },
          },
          gammaOutput: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                ),
                !1
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
                (this.outputEncoding = !0 === e ? en : $t);
            },
          },
          toneMappingWhitePoint: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                ),
                1
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              );
            },
          },
        }),
        Object.defineProperties(Cs.prototype, {
          cullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderReverseSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderSingleSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
        }),
        Object.defineProperties(Yn.prototype, {
          wrapS: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                ),
                this.texture.wrapS
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
                (this.texture.wrapS = e);
            },
          },
          wrapT: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                ),
                this.texture.wrapT
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
                (this.texture.wrapT = e);
            },
          },
          magFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                ),
                this.texture.magFilter
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
                (this.texture.magFilter = e);
            },
          },
          minFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                ),
                this.texture.minFilter
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
                (this.texture.minFilter = e);
            },
          },
          anisotropy: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                ),
                this.texture.anisotropy
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
                (this.texture.anisotropy = e);
            },
          },
          offset: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                ),
                this.texture.offset
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
                (this.texture.offset = e);
            },
          },
          repeat: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                ),
                this.texture.repeat
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
                (this.texture.repeat = e);
            },
          },
          format: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .format is now .texture.format."
                ),
                this.texture.format
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
                (this.texture.format = e);
            },
          },
          type: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .type is now .texture.type."
                ),
                this.texture.type
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
                (this.texture.type = e);
            },
          },
          generateMipmaps: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                ),
                this.texture.generateMipmaps
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
                (this.texture.generateMipmaps = e);
            },
          },
        }),
        Object.defineProperties(id.prototype, {
          load: {
            value: function (e) {
              console.warn(
                "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
              );
              var t = this;
              return (
                new qh().load(e, function (e) {
                  t.setBuffer(e);
                }),
                this
              );
            },
          },
          startTime: {
            set: function () {
              console.warn("THREE.Audio: .startTime is now .play( delay ).");
            },
          },
        }),
        (ld.prototype.getData = function () {
          return (
            console.warn(
              "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
            ),
            this.getFrequencyData()
          );
        }),
        (Ta.prototype.updateCubeMap = function (e, t) {
          return (
            console.warn(
              "THREE.CubeCamera: .updateCubeMap() is now .update()."
            ),
            this.update(e, t)
          );
        });
      var mf = {
        merge: function (e, t, n) {
          var r;
          console.warn(
            "THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
          ),
            t.isMesh &&
              (t.matrixAutoUpdate && t.updateMatrix(),
              (r = t.matrix),
              (t = t.geometry)),
            e.merge(t, r, n);
        },
        center: function (e) {
          return (
            console.warn(
              "THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
            ),
            e.center()
          );
        },
      };
      function vf() {
        console.error("THREE.CanvasRenderer has been removed");
      }
      function gf() {
        console.error("THREE.JSONLoader has been removed.");
      }
      (Vn.crossOrigin = void 0),
        (Vn.loadTexture = function (e, t, n, r) {
          console.warn(
            "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
          );
          var i = new Wl();
          i.setCrossOrigin(this.crossOrigin);
          var a = i.load(e, n, void 0, r);
          return t && (a.mapping = t), a;
        }),
        (Vn.loadTextureCube = function (e, t, n, r) {
          console.warn(
            "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
          );
          var i = new Vl();
          i.setCrossOrigin(this.crossOrigin);
          var a = i.load(e, n, void 0, r);
          return t && (a.mapping = t), a;
        }),
        (Vn.loadCompressedTexture = function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
          );
        }),
        (Vn.loadCompressedTextureCube = function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
          );
        });
      var yf = {
        createMultiMaterialObject: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
        detach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
        attach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
      };
      function xf() {
        console.error(
          "THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
        );
      }
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: i } })
        );
    },
    qBvQ: function (e, t, n) {
      "use strict";
      n.r(t),
        n.d(t, "ThreeJsModule", function () {
          return nt;
        });
      var r,
        i = n("ofXK"),
        a = n("tyNb"),
        o = n("fXoL"),
        s = function () {
          return ["."];
        },
        c = function () {
          return { exact: !0 };
        },
        u = function () {
          return [".", "object"];
        },
        l =
          (((r = (function () {
            function e() {
              _classCallCheck(this, e);
            }
            return (
              _createClass(e, [{ key: "ngOnInit", value: function () {} }]), e
            );
          })()).fac = function (e) {
            return new (e || r)();
          }),
          (r.cmp = o.Cb({
            type: r,
            selectors: [["app-three-wrapper"]],
            decls: 7,
            vars: 8,
            consts: [
              [1, "menu"],
              [
                "routerLinkActive",
                "active",
                3,
                "routerLink",
                "routerLinkActiveOptions",
              ],
              [1, "examples-wrapper"],
            ],
            template: function (e, t) {
              1 & e &&
                (o.Lb(0, "div", 0),
                o.Lb(1, "a", 1),
                o.hc(2, "Siatka"),
                o.Kb(),
                o.Lb(3, "a", 1),
                o.hc(4, "Obiekt"),
                o.Kb(),
                o.Kb(),
                o.Lb(5, "div", 2),
                o.Jb(6, "router-outlet"),
                o.Kb()),
                2 & e &&
                  (o.zb(1),
                  o.Zb("routerLink", o.ac(4, s))(
                    "routerLinkActiveOptions",
                    o.ac(5, c)
                  ),
                  o.zb(2),
                  o.Zb("routerLink", o.ac(6, u))(
                    "routerLinkActiveOptions",
                    o.ac(7, c)
                  ));
            },
            directives: [a.b, a.a, a.d],
            styles: [
              "[_nghost-%COMP%]{height:calc(100% - 30px);display:flex}.menu[_ngcontent-%COMP%]{width:200px;margin:10px}.menu[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{display:block;padding:5px 10px;text-decoration:none;color:#070728;border-bottom:2px solid #8f8f8f}.menu[_ngcontent-%COMP%]   a.active[_ngcontent-%COMP%]{border-bottom:2px solid #393985}[_nghost-%COMP%]     .examples-wrapper>:not(router-outlet){height:100%;display:flex}.examples-wrapper[_ngcontent-%COMP%]{flex:1;overflow:hidden;height:100%}",
            ],
          })),
          r),
        h = n("Womt"),
        d = function (e) {
          h.Object3D.call(this),
            (this.element = e || document.createElement("div")),
            (this.element.style.position = "absolute"),
            (this.element.style.pointerEvents = "auto"),
            this.addEventListener("removed", function () {
              this.traverse(function (e) {
                e.element instanceof Element &&
                  null !== e.element.parentNode &&
                  e.element.parentNode.removeChild(e.element);
              });
            });
        };
      d.prototype = Object.assign(Object.create(h.Object3D.prototype), {
        constructor: d,
        copy: function (e, t) {
          return (
            h.Object3D.prototype.copy.call(this, e, t),
            (this.element = e.element.cloneNode(!0)),
            this
          );
        },
      });
      var p = function (e) {
        d.call(this, e);
      };
      (p.prototype = Object.create(d.prototype)).constructor = p;
      var f = function () {
        var e,
          t,
          n,
          r,
          i = this,
          a = new h.Matrix4(),
          o = { camera: { fov: 0, style: "" }, objects: new WeakMap() },
          s = document.createElement("div");
        (s.style.overflow = "hidden"), (this.domElement = s);
        var c = document.createElement("div");
        (c.style.WebkitTransformStyle = "preserve-3d"),
          (c.style.transformStyle = "preserve-3d"),
          (c.style.pointerEvents = "none"),
          s.appendChild(c);
        var u = /Trident/i.test(navigator.userAgent);
        function l(e) {
          return Math.abs(e) < 1e-10 ? 0 : e;
        }
        function f(e) {
          var t = e.elements;
          return (
            "matrix3d(" +
            l(t[0]) +
            "," +
            l(-t[1]) +
            "," +
            l(t[2]) +
            "," +
            l(t[3]) +
            "," +
            l(t[4]) +
            "," +
            l(-t[5]) +
            "," +
            l(t[6]) +
            "," +
            l(t[7]) +
            "," +
            l(t[8]) +
            "," +
            l(-t[9]) +
            "," +
            l(t[10]) +
            "," +
            l(t[11]) +
            "," +
            l(t[12]) +
            "," +
            l(-t[13]) +
            "," +
            l(t[14]) +
            "," +
            l(t[15]) +
            ")"
          );
        }
        function m(e, t) {
          var i = e.elements,
            a =
              "matrix3d(" +
              l(i[0]) +
              "," +
              l(i[1]) +
              "," +
              l(i[2]) +
              "," +
              l(i[3]) +
              "," +
              l(-i[4]) +
              "," +
              l(-i[5]) +
              "," +
              l(-i[6]) +
              "," +
              l(-i[7]) +
              "," +
              l(i[8]) +
              "," +
              l(i[9]) +
              "," +
              l(i[10]) +
              "," +
              l(i[11]) +
              "," +
              l(i[12]) +
              "," +
              l(i[13]) +
              "," +
              l(i[14]) +
              "," +
              l(i[15]) +
              ")";
          return u
            ? "translate(-50%,-50%)translate(" + n + "px," + r + "px)" + t + a
            : "translate(-50%,-50%)" + a;
        }
        (this.getSize = function () {
          return { width: e, height: t };
        }),
          (this.setSize = function (i, a) {
            (n = (e = i) / 2),
              (r = (t = a) / 2),
              (s.style.width = i + "px"),
              (s.style.height = a + "px"),
              (c.style.width = i + "px"),
              (c.style.height = a + "px");
          });
        var v,
          g,
          y =
            ((v = new h.Vector3()),
            (g = new h.Vector3()),
            function (e, t) {
              return (
                v.setFromMatrixPosition(e.matrixWorld),
                g.setFromMatrixPosition(t.matrixWorld),
                v.distanceToSquared(g)
              );
            });
        this.render = function (e, t) {
          var h = t.projectionMatrix.elements[5] * r;
          if (
            (o.camera.fov !== h &&
              (t.isPerspectiveCamera
                ? ((s.style.WebkitPerspective = h + "px"),
                  (s.style.perspective = h + "px"))
                : ((s.style.WebkitPerspective = ""),
                  (s.style.perspective = "")),
              (o.camera.fov = h)),
            !0 === e.autoUpdate && e.updateMatrixWorld(),
            null === t.parent && t.updateMatrixWorld(),
            t.isOrthographicCamera)
          )
            var v = -(t.right + t.left) / 2,
              g = (t.top + t.bottom) / 2;
          var x = t.isOrthographicCamera
              ? "scale(" +
                h +
                ")translate(" +
                l(v) +
                "px," +
                l(g) +
                "px)" +
                f(t.matrixWorldInverse)
              : "translateZ(" + h + "px)" + f(t.matrixWorldInverse),
            b = x + "translate(" + n + "px," + r + "px)";
          o.camera.style === b ||
            u ||
            ((c.style.WebkitTransform = b),
            (c.style.transform = b),
            (o.camera.style = b)),
            (function e(t, n, r, s) {
              if (t instanceof d) {
                var l;
                t.onBeforeRender(i, n, r),
                  t instanceof p
                    ? (a.copy(r.matrixWorldInverse),
                      a.transpose(),
                      a.copyPosition(t.matrixWorld),
                      a.scale(t.scale),
                      (a.elements[3] = 0),
                      (a.elements[7] = 0),
                      (a.elements[11] = 0),
                      (a.elements[15] = 1),
                      (l = m(a, s)))
                    : (l = m(t.matrixWorld, s));
                var h = t.element,
                  f = o.objects.get(t);
                if (void 0 === f || f.style !== l) {
                  (h.style.WebkitTransform = l), (h.style.transform = l);
                  var v = { style: l };
                  u && (v.distanceToCameraSquared = y(r, t)),
                    o.objects.set(t, v);
                }
                (h.style.display = t.visible ? "" : "none"),
                  h.parentNode !== c && c.appendChild(h),
                  t.onAfterRender(i, n, r);
              }
              for (var g = 0, x = t.children.length; g < x; g++)
                e(t.children[g], n, r, s);
            })(e, e, t, x),
            u &&
              (function (e) {
                for (
                  var t = (function (e) {
                      var t = [];
                      return (
                        e.traverse(function (e) {
                          e instanceof d && t.push(e);
                        }),
                        t
                      );
                    })(e).sort(function (e, t) {
                      return (
                        o.objects.get(e).distanceToCameraSquared -
                        o.objects.get(t).distanceToCameraSquared
                      );
                    }),
                    n = t.length,
                    r = 0,
                    i = t.length;
                  r < i;
                  r++
                )
                  t[r].element.style.zIndex = n - r;
              })(e);
        };
      };
      n("VH6B");
      var m = (function () {
          var e = /^[og]\s*(.+)?/,
            t = /^mtllib /,
            n = /^usemtl /,
            r = /^usemap /,
            i = new h.Vector3(),
            a = new h.Vector3(),
            o = new h.Vector3(),
            s = new h.Vector3(),
            c = new h.Vector3();
          function u() {
            var e = {
              objects: [],
              object: {},
              vertices: [],
              normals: [],
              colors: [],
              uvs: [],
              materials: {},
              materialLibraries: [],
              startObject: function (e, t) {
                if (this.object && !1 === this.object.fromDeclaration)
                  return (
                    (this.object.name = e),
                    void (this.object.fromDeclaration = !1 !== t)
                  );
                var n =
                  this.object &&
                  "function" == typeof this.object.currentMaterial
                    ? this.object.currentMaterial()
                    : void 0;
                if (
                  (this.object &&
                    "function" == typeof this.object._finalize &&
                    this.object._finalize(!0),
                  (this.object = {
                    name: e || "",
                    fromDeclaration: !1 !== t,
                    geometry: {
                      vertices: [],
                      normals: [],
                      colors: [],
                      uvs: [],
                      hasNormalIndices: !1,
                      hasUVIndices: !1,
                    },
                    materials: [],
                    smooth: !0,
                    startMaterial: function (e, t) {
                      var n = this._finalize(!1);
                      n &&
                        (n.inherited || n.groupCount <= 0) &&
                        this.materials.splice(n.index, 1);
                      var r = {
                        index: this.materials.length,
                        name: e || "",
                        mtllib:
                          Array.isArray(t) && t.length > 0
                            ? t[t.length - 1]
                            : "",
                        smooth: void 0 !== n ? n.smooth : this.smooth,
                        groupStart: void 0 !== n ? n.groupEnd : 0,
                        groupEnd: -1,
                        groupCount: -1,
                        inherited: !1,
                        clone: function (e) {
                          var t = {
                            index: "number" == typeof e ? e : this.index,
                            name: this.name,
                            mtllib: this.mtllib,
                            smooth: this.smooth,
                            groupStart: 0,
                            groupEnd: -1,
                            groupCount: -1,
                            inherited: !1,
                          };
                          return (t.clone = this.clone.bind(t)), t;
                        },
                      };
                      return this.materials.push(r), r;
                    },
                    currentMaterial: function () {
                      if (this.materials.length > 0)
                        return this.materials[this.materials.length - 1];
                    },
                    _finalize: function (e) {
                      var t = this.currentMaterial();
                      if (
                        (t &&
                          -1 === t.groupEnd &&
                          ((t.groupEnd = this.geometry.vertices.length / 3),
                          (t.groupCount = t.groupEnd - t.groupStart),
                          (t.inherited = !1)),
                        e && this.materials.length > 1)
                      )
                        for (var n = this.materials.length - 1; n >= 0; n--)
                          this.materials[n].groupCount <= 0 &&
                            this.materials.splice(n, 1);
                      return (
                        e &&
                          0 === this.materials.length &&
                          this.materials.push({
                            name: "",
                            smooth: this.smooth,
                          }),
                        t
                      );
                    },
                  }),
                  n && n.name && "function" == typeof n.clone)
                ) {
                  var r = n.clone(0);
                  (r.inherited = !0), this.object.materials.push(r);
                }
                this.objects.push(this.object);
              },
              finalize: function () {
                this.object &&
                  "function" == typeof this.object._finalize &&
                  this.object._finalize(!0);
              },
              parseVertexIndex: function (e, t) {
                var n = parseInt(e, 10);
                return 3 * (n >= 0 ? n - 1 : n + t / 3);
              },
              parseNormalIndex: function (e, t) {
                var n = parseInt(e, 10);
                return 3 * (n >= 0 ? n - 1 : n + t / 3);
              },
              parseUVIndex: function (e, t) {
                var n = parseInt(e, 10);
                return 2 * (n >= 0 ? n - 1 : n + t / 2);
              },
              addVertex: function (e, t, n) {
                var r = this.vertices,
                  i = this.object.geometry.vertices;
                i.push(r[e + 0], r[e + 1], r[e + 2]),
                  i.push(r[t + 0], r[t + 1], r[t + 2]),
                  i.push(r[n + 0], r[n + 1], r[n + 2]);
              },
              addVertexPoint: function (e) {
                var t = this.vertices;
                this.object.geometry.vertices.push(
                  t[e + 0],
                  t[e + 1],
                  t[e + 2]
                );
              },
              addVertexLine: function (e) {
                var t = this.vertices;
                this.object.geometry.vertices.push(
                  t[e + 0],
                  t[e + 1],
                  t[e + 2]
                );
              },
              addNormal: function (e, t, n) {
                var r = this.normals,
                  i = this.object.geometry.normals;
                i.push(r[e + 0], r[e + 1], r[e + 2]),
                  i.push(r[t + 0], r[t + 1], r[t + 2]),
                  i.push(r[n + 0], r[n + 1], r[n + 2]);
              },
              addFaceNormal: function (e, t, n) {
                var r = this.vertices,
                  u = this.object.geometry.normals;
                i.fromArray(r, e),
                  a.fromArray(r, t),
                  o.fromArray(r, n),
                  c.subVectors(o, a),
                  s.subVectors(i, a),
                  c.cross(s),
                  c.normalize(),
                  u.push(c.x, c.y, c.z),
                  u.push(c.x, c.y, c.z),
                  u.push(c.x, c.y, c.z);
              },
              addColor: function (e, t, n) {
                var r = this.colors,
                  i = this.object.geometry.colors;
                void 0 !== r[e] && i.push(r[e + 0], r[e + 1], r[e + 2]),
                  void 0 !== r[t] && i.push(r[t + 0], r[t + 1], r[t + 2]),
                  void 0 !== r[n] && i.push(r[n + 0], r[n + 1], r[n + 2]);
              },
              addUV: function (e, t, n) {
                var r = this.uvs,
                  i = this.object.geometry.uvs;
                i.push(r[e + 0], r[e + 1]),
                  i.push(r[t + 0], r[t + 1]),
                  i.push(r[n + 0], r[n + 1]);
              },
              addDefaultUV: function () {
                var e = this.object.geometry.uvs;
                e.push(0, 0), e.push(0, 0), e.push(0, 0);
              },
              addUVLine: function (e) {
                var t = this.uvs;
                this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
              },
              addFace: function (e, t, n, r, i, a, o, s, c) {
                var u = this.vertices.length,
                  l = this.parseVertexIndex(e, u),
                  h = this.parseVertexIndex(t, u),
                  d = this.parseVertexIndex(n, u);
                if (
                  (this.addVertex(l, h, d),
                  this.addColor(l, h, d),
                  void 0 !== o && "" !== o)
                ) {
                  var p = this.normals.length;
                  (l = this.parseNormalIndex(o, p)),
                    (h = this.parseNormalIndex(s, p)),
                    (d = this.parseNormalIndex(c, p)),
                    this.addNormal(l, h, d),
                    (this.object.geometry.hasNormalIndices = !0);
                } else this.addFaceNormal(l, h, d);
                if (void 0 !== r && "" !== r) {
                  var f = this.uvs.length;
                  (l = this.parseUVIndex(r, f)),
                    (h = this.parseUVIndex(i, f)),
                    (d = this.parseUVIndex(a, f)),
                    this.addUV(l, h, d),
                    (this.object.geometry.hasUVIndices = !0);
                } else this.addDefaultUV();
              },
              addPointGeometry: function (e) {
                this.object.geometry.type = "Points";
                for (
                  var t = this.vertices.length, n = 0, r = e.length;
                  n < r;
                  n++
                )
                  this.addVertexPoint(this.parseVertexIndex(e[n], t));
              },
              addLineGeometry: function (e, t) {
                this.object.geometry.type = "Line";
                for (
                  var n = this.vertices.length,
                    r = this.uvs.length,
                    i = 0,
                    a = e.length;
                  i < a;
                  i++
                )
                  this.addVertexLine(this.parseVertexIndex(e[i], n));
                var o = 0;
                for (a = t.length; o < a; o++)
                  this.addUVLine(this.parseUVIndex(t[o], r));
              },
            };
            return e.startObject("", !1), e;
          }
          function l(e) {
            h.Loader.call(this, e), (this.materials = null);
          }
          return (
            (l.prototype = Object.assign(Object.create(h.Loader.prototype), {
              constructor: l,
              load: function (e, t, n, r) {
                var i = this,
                  a = new h.FileLoader(i.manager);
                a.setPath(this.path),
                  a.load(
                    e,
                    function (n) {
                      try {
                        t(i.parse(n));
                      } catch (a) {
                        r ? r(a) : console.error(a), i.manager.itemError(e);
                      }
                    },
                    n,
                    r
                  );
              },
              setMaterials: function (e) {
                return (this.materials = e), this;
              },
              parse: function (i) {
                var a = new u();
                -1 !== i.indexOf("\r\n") && (i = i.replace(/\r\n/g, "\n")),
                  -1 !== i.indexOf("\\\n") && (i = i.replace(/\\\n/g, ""));
                for (
                  var o = i.split("\n"),
                    s = "",
                    c = "",
                    l = [],
                    d = "function" == typeof "".trimLeft,
                    p = 0,
                    f = o.length;
                  p < f;
                  p++
                )
                  if (
                    ((s = o[p]),
                    0 !== (s = d ? s.trimLeft() : s.trim()).length &&
                      "#" !== (c = s.charAt(0)))
                  )
                    if ("v" === c) {
                      var m = s.split(/\s+/);
                      switch (m[0]) {
                        case "v":
                          a.vertices.push(
                            parseFloat(m[1]),
                            parseFloat(m[2]),
                            parseFloat(m[3])
                          ),
                            m.length >= 7
                              ? a.colors.push(
                                  parseFloat(m[4]),
                                  parseFloat(m[5]),
                                  parseFloat(m[6])
                                )
                              : a.colors.push(void 0, void 0, void 0);
                          break;
                        case "vn":
                          a.normals.push(
                            parseFloat(m[1]),
                            parseFloat(m[2]),
                            parseFloat(m[3])
                          );
                          break;
                        case "vt":
                          a.uvs.push(parseFloat(m[1]), parseFloat(m[2]));
                      }
                    } else if ("f" === c) {
                      for (
                        var v = s.substr(1).trim().split(/\s+/),
                          g = [],
                          y = 0,
                          x = v.length;
                        y < x;
                        y++
                      ) {
                        var b = v[y];
                        if (b.length > 0) {
                          var _ = b.split("/");
                          g.push(_);
                        }
                      }
                      var w = g[0];
                      for (y = 1, x = g.length - 1; y < x; y++) {
                        var M = g[y],
                          S = g[y + 1];
                        a.addFace(
                          w[0],
                          M[0],
                          S[0],
                          w[1],
                          M[1],
                          S[1],
                          w[2],
                          M[2],
                          S[2]
                        );
                      }
                    } else if ("l" === c) {
                      var T = s.substring(1).trim().split(" "),
                        E = [],
                        A = [];
                      if (-1 === s.indexOf("/")) E = T;
                      else
                        for (var L = 0, C = T.length; L < C; L++) {
                          var R = T[L].split("/");
                          "" !== R[0] && E.push(R[0]),
                            "" !== R[1] && A.push(R[1]);
                        }
                      a.addLineGeometry(E, A);
                    } else if ("p" === c) {
                      var P = s.substr(1).trim().split(" ");
                      a.addPointGeometry(P);
                    } else if (null !== (l = e.exec(s))) {
                      var O = (" " + l[0].substr(1).trim()).substr(1);
                      a.startObject(O);
                    } else if (n.test(s))
                      a.object.startMaterial(
                        s.substring(7).trim(),
                        a.materialLibraries
                      );
                    else if (t.test(s))
                      a.materialLibraries.push(s.substring(7).trim());
                    else if (r.test(s))
                      console.warn(
                        'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.'
                      );
                    else if ("s" === c) {
                      if ((l = s.split(" ")).length > 1) {
                        var D = l[1].trim().toLowerCase();
                        a.object.smooth = "0" !== D && "off" !== D;
                      } else a.object.smooth = !0;
                      (X = a.object.currentMaterial()) &&
                        (X.smooth = a.object.smooth);
                    } else {
                      if ("\0" === s) continue;
                      console.warn(
                        'THREE.OBJLoader: Unexpected line: "' + s + '"'
                      );
                    }
                a.finalize();
                var I = new h.Group();
                for (
                  I.materialLibraries = [].concat(a.materialLibraries),
                    p = 0,
                    f = a.objects.length;
                  p < f;
                  p++
                ) {
                  var N = a.objects[p],
                    B = N.geometry,
                    z = N.materials,
                    F = "Line" === B.type,
                    U = "Points" === B.type,
                    G = !1;
                  if (0 !== B.vertices.length) {
                    var k = new h.BufferGeometry();
                    k.setAttribute(
                      "position",
                      new h.Float32BufferAttribute(B.vertices, 3)
                    ),
                      !0 === B.hasNormalIndices &&
                        k.setAttribute(
                          "normal",
                          new h.Float32BufferAttribute(B.normals, 3)
                        ),
                      B.colors.length > 0 &&
                        ((G = !0),
                        k.setAttribute(
                          "color",
                          new h.Float32BufferAttribute(B.colors, 3)
                        )),
                      !0 === B.hasUVIndices &&
                        k.setAttribute(
                          "uv",
                          new h.Float32BufferAttribute(B.uvs, 2)
                        );
                    for (var H, j = [], V = 0, W = z.length; V < W; V++) {
                      var q = (J = z[V]).name + "_" + J.smooth + "_" + G,
                        X = a.materials[q];
                      if (null !== this.materials)
                        if (
                          ((X = this.materials.create(J.name)),
                          !F || !X || X instanceof h.LineBasicMaterial)
                        ) {
                          if (U && X && !(X instanceof h.PointsMaterial)) {
                            var Y = new h.PointsMaterial({
                              size: 10,
                              sizeAttenuation: !1,
                            });
                            h.Material.prototype.copy.call(Y, X),
                              Y.color.copy(X.color),
                              (Y.map = X.map),
                              (X = Y);
                          }
                        } else {
                          var Z = new h.LineBasicMaterial();
                          h.Material.prototype.copy.call(Z, X),
                            Z.color.copy(X.color),
                            (X = Z);
                        }
                      void 0 === X &&
                        (((X = F
                          ? new h.LineBasicMaterial()
                          : U
                          ? new h.PointsMaterial({
                              size: 1,
                              sizeAttenuation: !1,
                            })
                          : new h.MeshPhongMaterial()).name = J.name),
                        (X.flatShading = !J.smooth),
                        (X.vertexColors = G),
                        (a.materials[q] = X)),
                        j.push(X);
                    }
                    if (j.length > 1) {
                      for (V = 0, W = z.length; V < W; V++) {
                        var J;
                        k.addGroup((J = z[V]).groupStart, J.groupCount, V);
                      }
                      H = F
                        ? new h.LineSegments(k, j)
                        : U
                        ? new h.Points(k, j)
                        : new h.Mesh(k, j);
                    } else
                      H = F
                        ? new h.LineSegments(k, j[0])
                        : U
                        ? new h.Points(k, j[0])
                        : new h.Mesh(k, j[0]);
                    (H.name = N.name), I.add(H);
                  }
                }
                return I;
              },
            })),
            l
          );
        })(),
        v = function (e) {
          h.Loader.call(this, e);
        };
      (v.prototype = Object.assign(Object.create(h.Loader.prototype), {
        constructor: v,
        load: function (e, t, n, r) {
          var i = this,
            a = "" === this.path ? h.LoaderUtils.extractUrlBase(e) : this.path,
            o = new h.FileLoader(this.manager);
          o.setPath(this.path),
            o.load(
              e,
              function (n) {
                try {
                  t(i.parse(n, a));
                } catch (o) {
                  r ? r(o) : console.error(o), i.manager.itemError(e);
                }
              },
              n,
              r
            );
        },
        setMaterialOptions: function (e) {
          return (this.materialOptions = e), this;
        },
        parse: function (e, t) {
          for (
            var n = e.split("\n"), r = {}, i = /\s+/, a = {}, o = 0;
            o < n.length;
            o++
          ) {
            var s = n[o];
            if (0 !== (s = s.trim()).length && "#" !== s.charAt(0)) {
              var c = s.indexOf(" "),
                u = c >= 0 ? s.substring(0, c) : s;
              u = u.toLowerCase();
              var l = c >= 0 ? s.substring(c + 1) : "";
              if (((l = l.trim()), "newmtl" === u)) a[l] = r = { name: l };
              else if ("ka" === u || "kd" === u || "ks" === u || "ke" === u) {
                var h = l.split(i, 3);
                r[u] = [parseFloat(h[0]), parseFloat(h[1]), parseFloat(h[2])];
              } else r[u] = l;
            }
          }
          var d = new v.MaterialCreator(
            this.resourcePath || t,
            this.materialOptions
          );
          return (
            d.setCrossOrigin(this.crossOrigin),
            d.setManager(this.manager),
            d.setMaterials(a),
            d
          );
        },
      })),
        ((v.MaterialCreator = function (e, t) {
          (this.baseUrl = e || ""),
            (this.options = t),
            (this.materialsInfo = {}),
            (this.materials = {}),
            (this.materialsArray = []),
            (this.nameLookup = {}),
            (this.side =
              this.options && this.options.side
                ? this.options.side
                : h.FrontSide),
            (this.wrap =
              this.options && this.options.wrap
                ? this.options.wrap
                : h.RepeatWrapping);
        }).prototype = {
          constructor: v.MaterialCreator,
          crossOrigin: "anonymous",
          setCrossOrigin: function (e) {
            return (this.crossOrigin = e), this;
          },
          setManager: function (e) {
            this.manager = e;
          },
          setMaterials: function (e) {
            (this.materialsInfo = this.convert(e)),
              (this.materials = {}),
              (this.materialsArray = []),
              (this.nameLookup = {});
          },
          convert: function (e) {
            if (!this.options) return e;
            var t = {};
            for (var n in e) {
              var r = e[n],
                i = {};
              for (var a in ((t[n] = i), r)) {
                var o = !0,
                  s = r[a],
                  c = a.toLowerCase();
                switch (c) {
                  case "kd":
                  case "ka":
                  case "ks":
                    this.options &&
                      this.options.normalizeRGB &&
                      (s = [s[0] / 255, s[1] / 255, s[2] / 255]),
                      this.options &&
                        this.options.ignoreZeroRGBs &&
                        0 === s[0] &&
                        0 === s[1] &&
                        0 === s[2] &&
                        (o = !1);
                }
                o && (i[c] = s);
              }
            }
            return t;
          },
          preload: function () {
            for (var e in this.materialsInfo) this.create(e);
          },
          getIndex: function (e) {
            return this.nameLookup[e];
          },
          getAsArray: function () {
            var e = 0;
            for (var t in this.materialsInfo)
              (this.materialsArray[e] = this.create(t)),
                (this.nameLookup[t] = e),
                e++;
            return this.materialsArray;
          },
          create: function (e) {
            return (
              void 0 === this.materials[e] && this.createMaterial_(e),
              this.materials[e]
            );
          },
          createMaterial_: function (e) {
            var t = this,
              n = this.materialsInfo[e],
              r = { name: e, side: this.side };
            function i(e, n) {
              if (!r[e]) {
                var i,
                  a,
                  o = t.getTextureParams(n, r),
                  s = t.loadTexture(
                    ((i = t.baseUrl),
                    "string" != typeof (a = o.url) || "" === a
                      ? ""
                      : /^https?:\/\//i.test(a)
                      ? a
                      : i + a)
                  );
                s.repeat.copy(o.scale),
                  s.offset.copy(o.offset),
                  (s.wrapS = t.wrap),
                  (s.wrapT = t.wrap),
                  (r[e] = s);
              }
            }
            for (var a in n) {
              var o,
                s = n[a];
              if ("" !== s)
                switch (a.toLowerCase()) {
                  case "kd":
                    r.color = new h.Color().fromArray(s);
                    break;
                  case "ks":
                    r.specular = new h.Color().fromArray(s);
                    break;
                  case "ke":
                    r.emissive = new h.Color().fromArray(s);
                    break;
                  case "map_kd":
                    i("map", s);
                    break;
                  case "map_ks":
                    i("specularMap", s);
                    break;
                  case "map_ke":
                    i("emissiveMap", s);
                    break;
                  case "norm":
                    i("normalMap", s);
                    break;
                  case "map_bump":
                  case "bump":
                    i("bumpMap", s);
                    break;
                  case "map_d":
                    i("alphaMap", s), (r.transparent = !0);
                    break;
                  case "ns":
                    r.shininess = parseFloat(s);
                    break;
                  case "d":
                    (o = parseFloat(s)) < 1 &&
                      ((r.opacity = o), (r.transparent = !0));
                    break;
                  case "tr":
                    (o = parseFloat(s)),
                      this.options &&
                        this.options.invertTrProperty &&
                        (o = 1 - o),
                      o > 0 && ((r.opacity = 1 - o), (r.transparent = !0));
                }
            }
            return (
              (this.materials[e] = new h.MeshPhongMaterial(r)),
              this.materials[e]
            );
          },
          getTextureParams: function (e, t) {
            var n,
              r = { scale: new h.Vector2(1, 1), offset: new h.Vector2(0, 0) },
              i = e.split(/\s+/);
            return (
              (n = i.indexOf("-bm")) >= 0 &&
                ((t.bumpScale = parseFloat(i[n + 1])), i.splice(n, 2)),
              (n = i.indexOf("-s")) >= 0 &&
                (r.scale.set(parseFloat(i[n + 1]), parseFloat(i[n + 2])),
                i.splice(n, 4)),
              (n = i.indexOf("-o")) >= 0 &&
                (r.offset.set(parseFloat(i[n + 1]), parseFloat(i[n + 2])),
                i.splice(n, 4)),
              (r.url = i.join(" ").trim()),
              r
            );
          },
          loadTexture: function (e, t, n, r, i) {
            var a,
              o =
                void 0 !== this.manager
                  ? this.manager
                  : h.DefaultLoadingManager,
              s = o.getHandler(e);
            return (
              null === s && (s = new h.TextureLoader(o)),
              s.setCrossOrigin && s.setCrossOrigin(this.crossOrigin),
              (a = s.load(e, n, r, i)),
              void 0 !== t && (a.mapping = t),
              a
            );
          },
        });
      var g,
        y,
        x,
        b,
        _,
        w,
        M,
        S,
        T,
        E,
        A,
        L,
        C,
        R,
        P,
        O,
        D,
        I = function (e) {
          h.Loader.call(this, e),
            (this.defaultDPI = 90),
            (this.defaultUnit = "px");
        };
      (I.prototype = Object.assign(Object.create(h.Loader.prototype), {
        constructor: I,
        load: function (e, t, n, r) {
          var i = this,
            a = new h.FileLoader(i.manager);
          a.setPath(i.path),
            a.load(
              e,
              function (n) {
                try {
                  t(i.parse(n));
                } catch (a) {
                  r ? r(a) : console.error(a), i.manager.itemError(e);
                }
              },
              n,
              r
            );
        },
        parse: function (e) {
          var t = this;
          function n(e, t, n, i, a, o, s, c) {
            (i = (i * Math.PI) / 180), (t = Math.abs(t)), (n = Math.abs(n));
            var u = (s.x - c.x) / 2,
              l = (s.y - c.y) / 2,
              h = Math.cos(i) * u + Math.sin(i) * l,
              d = -Math.sin(i) * u + Math.cos(i) * l,
              p = t * t,
              f = n * n,
              m = h * h,
              v = d * d,
              g = m / p + v / f;
            if (g > 1) {
              var y = Math.sqrt(g);
              (p = (t *= y) * t), (f = (n *= y) * n);
            }
            var x = p * v + f * m,
              b = Math.sqrt(Math.max(0, (p * f - x) / x));
            a === o && (b = -b);
            var _ = (b * t * d) / n,
              w = (-b * n * h) / t,
              M = Math.cos(i) * _ - Math.sin(i) * w + (s.x + c.x) / 2,
              S = Math.sin(i) * _ + Math.cos(i) * w + (s.y + c.y) / 2,
              T = r(1, 0, (h - _) / t, (d - w) / n),
              E =
                r((h - _) / t, (d - w) / n, (-h - _) / t, (-d - w) / n) %
                (2 * Math.PI);
            e.currentPath.absellipse(M, S, t, n, T, T + E, 0 === o, i);
          }
          function r(e, t, n, r) {
            var i = e * n + t * r,
              a = Math.sqrt(e * e + t * t) * Math.sqrt(n * n + r * r),
              o = Math.acos(Math.max(-1, Math.min(1, i / a)));
            return e * r - t * n < 0 && (o = -o), o;
          }
          function i(e, t) {
            t = Object.assign({}, t);
            var n = {};
            if (e.hasAttribute("class"))
              for (
                var r = e
                    .getAttribute("class")
                    .split(/\s/)
                    .filter(Boolean)
                    .map(function (e) {
                      return e.trim();
                    }),
                  i = 0;
                i < r.length;
                i++
              )
                n = Object.assign(n, f["." + r[i]]);
            function a(r, i, a) {
              void 0 === a &&
                (a = function (e) {
                  return e;
                }),
                e.hasAttribute(r) && (t[i] = a(e.getAttribute(r))),
                n[r] && (t[i] = a(n[r])),
                e.style && "" !== e.style[r] && (t[i] = a(e.style[r]));
            }
            function o(e) {
              return Math.max(0, Math.min(1, u(e)));
            }
            function s(e) {
              return Math.max(0, u(e));
            }
            return (
              e.hasAttribute("id") &&
                (n = Object.assign(n, f["#" + e.getAttribute("id")])),
              a("fill", "fill"),
              a("fill-opacity", "fillOpacity", o),
              a("opacity", "opacity", o),
              a("stroke", "stroke"),
              a("stroke-opacity", "strokeOpacity", o),
              a("stroke-width", "strokeWidth", s),
              a("stroke-linejoin", "strokeLineJoin"),
              a("stroke-linecap", "strokeLineCap"),
              a("stroke-miterlimit", "strokeMiterLimit", s),
              a("visibility", "visibility"),
              t
            );
          }
          function a(e, t) {
            return e - (t - e);
          }
          function o(e) {
            for (
              var t = e.split(/[\s,]+|(?=\s?[+\-])/), n = 0;
              n < t.length;
              n++
            ) {
              var r = t[n];
              if (r.indexOf(".") !== r.lastIndexOf("."))
                for (var i = r.split("."), a = 2; a < i.length; a++)
                  t.splice(n + a - 1, 0, "0." + i[a]);
              t[n] = u(r);
            }
            return t;
          }
          var s = ["mm", "cm", "in", "pt", "pc", "px"],
            c = {
              mm: {
                mm: 1,
                cm: 0.1,
                in: 1 / 25.4,
                pt: 72 / 25.4,
                pc: 6 / 25.4,
                px: -1,
              },
              cm: {
                mm: 10,
                cm: 1,
                in: 1 / 2.54,
                pt: 72 / 2.54,
                pc: 6 / 2.54,
                px: -1,
              },
              in: { mm: 25.4, cm: 2.54, in: 1, pt: 72, pc: 6, px: -1 },
              pt: {
                mm: 25.4 / 72,
                cm: 2.54 / 72,
                in: 1 / 72,
                pt: 1,
                pc: 6 / 72,
                px: -1,
              },
              pc: {
                mm: 25.4 / 6,
                cm: 2.54 / 6,
                in: 1 / 6,
                pt: 12,
                pc: 1,
                px: -1,
              },
              px: { px: 1 },
            };
          function u(e) {
            var n = "px";
            if ("string" == typeof e || e instanceof String)
              for (var r = 0, i = s.length; r < i; r++) {
                var a = s[r];
                if (e.endsWith(a)) {
                  (n = a), (e = e.substring(0, e.length - a.length));
                  break;
                }
              }
            var o = void 0;
            return (
              "px" === n && "px" !== t.defaultUnit
                ? (o = c.in[t.defaultUnit] / t.defaultDPI)
                : (o = c[n][t.defaultUnit]) < 0 && (o = c[n].in * t.defaultDPI),
              o * parseFloat(e)
            );
          }
          function l(e) {
            var t = e.elements;
            return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
          }
          function d(e) {
            var t = e.elements;
            return Math.sqrt(t[3] * t[3] + t[4] * t[4]);
          }
          var p = [],
            f = {},
            m = [],
            v = new h.Matrix3(),
            g = new h.Matrix3(),
            y = new h.Matrix3(),
            x = new h.Matrix3(),
            b = new h.Vector2(),
            _ = new h.Vector3(),
            w = new h.Matrix3(),
            M = new DOMParser().parseFromString(e, "image/svg+xml");
          return (
            (function e(t, r) {
              if (1 === t.nodeType) {
                var s = (function (e) {
                    if (!e.hasAttribute("transform")) return null;
                    var t = (function (e) {
                      for (
                        var t = new h.Matrix3(),
                          n = v,
                          r = e.getAttribute("transform").split(")"),
                          i = r.length - 1;
                        i >= 0;
                        i--
                      ) {
                        var a = r[i].trim();
                        if ("" !== a) {
                          var s = a.indexOf("("),
                            c = a.length;
                          if (s > 0 && s < c) {
                            var u = a.substr(0, s),
                              l = o(a.substr(s + 1, c - s - 1));
                            switch ((n.identity(), u)) {
                              case "translate":
                                if (l.length >= 1) {
                                  var d = l[0],
                                    p = d;
                                  l.length >= 2 && (p = l[1]),
                                    n.translate(d, p);
                                }
                                break;
                              case "rotate":
                                if (l.length >= 1) {
                                  var f,
                                    m = 0,
                                    b = 0;
                                  (f = (-l[0] * Math.PI) / 180),
                                    l.length >= 3 && ((m = l[1]), (b = l[2])),
                                    g.identity().translate(-m, -b),
                                    y.identity().rotate(f),
                                    x.multiplyMatrices(y, g),
                                    g.identity().translate(m, b),
                                    n.multiplyMatrices(g, x);
                                }
                                break;
                              case "scale":
                                if (l.length >= 1) {
                                  var _ = l[0],
                                    w = _;
                                  l.length >= 2 && (w = l[1]), n.scale(_, w);
                                }
                                break;
                              case "skewX":
                                1 === l.length &&
                                  n.set(
                                    1,
                                    Math.tan((l[0] * Math.PI) / 180),
                                    0,
                                    0,
                                    1,
                                    0,
                                    0,
                                    0,
                                    1
                                  );
                                break;
                              case "skewY":
                                1 === l.length &&
                                  n.set(
                                    1,
                                    0,
                                    0,
                                    Math.tan((l[0] * Math.PI) / 180),
                                    1,
                                    0,
                                    0,
                                    0,
                                    1
                                  );
                                break;
                              case "matrix":
                                6 === l.length &&
                                  n.set(
                                    l[0],
                                    l[2],
                                    l[4],
                                    l[1],
                                    l[3],
                                    l[5],
                                    0,
                                    0,
                                    1
                                  );
                            }
                          }
                          t.premultiply(n);
                        }
                      }
                      return t;
                    })(e);
                    return (
                      m.length > 0 && t.premultiply(m[m.length - 1]),
                      w.copy(t),
                      m.push(t),
                      t
                    );
                  })(t),
                  c = null;
                switch (t.nodeName) {
                  case "svg":
                    break;
                  case "style":
                    !(function (e) {
                      if (
                        e.sheet &&
                        e.sheet.cssRules &&
                        e.sheet.cssRules.length
                      )
                        for (var t = 0; t < e.sheet.cssRules.length; t++) {
                          var n = e.sheet.cssRules[t];
                          if (1 === n.type)
                            for (
                              var r = n.selectorText
                                  .split(/,/gm)
                                  .filter(Boolean)
                                  .map(function (e) {
                                    return e.trim();
                                  }),
                                i = 0;
                              i < r.length;
                              i++
                            )
                              f[r[i]] = Object.assign(f[r[i]] || {}, n.style);
                        }
                    })(t);
                    break;
                  case "g":
                    r = i(t, r);
                    break;
                  case "path":
                    (r = i(t, r)),
                      t.hasAttribute("d") &&
                        (c = (function (e) {
                          for (
                            var t = new h.ShapePath(),
                              r = new h.Vector2(),
                              i = new h.Vector2(),
                              s = new h.Vector2(),
                              c = !0,
                              u = !1,
                              l = e
                                .getAttribute("d")
                                .match(/[a-df-z][^a-df-z]*/gi),
                              d = 0,
                              p = l.length;
                            d < p;
                            d++
                          ) {
                            var f = l[d],
                              m = f.charAt(0),
                              v = f.substr(1).trim();
                            switch ((!0 === c && ((u = !0), (c = !1)), m)) {
                              case "M":
                                for (
                                  var g = o(v), y = 0, x = g.length;
                                  y < x;
                                  y += 2
                                )
                                  (r.x = g[y + 0]),
                                    (r.y = g[y + 1]),
                                    (i.x = r.x),
                                    (i.y = r.y),
                                    0 === y
                                      ? t.moveTo(r.x, r.y)
                                      : t.lineTo(r.x, r.y),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "H":
                                for (y = 0, x = (g = o(v)).length; y < x; y++)
                                  (r.x = g[y]),
                                    (i.x = r.x),
                                    (i.y = r.y),
                                    t.lineTo(r.x, r.y),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "V":
                                for (y = 0, x = (g = o(v)).length; y < x; y++)
                                  (r.y = g[y]),
                                    (i.x = r.x),
                                    (i.y = r.y),
                                    t.lineTo(r.x, r.y),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "L":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 2
                                )
                                  (r.x = g[y + 0]),
                                    (r.y = g[y + 1]),
                                    (i.x = r.x),
                                    (i.y = r.y),
                                    t.lineTo(r.x, r.y),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "C":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 6
                                )
                                  t.bezierCurveTo(
                                    g[y + 0],
                                    g[y + 1],
                                    g[y + 2],
                                    g[y + 3],
                                    g[y + 4],
                                    g[y + 5]
                                  ),
                                    (i.x = g[y + 2]),
                                    (i.y = g[y + 3]),
                                    (r.x = g[y + 4]),
                                    (r.y = g[y + 5]),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "S":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 4
                                )
                                  t.bezierCurveTo(
                                    a(r.x, i.x),
                                    a(r.y, i.y),
                                    g[y + 0],
                                    g[y + 1],
                                    g[y + 2],
                                    g[y + 3]
                                  ),
                                    (i.x = g[y + 0]),
                                    (i.y = g[y + 1]),
                                    (r.x = g[y + 2]),
                                    (r.y = g[y + 3]),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "Q":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 4
                                )
                                  t.quadraticCurveTo(
                                    g[y + 0],
                                    g[y + 1],
                                    g[y + 2],
                                    g[y + 3]
                                  ),
                                    (i.x = g[y + 0]),
                                    (i.y = g[y + 1]),
                                    (r.x = g[y + 2]),
                                    (r.y = g[y + 3]),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "T":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 2
                                ) {
                                  var b = a(r.x, i.x),
                                    _ = a(r.y, i.y);
                                  t.quadraticCurveTo(b, _, g[y + 0], g[y + 1]),
                                    (i.x = b),
                                    (i.y = _),
                                    (r.x = g[y + 0]),
                                    (r.y = g[y + 1]),
                                    0 === y && !0 === u && s.copy(r);
                                }
                                break;
                              case "A":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 7
                                ) {
                                  var w = r.clone();
                                  (r.x = g[y + 5]),
                                    (r.y = g[y + 6]),
                                    (i.x = r.x),
                                    (i.y = r.y),
                                    n(
                                      t,
                                      g[y],
                                      g[y + 1],
                                      g[y + 2],
                                      g[y + 3],
                                      g[y + 4],
                                      w,
                                      r
                                    ),
                                    0 === y && !0 === u && s.copy(r);
                                }
                                break;
                              case "m":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 2
                                )
                                  (r.x += g[y + 0]),
                                    (r.y += g[y + 1]),
                                    (i.x = r.x),
                                    (i.y = r.y),
                                    0 === y
                                      ? t.moveTo(r.x, r.y)
                                      : t.lineTo(r.x, r.y),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "h":
                                for (y = 0, x = (g = o(v)).length; y < x; y++)
                                  (r.x += g[y]),
                                    (i.x = r.x),
                                    (i.y = r.y),
                                    t.lineTo(r.x, r.y),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "v":
                                for (y = 0, x = (g = o(v)).length; y < x; y++)
                                  (r.y += g[y]),
                                    (i.x = r.x),
                                    (i.y = r.y),
                                    t.lineTo(r.x, r.y),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "l":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 2
                                )
                                  (r.x += g[y + 0]),
                                    (r.y += g[y + 1]),
                                    (i.x = r.x),
                                    (i.y = r.y),
                                    t.lineTo(r.x, r.y),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "c":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 6
                                )
                                  t.bezierCurveTo(
                                    r.x + g[y + 0],
                                    r.y + g[y + 1],
                                    r.x + g[y + 2],
                                    r.y + g[y + 3],
                                    r.x + g[y + 4],
                                    r.y + g[y + 5]
                                  ),
                                    (i.x = r.x + g[y + 2]),
                                    (i.y = r.y + g[y + 3]),
                                    (r.x += g[y + 4]),
                                    (r.y += g[y + 5]),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "s":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 4
                                )
                                  t.bezierCurveTo(
                                    a(r.x, i.x),
                                    a(r.y, i.y),
                                    r.x + g[y + 0],
                                    r.y + g[y + 1],
                                    r.x + g[y + 2],
                                    r.y + g[y + 3]
                                  ),
                                    (i.x = r.x + g[y + 0]),
                                    (i.y = r.y + g[y + 1]),
                                    (r.x += g[y + 2]),
                                    (r.y += g[y + 3]),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "q":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 4
                                )
                                  t.quadraticCurveTo(
                                    r.x + g[y + 0],
                                    r.y + g[y + 1],
                                    r.x + g[y + 2],
                                    r.y + g[y + 3]
                                  ),
                                    (i.x = r.x + g[y + 0]),
                                    (i.y = r.y + g[y + 1]),
                                    (r.x += g[y + 2]),
                                    (r.y += g[y + 3]),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "t":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 2
                                )
                                  (b = a(r.x, i.x)),
                                    (_ = a(r.y, i.y)),
                                    t.quadraticCurveTo(
                                      b,
                                      _,
                                      r.x + g[y + 0],
                                      r.y + g[y + 1]
                                    ),
                                    (i.x = b),
                                    (i.y = _),
                                    (r.x = r.x + g[y + 0]),
                                    (r.y = r.y + g[y + 1]),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "a":
                                for (
                                  y = 0, x = (g = o(v)).length;
                                  y < x;
                                  y += 7
                                )
                                  (w = r.clone()),
                                    (r.x += g[y + 5]),
                                    (r.y += g[y + 6]),
                                    (i.x = r.x),
                                    (i.y = r.y),
                                    n(
                                      t,
                                      g[y],
                                      g[y + 1],
                                      g[y + 2],
                                      g[y + 3],
                                      g[y + 4],
                                      w,
                                      r
                                    ),
                                    0 === y && !0 === u && s.copy(r);
                                break;
                              case "Z":
                              case "z":
                                (t.currentPath.autoClose = !0),
                                  t.currentPath.curves.length > 0 &&
                                    (r.copy(s),
                                    t.currentPath.currentPoint.copy(r),
                                    (c = !0));
                                break;
                              default:
                                console.warn(f);
                            }
                            u = !1;
                          }
                          return t;
                        })(t));
                    break;
                  case "rect":
                    (r = i(t, r)),
                      (c = (function (e) {
                        var t = u(e.getAttribute("x") || 0),
                          n = u(e.getAttribute("y") || 0),
                          r = u(e.getAttribute("rx") || 0),
                          i = u(e.getAttribute("ry") || 0),
                          a = u(e.getAttribute("width")),
                          o = u(e.getAttribute("height")),
                          s = new h.ShapePath();
                        return (
                          s.moveTo(t + 2 * r, n),
                          s.lineTo(t + a - 2 * r, n),
                          (0 !== r || 0 !== i) &&
                            s.bezierCurveTo(
                              t + a,
                              n,
                              t + a,
                              n,
                              t + a,
                              n + 2 * i
                            ),
                          s.lineTo(t + a, n + o - 2 * i),
                          (0 !== r || 0 !== i) &&
                            s.bezierCurveTo(
                              t + a,
                              n + o,
                              t + a,
                              n + o,
                              t + a - 2 * r,
                              n + o
                            ),
                          s.lineTo(t + 2 * r, n + o),
                          (0 !== r || 0 !== i) &&
                            s.bezierCurveTo(
                              t,
                              n + o,
                              t,
                              n + o,
                              t,
                              n + o - 2 * i
                            ),
                          s.lineTo(t, n + 2 * i),
                          (0 !== r || 0 !== i) &&
                            s.bezierCurveTo(t, n, t, n, t + 2 * r, n),
                          s
                        );
                      })(t));
                    break;
                  case "polygon":
                    (r = i(t, r)),
                      (c = (function (e) {
                        var t = new h.ShapePath(),
                          n = 0;
                        return (
                          e
                            .getAttribute("points")
                            .replace(
                              /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,
                              function (e, r, i) {
                                var a = u(r),
                                  o = u(i);
                                0 === n ? t.moveTo(a, o) : t.lineTo(a, o), n++;
                              }
                            ),
                          (t.currentPath.autoClose = !0),
                          t
                        );
                      })(t));
                    break;
                  case "polyline":
                    (r = i(t, r)),
                      (c = (function (e) {
                        var t = new h.ShapePath(),
                          n = 0;
                        return (
                          e
                            .getAttribute("points")
                            .replace(
                              /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,
                              function (e, r, i) {
                                var a = u(r),
                                  o = u(i);
                                0 === n ? t.moveTo(a, o) : t.lineTo(a, o), n++;
                              }
                            ),
                          (t.currentPath.autoClose = !1),
                          t
                        );
                      })(t));
                    break;
                  case "circle":
                    (r = i(t, r)),
                      (c = (function (e) {
                        var t = u(e.getAttribute("cx")),
                          n = u(e.getAttribute("cy")),
                          r = u(e.getAttribute("r")),
                          i = new h.Path();
                        i.absarc(t, n, r, 0, 2 * Math.PI);
                        var a = new h.ShapePath();
                        return a.subPaths.push(i), a;
                      })(t));
                    break;
                  case "ellipse":
                    (r = i(t, r)),
                      (c = (function (e) {
                        var t = u(e.getAttribute("cx")),
                          n = u(e.getAttribute("cy")),
                          r = u(e.getAttribute("rx")),
                          i = u(e.getAttribute("ry")),
                          a = new h.Path();
                        a.absellipse(t, n, r, i, 0, 2 * Math.PI);
                        var o = new h.ShapePath();
                        return o.subPaths.push(a), o;
                      })(t));
                    break;
                  case "line":
                    (r = i(t, r)),
                      (c = (function (e) {
                        var t = u(e.getAttribute("x1")),
                          n = u(e.getAttribute("y1")),
                          r = u(e.getAttribute("x2")),
                          i = u(e.getAttribute("y2")),
                          a = new h.ShapePath();
                        return (
                          a.moveTo(t, n),
                          a.lineTo(r, i),
                          (a.currentPath.autoClose = !1),
                          a
                        );
                      })(t));
                }
                c &&
                  (void 0 !== r.fill &&
                    "none" !== r.fill &&
                    c.color.setStyle(r.fill),
                  (function (e, t) {
                    function n(e) {
                      _.set(e.x, e.y, 1).applyMatrix3(t), e.set(_.x, _.y);
                    }
                    for (
                      var r = (function (e) {
                          return 0 !== e.elements[1] || 0 !== e.elements[3];
                        })(t),
                        i = e.subPaths,
                        a = 0,
                        o = i.length;
                      a < o;
                      a++
                    )
                      for (var s = i[a].curves, c = 0; c < s.length; c++) {
                        var u = s[c];
                        u.isLineCurve
                          ? (n(u.v1), n(u.v2))
                          : u.isCubicBezierCurve
                          ? (n(u.v0), n(u.v1), n(u.v2), n(u.v3))
                          : u.isQuadraticBezierCurve
                          ? (n(u.v0), n(u.v1), n(u.v2))
                          : u.isEllipseCurve &&
                            (r &&
                              console.warn(
                                "SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."
                              ),
                            b.set(u.aX, u.aY),
                            n(b),
                            (u.aX = b.x),
                            (u.aY = b.y),
                            (u.xRadius *= l(t)),
                            (u.yRadius *= d(t)));
                      }
                  })(c, w),
                  p.push(c),
                  (c.userData = { node: t, style: r }));
                for (var M = t.childNodes, S = 0; S < M.length; S++) e(M[S], r);
                s &&
                  (m.pop(),
                  m.length > 0 ? w.copy(m[m.length - 1]) : w.identity());
              }
            })(M.documentElement, {
              fill: "#000",
              fillOpacity: 1,
              strokeOpacity: 1,
              strokeWidth: 1,
              strokeLineJoin: "miter",
              strokeLineCap: "butt",
              strokeMiterLimit: 4,
            }),
            { paths: p, xml: M.documentElement }
          );
        },
      })),
        (I.getStrokeStyle = function (e, t, n, r, i) {
          return {
            strokeColor: (t = void 0 !== t ? t : "#000"),
            strokeWidth: (e = void 0 !== e ? e : 1),
            strokeLineJoin: (n = void 0 !== n ? n : "miter"),
            strokeLineCap: (r = void 0 !== r ? r : "butt"),
            strokeMiterLimit: (i = void 0 !== i ? i : 4),
          };
        }),
        (I.pointsToStroke = function (e, t, n, r) {
          var i = [],
            a = [],
            o = [];
          if (0 === I.pointsToStrokeWithBuffers(e, t, n, r, i, a, o))
            return null;
          var s = new h.BufferGeometry();
          return (
            s.setAttribute("position", new h.Float32BufferAttribute(i, 3)),
            s.setAttribute("normal", new h.Float32BufferAttribute(a, 3)),
            s.setAttribute("uv", new h.Float32BufferAttribute(o, 2)),
            s
          );
        }),
        (I.pointsToStrokeWithBuffers =
          ((g = new h.Vector2()),
          (y = new h.Vector2()),
          (x = new h.Vector2()),
          (b = new h.Vector2()),
          (_ = new h.Vector2()),
          (w = new h.Vector2()),
          (M = new h.Vector2()),
          (S = new h.Vector2()),
          (T = new h.Vector2()),
          (E = new h.Vector2()),
          (A = new h.Vector2()),
          (L = new h.Vector2()),
          (C = new h.Vector2()),
          (R = new h.Vector2()),
          (P = new h.Vector2()),
          (O = new h.Vector2()),
          (D = new h.Vector2()),
          function (e, t, n, r, i, a, o, s) {
            (n = void 0 !== n ? n : 12),
              (r = void 0 !== r ? r : 0.001),
              (s = void 0 !== s ? s : 0);
            var c = (e = (function (e) {
              for (var t = !1, n = 1, i = e.length - 1; n < i; n++)
                if (e[n].distanceTo(e[n + 1]) < r) {
                  t = !0;
                  break;
                }
              if (!t) return e;
              var a = [];
              for (a.push(e[0]), n = 1, i = e.length - 1; n < i; n++)
                e[n].distanceTo(e[n + 1]) >= r && a.push(e[n]);
              return a.push(e[e.length - 1]), a;
            })(e)).length;
            if (c < 2) return 0;
            var u,
              l,
              h,
              d,
              p,
              f = e[0].equals(e[c - 1]),
              m = e[0],
              v = t.strokeWidth / 2,
              I = 1 / (c - 1),
              N = 0,
              B = !1,
              z = 0,
              F = 3 * s,
              U = 2 * s;
            K(e[0], e[1], g).multiplyScalar(v),
              S.copy(e[0]).sub(g),
              T.copy(e[0]).add(g),
              E.copy(S),
              A.copy(T);
            for (var G = 1; G < c; G++) {
              l = G === c - 1 ? (f ? e[1] : void 0) : e[G + 1];
              var k = g;
              K(m, (u = e[G]), k),
                x.copy(k).multiplyScalar(v),
                L.copy(u).sub(x),
                C.copy(u).add(x);
              var H = N + I;
              if (((h = !1), void 0 !== l)) {
                K(u, l, y),
                  x.copy(y).multiplyScalar(v),
                  R.copy(u).sub(x),
                  P.copy(u).add(x),
                  (d = !0),
                  x.subVectors(l, m),
                  k.dot(x) < 0 && (d = !1),
                  1 === G && (B = d),
                  x.subVectors(l, u),
                  x.normalize();
                var j = Math.abs(k.dot(x));
                if (0 !== j) {
                  var V = v / j;
                  x.multiplyScalar(-V),
                    b.subVectors(u, m),
                    _.copy(b).setLength(V).add(x),
                    O.copy(_).negate();
                  var W = _.length(),
                    q = b.length();
                  b.divideScalar(q), w.subVectors(l, u);
                  var X = w.length();
                  switch (
                    (w.divideScalar(X),
                    b.dot(O) < q && w.dot(O) < X && (h = !0),
                    D.copy(_).add(u),
                    O.add(u),
                    (p = !1),
                    h
                      ? d
                        ? (P.copy(O), C.copy(O))
                        : (R.copy(O), L.copy(O))
                      : ee(),
                    t.strokeLineJoin)
                  ) {
                    case "bevel":
                      te(d, h, H);
                      break;
                    case "round":
                      ne(d, h), d ? $(u, L, R, H, 0) : $(u, P, C, H, 1);
                      break;
                    case "miter":
                    case "miter-clip":
                    default:
                      var Y = (v * t.strokeMiterLimit) / W;
                      if (Y < 1) {
                        if ("miter-clip" !== t.strokeLineJoin) {
                          te(d, h, H);
                          break;
                        }
                        ne(d, h),
                          d
                            ? (w.subVectors(D, L).multiplyScalar(Y).add(L),
                              M.subVectors(D, R).multiplyScalar(Y).add(R),
                              Q(L, H, 0),
                              Q(w, H, 0),
                              Q(u, H, 0.5),
                              Q(u, H, 0.5),
                              Q(w, H, 0),
                              Q(M, H, 0),
                              Q(u, H, 0.5),
                              Q(M, H, 0),
                              Q(R, H, 0))
                            : (w.subVectors(D, C).multiplyScalar(Y).add(C),
                              M.subVectors(D, P).multiplyScalar(Y).add(P),
                              Q(C, H, 1),
                              Q(w, H, 1),
                              Q(u, H, 0.5),
                              Q(u, H, 0.5),
                              Q(w, H, 1),
                              Q(M, H, 1),
                              Q(u, H, 0.5),
                              Q(M, H, 1),
                              Q(P, H, 1));
                      } else
                        h
                          ? (d
                              ? (Q(T, N, 1),
                                Q(S, N, 0),
                                Q(D, H, 0),
                                Q(T, N, 1),
                                Q(D, H, 0),
                                Q(O, H, 1))
                              : (Q(T, N, 1),
                                Q(S, N, 0),
                                Q(D, H, 1),
                                Q(S, N, 0),
                                Q(O, H, 0),
                                Q(D, H, 1)),
                            d ? R.copy(D) : P.copy(D))
                          : d
                          ? (Q(L, H, 0),
                            Q(D, H, 0),
                            Q(u, H, 0.5),
                            Q(u, H, 0.5),
                            Q(D, H, 0),
                            Q(R, H, 0))
                          : (Q(C, H, 1),
                            Q(D, H, 1),
                            Q(u, H, 0.5),
                            Q(u, H, 0.5),
                            Q(D, H, 1),
                            Q(P, H, 1)),
                          (p = !0);
                  }
                } else ee();
              } else ee();
              f || G !== c - 1 || re(e[0], E, A, d, !0, N),
                (N = H),
                (m = u),
                S.copy(R),
                T.copy(P);
            }
            if (f) {
              if (h && i) {
                var Z = D,
                  J = O;
                B !== d && ((Z = O), (J = D)),
                  d
                    ? (p || B) &&
                      (J.toArray(i, 0), J.toArray(i, 9), p && Z.toArray(i, 3))
                    : (!p && B) ||
                      (J.toArray(i, 3), J.toArray(i, 9), p && Z.toArray(i, 0));
              }
            } else re(u, L, C, d, !1, H);
            return z;
            function K(e, t, n) {
              return n.subVectors(t, e), n.set(-n.y, n.x).normalize();
            }
            function Q(e, t, n) {
              i &&
                ((i[F] = e.x),
                (i[F + 1] = e.y),
                (i[F + 2] = 0),
                a && ((a[F] = 0), (a[F + 1] = 0), (a[F + 2] = 1)),
                (F += 3),
                o && ((o[U] = t), (o[U + 1] = n), (U += 2))),
                (z += 3);
            }
            function $(e, t, r, i, a) {
              g.copy(t).sub(e).normalize(), y.copy(r).sub(e).normalize();
              var o = Math.PI,
                s = g.dot(y);
              Math.abs(s) < 1 && (o = Math.abs(Math.acos(s))),
                (o /= n),
                x.copy(t);
              for (var c = 0, u = n - 1; c < u; c++)
                b.copy(x).rotateAround(e, o),
                  Q(x, i, a),
                  Q(b, i, a),
                  Q(e, i, 0.5),
                  x.copy(b);
              Q(b, i, a), Q(r, i, a), Q(e, i, 0.5);
            }
            function ee() {
              Q(T, N, 1),
                Q(S, N, 0),
                Q(L, H, 0),
                Q(T, N, 1),
                Q(L, H, 1),
                Q(C, H, 0);
            }
            function te(e, t, n) {
              t
                ? e
                  ? (Q(T, N, 1),
                    Q(S, N, 0),
                    Q(L, H, 0),
                    Q(T, N, 1),
                    Q(L, H, 0),
                    Q(O, H, 1),
                    Q(L, n, 0),
                    Q(R, n, 0),
                    Q(O, n, 0.5))
                  : (Q(T, N, 1),
                    Q(S, N, 0),
                    Q(C, H, 1),
                    Q(S, N, 0),
                    Q(O, H, 0),
                    Q(C, H, 1),
                    Q(C, n, 1),
                    Q(P, n, 0),
                    Q(O, n, 0.5))
                : e
                ? (Q(L, n, 0), Q(R, n, 0), Q(u, n, 0.5))
                : (Q(C, n, 1), Q(P, n, 0), Q(u, n, 0.5));
            }
            function ne(e, t) {
              t &&
                (e
                  ? (Q(T, N, 1),
                    Q(S, N, 0),
                    Q(L, H, 0),
                    Q(T, N, 1),
                    Q(L, H, 0),
                    Q(O, H, 1),
                    Q(L, N, 0),
                    Q(u, H, 0.5),
                    Q(O, H, 1),
                    Q(u, H, 0.5),
                    Q(R, N, 0),
                    Q(O, H, 1))
                  : (Q(T, N, 1),
                    Q(S, N, 0),
                    Q(C, H, 1),
                    Q(S, N, 0),
                    Q(O, H, 0),
                    Q(C, H, 1),
                    Q(C, N, 1),
                    Q(O, H, 0),
                    Q(u, H, 0.5),
                    Q(u, H, 0.5),
                    Q(O, H, 0),
                    Q(P, N, 1)));
            }
            function re(e, n, r, a, o, s) {
              switch (t.strokeLineCap) {
                case "round":
                  o ? $(e, r, n, s, 0.5) : $(e, n, r, s, 0.5);
                  break;
                case "square":
                  if (o)
                    g.subVectors(n, e),
                      y.set(g.y, -g.x),
                      x.addVectors(g, y).add(e),
                      b.subVectors(y, g).add(e),
                      a
                        ? (x.toArray(i, 3), b.toArray(i, 0), b.toArray(i, 9))
                        : (x.toArray(i, 3), x.toArray(i, 9), b.toArray(i, 0));
                  else {
                    g.subVectors(r, e),
                      y.set(g.y, -g.x),
                      x.addVectors(g, y).add(e),
                      b.subVectors(y, g).add(e);
                    var c = i.length;
                    a
                      ? (x.toArray(i, c - 3),
                        b.toArray(i, c - 6),
                        b.toArray(i, c - 12))
                      : (x.toArray(i, c - 6),
                        b.toArray(i, c - 3),
                        b.toArray(i, c - 12));
                  }
              }
            }
          }));
      var N = function (e, t) {
        var n, r, i, a, o, s;
        void 0 === t &&
          console.warn(
            'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
          ),
          t === document &&
            console.error(
              'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
            ),
          (this.object = e),
          (this.domElement = t),
          (this.enabled = !0),
          (this.target = new h.Vector3()),
          (this.minDistance = 0),
          (this.maxDistance = 1 / 0),
          (this.minZoom = 0),
          (this.maxZoom = 1 / 0),
          (this.minPolarAngle = 0),
          (this.maxPolarAngle = Math.PI),
          (this.minAzimuthAngle = -1 / 0),
          (this.maxAzimuthAngle = 1 / 0),
          (this.enableDamping = !1),
          (this.dampingFactor = 0.05),
          (this.enableZoom = !0),
          (this.zoomSpeed = 1),
          (this.enableRotate = !0),
          (this.rotateSpeed = 1),
          (this.enablePan = !0),
          (this.panSpeed = 1),
          (this.screenSpacePanning = !0),
          (this.keyPanSpeed = 7),
          (this.autoRotate = !1),
          (this.autoRotateSpeed = 2),
          (this.enableKeys = !0),
          (this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }),
          (this.mouseButtons = {
            LEFT: h.MOUSE.ROTATE,
            MIDDLE: h.MOUSE.DOLLY,
            RIGHT: h.MOUSE.PAN,
          }),
          (this.touches = { ONE: h.TOUCH.ROTATE, TWO: h.TOUCH.DOLLY_PAN }),
          (this.target0 = this.target.clone()),
          (this.position0 = this.object.position.clone()),
          (this.zoom0 = this.object.zoom),
          (this.getPolarAngle = function () {
            return v.phi;
          }),
          (this.getAzimuthalAngle = function () {
            return v.theta;
          }),
          (this.saveState = function () {
            c.target0.copy(c.target),
              c.position0.copy(c.object.position),
              (c.zoom0 = c.object.zoom);
          }),
          (this.reset = function () {
            c.target.copy(c.target0),
              c.object.position.copy(c.position0),
              (c.object.zoom = c.zoom0),
              c.object.updateProjectionMatrix(),
              c.dispatchEvent(u),
              c.update(),
              (f = p.NONE);
          }),
          (this.update =
            ((n = new h.Vector3()),
            (r = new h.Quaternion().setFromUnitVectors(
              e.up,
              new h.Vector3(0, 1, 0)
            )),
            (i = r.clone().inverse()),
            (a = new h.Vector3()),
            (o = new h.Quaternion()),
            (s = 2 * Math.PI),
            function () {
              var e = c.object.position;
              n.copy(e).sub(c.target),
                n.applyQuaternion(r),
                v.setFromVector3(n),
                c.autoRotate &&
                  f === p.NONE &&
                  P(((2 * Math.PI) / 60 / 60) * c.autoRotateSpeed),
                c.enableDamping
                  ? ((v.theta += g.theta * c.dampingFactor),
                    (v.phi += g.phi * c.dampingFactor))
                  : ((v.theta += g.theta), (v.phi += g.phi));
              var t = c.minAzimuthAngle,
                l = c.maxAzimuthAngle;
              return (
                isFinite(t) &&
                  isFinite(l) &&
                  (t < -Math.PI ? (t += s) : t > Math.PI && (t -= s),
                  l < -Math.PI ? (l += s) : l > Math.PI && (l -= s),
                  (v.theta =
                    t < l
                      ? Math.max(t, Math.min(l, v.theta))
                      : v.theta > (t + l) / 2
                      ? Math.max(t, v.theta)
                      : Math.min(l, v.theta))),
                (v.phi = Math.max(
                  c.minPolarAngle,
                  Math.min(c.maxPolarAngle, v.phi)
                )),
                v.makeSafe(),
                (v.radius *= y),
                (v.radius = Math.max(
                  c.minDistance,
                  Math.min(c.maxDistance, v.radius)
                )),
                !0 === c.enableDamping
                  ? c.target.addScaledVector(x, c.dampingFactor)
                  : c.target.add(x),
                n.setFromSpherical(v),
                n.applyQuaternion(i),
                e.copy(c.target).add(n),
                c.object.lookAt(c.target),
                !0 === c.enableDamping
                  ? ((g.theta *= 1 - c.dampingFactor),
                    (g.phi *= 1 - c.dampingFactor),
                    x.multiplyScalar(1 - c.dampingFactor))
                  : (g.set(0, 0, 0), x.set(0, 0, 0)),
                (y = 1),
                !!(
                  b ||
                  a.distanceToSquared(c.object.position) > m ||
                  8 * (1 - o.dot(c.object.quaternion)) > m
                ) &&
                  (c.dispatchEvent(u),
                  a.copy(c.object.position),
                  o.copy(c.object.quaternion),
                  (b = !1),
                  !0)
              );
            })),
          (this.dispose = function () {
            c.domElement.removeEventListener("contextmenu", te, !1),
              c.domElement.removeEventListener("mousedown", X, !1),
              c.domElement.removeEventListener("wheel", J, !1),
              c.domElement.removeEventListener("touchstart", Q, !1),
              c.domElement.removeEventListener("touchend", ee, !1),
              c.domElement.removeEventListener("touchmove", $, !1),
              c.domElement.ownerDocument.removeEventListener(
                "mousemove",
                Y,
                !1
              ),
              c.domElement.ownerDocument.removeEventListener("mouseup", Z, !1),
              c.domElement.removeEventListener("keydown", K, !1);
          });
        var c = this,
          u = { type: "change" },
          l = { type: "start" },
          d = { type: "end" },
          p = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6,
          },
          f = p.NONE,
          m = 1e-6,
          v = new h.Spherical(),
          g = new h.Spherical(),
          y = 1,
          x = new h.Vector3(),
          b = !1,
          _ = new h.Vector2(),
          w = new h.Vector2(),
          M = new h.Vector2(),
          S = new h.Vector2(),
          T = new h.Vector2(),
          E = new h.Vector2(),
          A = new h.Vector2(),
          L = new h.Vector2(),
          C = new h.Vector2();
        function R() {
          return Math.pow(0.95, c.zoomSpeed);
        }
        function P(e) {
          g.theta -= e;
        }
        function O(e) {
          g.phi -= e;
        }
        var D,
          I =
            ((D = new h.Vector3()),
            function (e, t) {
              D.setFromMatrixColumn(t, 0), D.multiplyScalar(-e), x.add(D);
            }),
          N = (function () {
            var e = new h.Vector3();
            return function (t, n) {
              !0 === c.screenSpacePanning
                ? e.setFromMatrixColumn(n, 1)
                : (e.setFromMatrixColumn(n, 0), e.crossVectors(c.object.up, e)),
                e.multiplyScalar(t),
                x.add(e);
            };
          })(),
          B = (function () {
            var e = new h.Vector3();
            return function (t, n) {
              var r = c.domElement;
              if (c.object.isPerspectiveCamera) {
                e.copy(c.object.position).sub(c.target);
                var i = e.length();
                (i *= Math.tan(((c.object.fov / 2) * Math.PI) / 180)),
                  I((2 * t * i) / r.clientHeight, c.object.matrix),
                  N((2 * n * i) / r.clientHeight, c.object.matrix);
              } else
                c.object.isOrthographicCamera
                  ? (I(
                      (t * (c.object.right - c.object.left)) /
                        c.object.zoom /
                        r.clientWidth,
                      c.object.matrix
                    ),
                    N(
                      (n * (c.object.top - c.object.bottom)) /
                        c.object.zoom /
                        r.clientHeight,
                      c.object.matrix
                    ))
                  : (console.warn(
                      "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                    ),
                    (c.enablePan = !1));
            };
          })();
        function z(e) {
          c.object.isPerspectiveCamera
            ? (y /= e)
            : c.object.isOrthographicCamera
            ? ((c.object.zoom = Math.max(
                c.minZoom,
                Math.min(c.maxZoom, c.object.zoom * e)
              )),
              c.object.updateProjectionMatrix(),
              (b = !0))
            : (console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
              ),
              (c.enableZoom = !1));
        }
        function F(e) {
          c.object.isPerspectiveCamera
            ? (y *= e)
            : c.object.isOrthographicCamera
            ? ((c.object.zoom = Math.max(
                c.minZoom,
                Math.min(c.maxZoom, c.object.zoom / e)
              )),
              c.object.updateProjectionMatrix(),
              (b = !0))
            : (console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
              ),
              (c.enableZoom = !1));
        }
        function U(e) {
          _.set(e.clientX, e.clientY);
        }
        function G(e) {
          S.set(e.clientX, e.clientY);
        }
        function k(e) {
          1 == e.touches.length
            ? _.set(e.touches[0].pageX, e.touches[0].pageY)
            : _.set(
                0.5 * (e.touches[0].pageX + e.touches[1].pageX),
                0.5 * (e.touches[0].pageY + e.touches[1].pageY)
              );
        }
        function H(e) {
          1 == e.touches.length
            ? S.set(e.touches[0].pageX, e.touches[0].pageY)
            : S.set(
                0.5 * (e.touches[0].pageX + e.touches[1].pageX),
                0.5 * (e.touches[0].pageY + e.touches[1].pageY)
              );
        }
        function j(e) {
          var t = e.touches[0].pageX - e.touches[1].pageX,
            n = e.touches[0].pageY - e.touches[1].pageY,
            r = Math.sqrt(t * t + n * n);
          A.set(0, r);
        }
        function V(e) {
          1 == e.touches.length
            ? w.set(e.touches[0].pageX, e.touches[0].pageY)
            : w.set(
                0.5 * (e.touches[0].pageX + e.touches[1].pageX),
                0.5 * (e.touches[0].pageY + e.touches[1].pageY)
              ),
            M.subVectors(w, _).multiplyScalar(c.rotateSpeed);
          var t = c.domElement;
          P((2 * Math.PI * M.x) / t.clientHeight),
            O((2 * Math.PI * M.y) / t.clientHeight),
            _.copy(w);
        }
        function W(e) {
          1 == e.touches.length
            ? T.set(e.touches[0].pageX, e.touches[0].pageY)
            : T.set(
                0.5 * (e.touches[0].pageX + e.touches[1].pageX),
                0.5 * (e.touches[0].pageY + e.touches[1].pageY)
              ),
            E.subVectors(T, S).multiplyScalar(c.panSpeed),
            B(E.x, E.y),
            S.copy(T);
        }
        function q(e) {
          var t = e.touches[0].pageX - e.touches[1].pageX,
            n = e.touches[0].pageY - e.touches[1].pageY,
            r = Math.sqrt(t * t + n * n);
          L.set(0, r),
            C.set(0, Math.pow(L.y / A.y, c.zoomSpeed)),
            z(C.y),
            A.copy(L);
        }
        function X(e) {
          if (!1 !== c.enabled) {
            var t;
            switch (
              (e.preventDefault(),
              c.domElement.focus ? c.domElement.focus() : window.focus(),
              e.button)
            ) {
              case 0:
                t = c.mouseButtons.LEFT;
                break;
              case 1:
                t = c.mouseButtons.MIDDLE;
                break;
              case 2:
                t = c.mouseButtons.RIGHT;
                break;
              default:
                t = -1;
            }
            switch (t) {
              case h.MOUSE.DOLLY:
                if (!1 === c.enableZoom) return;
                !(function (e) {
                  A.set(e.clientX, e.clientY);
                })(e),
                  (f = p.DOLLY);
                break;
              case h.MOUSE.ROTATE:
                if (e.ctrlKey || e.metaKey || e.shiftKey) {
                  if (!1 === c.enablePan) return;
                  G(e), (f = p.PAN);
                } else {
                  if (!1 === c.enableRotate) return;
                  U(e), (f = p.ROTATE);
                }
                break;
              case h.MOUSE.PAN:
                if (e.ctrlKey || e.metaKey || e.shiftKey) {
                  if (!1 === c.enableRotate) return;
                  U(e), (f = p.ROTATE);
                } else {
                  if (!1 === c.enablePan) return;
                  G(e), (f = p.PAN);
                }
                break;
              default:
                f = p.NONE;
            }
            f !== p.NONE &&
              (c.domElement.ownerDocument.addEventListener("mousemove", Y, !1),
              c.domElement.ownerDocument.addEventListener("mouseup", Z, !1),
              c.dispatchEvent(l));
          }
        }
        function Y(e) {
          if (!1 !== c.enabled)
            switch ((e.preventDefault(), f)) {
              case p.ROTATE:
                if (!1 === c.enableRotate) return;
                !(function (e) {
                  w.set(e.clientX, e.clientY),
                    M.subVectors(w, _).multiplyScalar(c.rotateSpeed);
                  var t = c.domElement;
                  P((2 * Math.PI * M.x) / t.clientHeight),
                    O((2 * Math.PI * M.y) / t.clientHeight),
                    _.copy(w),
                    c.update();
                })(e);
                break;
              case p.DOLLY:
                if (!1 === c.enableZoom) return;
                !(function (e) {
                  L.set(e.clientX, e.clientY),
                    C.subVectors(L, A),
                    C.y > 0 ? z(R()) : C.y < 0 && F(R()),
                    A.copy(L),
                    c.update();
                })(e);
                break;
              case p.PAN:
                if (!1 === c.enablePan) return;
                !(function (e) {
                  T.set(e.clientX, e.clientY),
                    E.subVectors(T, S).multiplyScalar(c.panSpeed),
                    B(E.x, E.y),
                    S.copy(T),
                    c.update();
                })(e);
            }
        }
        function Z(e) {
          !1 !== c.enabled &&
            (c.domElement.ownerDocument.removeEventListener("mousemove", Y, !1),
            c.domElement.ownerDocument.removeEventListener("mouseup", Z, !1),
            c.dispatchEvent(d),
            (f = p.NONE));
        }
        function J(e) {
          !1 === c.enabled ||
            !1 === c.enableZoom ||
            (f !== p.NONE && f !== p.ROTATE) ||
            (e.preventDefault(),
            e.stopPropagation(),
            c.dispatchEvent(l),
            (function (e) {
              e.deltaY < 0 ? F(R()) : e.deltaY > 0 && z(R()), c.update();
            })(e),
            c.dispatchEvent(d));
        }
        function K(e) {
          !1 !== c.enabled &&
            !1 !== c.enableKeys &&
            !1 !== c.enablePan &&
            (function (e) {
              var t = !1;
              switch (e.keyCode) {
                case c.keys.UP:
                  B(0, c.keyPanSpeed), (t = !0);
                  break;
                case c.keys.BOTTOM:
                  B(0, -c.keyPanSpeed), (t = !0);
                  break;
                case c.keys.LEFT:
                  B(c.keyPanSpeed, 0), (t = !0);
                  break;
                case c.keys.RIGHT:
                  B(-c.keyPanSpeed, 0), (t = !0);
              }
              t && (e.preventDefault(), c.update());
            })(e);
        }
        function Q(e) {
          if (!1 !== c.enabled) {
            switch ((e.preventDefault(), e.touches.length)) {
              case 1:
                switch (c.touches.ONE) {
                  case h.TOUCH.ROTATE:
                    if (!1 === c.enableRotate) return;
                    k(e), (f = p.TOUCH_ROTATE);
                    break;
                  case h.TOUCH.PAN:
                    if (!1 === c.enablePan) return;
                    H(e), (f = p.TOUCH_PAN);
                    break;
                  default:
                    f = p.NONE;
                }
                break;
              case 2:
                switch (c.touches.TWO) {
                  case h.TOUCH.DOLLY_PAN:
                    if (!1 === c.enableZoom && !1 === c.enablePan) return;
                    !(function (e) {
                      c.enableZoom && j(e), c.enablePan && H(e);
                    })(e),
                      (f = p.TOUCH_DOLLY_PAN);
                    break;
                  case h.TOUCH.DOLLY_ROTATE:
                    if (!1 === c.enableZoom && !1 === c.enableRotate) return;
                    !(function (e) {
                      c.enableZoom && j(e), c.enableRotate && k(e);
                    })(e),
                      (f = p.TOUCH_DOLLY_ROTATE);
                    break;
                  default:
                    f = p.NONE;
                }
                break;
              default:
                f = p.NONE;
            }
            f !== p.NONE && c.dispatchEvent(l);
          }
        }
        function $(e) {
          if (!1 !== c.enabled)
            switch ((e.preventDefault(), e.stopPropagation(), f)) {
              case p.TOUCH_ROTATE:
                if (!1 === c.enableRotate) return;
                V(e), c.update();
                break;
              case p.TOUCH_PAN:
                if (!1 === c.enablePan) return;
                W(e), c.update();
                break;
              case p.TOUCH_DOLLY_PAN:
                if (!1 === c.enableZoom && !1 === c.enablePan) return;
                !(function (e) {
                  c.enableZoom && q(e), c.enablePan && W(e);
                })(e),
                  c.update();
                break;
              case p.TOUCH_DOLLY_ROTATE:
                if (!1 === c.enableZoom && !1 === c.enableRotate) return;
                !(function (e) {
                  c.enableZoom && q(e), c.enableRotate && V(e);
                })(e),
                  c.update();
                break;
              default:
                f = p.NONE;
            }
        }
        function ee(e) {
          !1 !== c.enabled && (c.dispatchEvent(d), (f = p.NONE));
        }
        function te(e) {
          !1 !== c.enabled && e.preventDefault();
        }
        c.domElement.addEventListener("contextmenu", te, !1),
          c.domElement.addEventListener("mousedown", X, !1),
          c.domElement.addEventListener("wheel", J, !1),
          c.domElement.addEventListener("touchstart", Q, !1),
          c.domElement.addEventListener("touchend", ee, !1),
          c.domElement.addEventListener("touchmove", $, !1),
          c.domElement.addEventListener("keydown", K, !1),
          -1 === c.domElement.tabIndex && (c.domElement.tabIndex = 0),
          this.update();
      };
      (N.prototype = Object.create(
        h.EventDispatcher.prototype
      )).constructor = N;
      var B = function (e, t) {
        N.call(this, e, t),
          (this.screenSpacePanning = !1),
          (this.mouseButtons.LEFT = h.MOUSE.PAN),
          (this.mouseButtons.RIGHT = h.MOUSE.ROTATE),
          (this.touches.ONE = h.TOUCH.PAN),
          (this.touches.TWO = h.TOUCH.DOLLY_ROTATE);
      };
      (B.prototype = Object.create(
        h.EventDispatcher.prototype
      )).constructor = B;
      var z,
        F,
        U,
        G,
        k,
        H = ["*"],
        j = ["canvas"],
        V =
          (((k = (function () {
            function e(t) {
              _classCallCheck(this, e),
                (this.rendererService = t),
                (this.zAxisUp = !1);
            }
            return (
              _createClass(e, [
                {
                  key: "ngAfterViewInit",
                  value: function () {
                    this.createCamera(),
                      this.applyZAxisUp(),
                      this.applyPosition(),
                      this.rendererService.setCamera(this);
                  },
                },
                {
                  key: "ngOnChanges",
                  value: function (e) {
                    var t = !1;
                    ["positionX", "positionY", "positionZ"].some(function (t) {
                      return t in e;
                    }) && (this.applyPosition(), (t = !0)),
                      t && this.rendererService.render();
                  },
                },
                {
                  key: "applyPosition",
                  value: function () {
                    this.camera &&
                      this.camera.position.set(
                        this.positionX || 0,
                        this.positionY || 0,
                        this.positionZ || 0
                      );
                  },
                },
                {
                  key: "applyZAxisUp",
                  value: function () {
                    this.camera && this.zAxisUp && this.camera.up.set(0, 0, 1);
                  },
                },
              ]),
              e
            );
          })()).fac = function (e) {
            o.Rb();
          }),
          (k.dir = o.Db({
            type: k,
            inputs: {
              zAxisUp: "zAxisUp",
              positionX: "positionX",
              positionY: "positionY",
              positionZ: "positionZ",
            },
            features: [o.xb],
          })),
          k),
        W =
          (((G = (function () {
            function e() {
              _classCallCheck(this, e), (this.init = !1);
            }
            return (
              _createClass(e, [
                { key: "ngOnDestroy", value: function () {} },
                {
                  key: "setScene",
                  value: function (e) {
                    this.scene = e;
                  },
                },
                {
                  key: "setCamera",
                  value: function (e) {
                    (this.camera = e),
                      this.camera.updateAspectRatio(this.aspect);
                  },
                },
                {
                  key: "render",
                  value: function () {
                    this.init &&
                      this.scene &&
                      this.camera &&
                      (this.webGlRenderer.render(
                        this.scene.getObject(),
                        this.camera.camera
                      ),
                      this.css3dRenderer.render(
                        this.scene.getObject(),
                        this.camera.camera
                      ));
                  },
                },
                {
                  key: "initialize",
                  value: function (e) {
                    (this.webGlRenderer = new h.WebGLRenderer({
                      canvas: e,
                      antialias: !0,
                      alpha: !0,
                    })),
                      this.webGlRenderer.setPixelRatio(devicePixelRatio),
                      this.webGlRenderer.setSize(
                        e.clientWidth,
                        e.clientHeight,
                        !1
                      ),
                      (this.webGlRenderer.shadowMap.enabled = !1),
                      (this.webGlRenderer.shadowMap.autoUpdate = !1),
                      (this.webGlRenderer.shadowMap.type = h.PCFSoftShadowMap),
                      this.webGlRenderer.setClearColor(0, 0),
                      (this.webGlRenderer.autoClear = !0),
                      (e.style.zIndex = "2"),
                      (this.css3dRenderer = new f()),
                      this.css3dRenderer.setSize(
                        window.innerWidth,
                        window.innerHeight
                      ),
                      (this.css3dRenderer.domElement.style.position =
                        "absolute"),
                      (this.css3dRenderer.domElement.style.top = "0"),
                      (this.css3dRenderer.domElement.style.zIndex = "1"),
                      e.parentElement.appendChild(
                        this.css3dRenderer.domElement
                      ),
                      this.updateChildCamerasAspectRatio(e),
                      (this.init = !0),
                      this.render();
                  },
                },
                {
                  key: "resize",
                  value: function (e, t) {
                    (e.style.width = t), (e.style.height = t);
                    var n = e.clientWidth,
                      r = e.clientHeight;
                    this.webGlRenderer.setSize(n, r, !0),
                      this.css3dRenderer.setSize(n, r),
                      this.updateChildCamerasAspectRatio(e),
                      this.render();
                  },
                },
                {
                  key: "calculateAspectRatio",
                  value: function (e) {
                    if (0 === e.clientHeight) return 0;
                    this.aspect = e.clientWidth / e.clientHeight;
                  },
                },
                {
                  key: "updateChildCamerasAspectRatio",
                  value: function (e) {
                    this.calculateAspectRatio(e),
                      this.camera && this.camera.updateAspectRatio(this.aspect);
                  },
                },
              ]),
              e
            );
          })()).fac = function (e) {
            return new (e || G)();
          }),
          (G.prov = o.Eb({ token: G, factory: G.fac })),
          G),
        q =
          (((U = (function (e) {
            _inherits(n, e);
            var t = _createSuper(n);
            function n(e) {
              var r;
              return (
                _classCallCheck(this, n),
                ((r = t.call(this, e)).rendererService = e),
                r
              );
            }
            return (
              _createClass(n, [
                {
                  key: "createCamera",
                  value: function () {
                    this.camera = new h.PerspectiveCamera(
                      this.fov,
                      void 0,
                      this.near,
                      this.far
                    );
                  },
                },
                {
                  key: "updateAspectRatio",
                  value: function (e) {
                    (this.camera.aspect = e),
                      this.camera.updateProjectionMatrix();
                  },
                },
              ]),
              n
            );
          })(V)).fac = function (e) {
            return new (e || U)(o.Ib(W));
          }),
          (U.cmp = o.Cb({
            type: U,
            selectors: [["atft-perspective-camera"]],
            inputs: { fov: "fov", near: "near", far: "far" },
            features: [
              o.yb([
                {
                  provide: V,
                  useExisting: Object(o.S)(function () {
                    return U;
                  }),
                },
              ]),
              o.wb,
            ],
            ngContentSelectors: H,
            decls: 1,
            vars: 0,
            template: function (e, t) {
              1 & e && (o.Yb(), o.Xb(0));
            },
            encapsulation: 2,
          })),
          U),
        X =
          (((F = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: F })),
          (F.inj = o.Fb({
            factory: function (e) {
              return new (e || F)();
            },
            imports: [[i.c]],
          })),
          F),
        Y =
          (((z = (function () {
            function e(t) {
              var n = this;
              _classCallCheck(this, e),
                (this.rendererService = t),
                (this.changed = new o.n()),
                this.changed.subscribe(function () {
                  n.rendererService.render();
                });
            }
            return (
              _createClass(e, [
                {
                  key: "ngOnChanges",
                  value: function (e) {
                    if (this.object) {
                      var t = !1;
                      ["rotateX", "rotateY", "rotateZ"].some(function (t) {
                        return t in e;
                      }) && (this.applyRotation(), (t = !0)),
                        ["translateX", "translateY", "translateZ"].some(
                          function (t) {
                            return t in e;
                          }
                        ) && (this.applyTranslation(), (t = !0)),
                        t && this.changed.emit();
                    }
                  },
                },
                {
                  key: "ngOnDestroy",
                  value: function () {
                    this.object &&
                      this.object.parent &&
                      this.object.parent.remove(this.object);
                  },
                },
                {
                  key: "ngAfterViewInit",
                  value: function () {
                    (this.object = this.newObject3DInstance()),
                      this.applyTranslation(),
                      this.applyRotation(),
                      this.collectChilds(),
                      this.afterInit();
                  },
                },
                {
                  key: "collectChilds",
                  value: function () {
                    var e = this;
                    void 0 !== this.childNodes &&
                      this.childNodes.length > 1 &&
                      this.childNodes
                        .filter(function (t) {
                          return t !== e && void 0 !== t.getObject();
                        })
                        .forEach(function (t) {
                          e.addChild(t.getObject());
                        }),
                      void 0 !== this.viewChilds &&
                        this.viewChilds.length > 0 &&
                        this.viewChilds
                          .filter(function (t) {
                            return (
                              t !== e &&
                              void 0 !== t.getObject() &&
                              !t.getObject().parent
                            );
                          })
                          .forEach(function (t) {
                            e.addChild(t.getObject());
                          });
                  },
                },
                {
                  key: "applyRotation",
                  value: function () {
                    this.object.rotation.set(
                      this.rotateX || 0,
                      this.rotateY || 0,
                      this.rotateZ || 0,
                      "XYZ"
                    );
                  },
                },
                {
                  key: "applyTranslation",
                  value: function () {
                    this.object.position.set(
                      this.translateX || 0,
                      this.translateY || 0,
                      this.translateZ || 0
                    );
                  },
                },
                {
                  key: "addChild",
                  value: function (e) {
                    this.object.add(e);
                  },
                },
                {
                  key: "removeChild",
                  value: function (e) {
                    this.object.remove(e);
                  },
                },
                {
                  key: "getObject",
                  value: function () {
                    return this.object;
                  },
                },
                { key: "afterInit", value: function () {} },
              ]),
              e
            );
          })()).fac = function (e) {
            o.Rb();
          }),
          (z.dir = o.Db({
            type: z,
            contentQueries: function (e, t, n) {
              var r;
              1 & e && o.Bb(n, z, !1),
                2 & e && o.bc((r = o.Tb())) && (t.childNodes = r);
            },
            viewQuery: function (e, t) {
              var n;
              1 & e && o.jc(z, !0),
                2 & e && o.bc((n = o.Tb())) && (t.viewChilds = n);
            },
            inputs: {
              rotateX: "rotateX",
              rotateY: "rotateY",
              rotateZ: "rotateZ",
              translateX: "translateX",
              translateY: "translateY",
              translateZ: "translateZ",
              name: "name",
            },
            outputs: { changed: "changed" },
            features: [o.xb],
          })),
          z);
      function Z(e, t) {
        var n = t || 16777215;
        return void 0 !== e && (n = 1 * e), n;
      }
      var J,
        K,
        Q,
        $,
        ee,
        te,
        ne,
        re,
        ie,
        ae,
        oe,
        se,
        ce,
        ue,
        le,
        he,
        de,
        pe,
        fe,
        me,
        ve,
        ge,
        ye,
        xe,
        be,
        _e,
        we,
        Me,
        Se,
        Te,
        Ee =
          (((re = (function () {
            function e(t) {
              _classCallCheck(this, e),
                (this.rendererService = t),
                (this.animate = new o.n()),
                (this.enabled = !1),
                (this.animationStep = this.animationStep.bind(this));
            }
            return (
              _createClass(e, [
                {
                  key: "start",
                  value: function () {
                    this.enabled || ((this.enabled = !0), this.animationStep());
                  },
                },
                {
                  key: "stop",
                  value: function () {
                    this.enabled && (this.enabled = !1);
                  },
                },
                {
                  key: "animationStep",
                  value: function () {
                    this.enabled &&
                      (requestAnimationFrame(this.animationStep),
                      this.animate.observers.length > 0 &&
                        (this.animate.emit(), this.rendererService.render()));
                  },
                },
              ]),
              e
            );
          })()).fac = function (e) {
            return new (e || re)(o.Ob(W));
          }),
          (re.prov = o.Eb({ token: re, factory: re.fac })),
          re),
        Ae =
          (((ne = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: ne })),
          (ne.inj = o.Fb({
            factory: function (e) {
              return new (e || ne)();
            },
            imports: [[i.c]],
          })),
          ne),
        Le =
          (((te = (function (e) {
            _inherits(n, e);
            var t = _createSuper(n);
            function n(e) {
              var r;
              return (
                _classCallCheck(this, n),
                ((r = t.call(this, e)).rendererService = e),
                r
              );
            }
            return (
              _createClass(n, [
                {
                  key: "newObject3DInstance",
                  value: function () {
                    return new h.AxesHelper(this.size);
                  },
                },
              ]),
              n
            );
          })(Y)).fac = function (e) {
            return new (e || te)(o.Ib(W));
          }),
          (te.cmp = o.Cb({
            type: te,
            selectors: [["atft-axes-helper"]],
            inputs: { size: "size" },
            features: [
              o.yb([
                {
                  provide: Y,
                  useExisting: Object(o.S)(function () {
                    return te;
                  }),
                },
              ]),
              o.wb,
            ],
            ngContentSelectors: H,
            decls: 1,
            vars: 0,
            template: function (e, t) {
              1 & e && (o.Yb(), o.Xb(0));
            },
            encapsulation: 2,
          })),
          te),
        Ce =
          (((ee = (function (e) {
            _inherits(n, e);
            var t = _createSuper(n);
            function n(e) {
              var r;
              return (
                _classCallCheck(this, n),
                ((r = t.call(this, e)).rendererService = e),
                r
              );
            }
            return (
              _createClass(n, [
                {
                  key: "newObject3DInstance",
                  value: function () {
                    return new h.GridHelper(this.size, this.divisions);
                  },
                },
              ]),
              n
            );
          })(Y)).fac = function (e) {
            return new (e || ee)(o.Ib(W));
          }),
          (ee.cmp = o.Cb({
            type: ee,
            selectors: [["atft-grid-helper"]],
            inputs: { size: "size", divisions: "divisions" },
            features: [
              o.yb([
                {
                  provide: Y,
                  useExisting: Object(o.S)(function () {
                    return ee;
                  }),
                },
              ]),
              o.wb,
            ],
            ngContentSelectors: H,
            decls: 1,
            vars: 0,
            template: function (e, t) {
              1 & e && (o.Yb(), o.Xb(0));
            },
            encapsulation: 2,
          })),
          ee),
        Re =
          ((($ = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: $ })),
          ($.inj = o.Fb({
            factory: function (e) {
              return new (e || $)();
            },
            imports: [[i.c]],
          })),
          $),
        Pe =
          (((Q = (function (e) {
            _inherits(n, e);
            var t = _createSuper(n);
            function n(e) {
              var r;
              return (
                _classCallCheck(this, n),
                ((r = t.call(this, e)).rendererService = e),
                (r.color = 16777215),
                (r.intensity = 1),
                (r.distance = 500),
                (r.castShadow = !1),
                r
              );
            }
            return (
              _createClass(n, [
                {
                  key: "newObject3DInstance",
                  value: function () {
                    var e = new h.PointLight(
                      Z(this.color),
                      this.intensity,
                      this.distance
                    );
                    return (
                      !0 === this.castShadow &&
                        ((e.castShadow = this.castShadow),
                        (e.shadow.mapSize.width = 1024),
                        (e.shadow.mapSize.height = 1024),
                        (e.shadow.camera.near = 0.5),
                        (e.shadow.camera.far = 500),
                        (e.shadow.bias = -0.001),
                        (e.shadow.radius = 1)),
                      e
                    );
                  },
                },
              ]),
              n
            );
          })(Y)).fac = function (e) {
            return new (e || Q)(o.Ib(W));
          }),
          (Q.cmp = o.Cb({
            type: Q,
            selectors: [["atft-point-light"]],
            inputs: {
              color: "color",
              intensity: "intensity",
              distance: "distance",
              castShadow: "castShadow",
            },
            features: [
              o.yb([
                {
                  provide: Y,
                  useExisting: Object(o.S)(function () {
                    return Q;
                  }),
                },
              ]),
              o.wb,
            ],
            ngContentSelectors: H,
            decls: 1,
            vars: 0,
            template: function (e, t) {
              1 & e && (o.Yb(), o.Xb(0));
            },
            encapsulation: 2,
          })),
          Q),
        Oe =
          (((K = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: K })),
          (K.inj = o.Fb({
            factory: function (e) {
              return new (e || K)();
            },
            imports: [[i.c]],
          })),
          K),
        De =
          (((J = (function (e) {
            _inherits(n, e);
            var t = _createSuper(n);
            function n() {
              var e;
              return (
                _classCallCheck(this, n),
                ((e = t.apply(this, arguments)).parentInitialized = !1),
                e
              );
            }
            return (
              _createClass(n, [
                {
                  key: "afterInit",
                  value: function () {
                    _get(_getPrototypeOf(n.prototype), "afterInit", this).call(
                      this
                    ),
                      (this.parentInitialized = !0),
                      this.startLoading();
                  },
                },
                {
                  key: "startLoading",
                  value: function () {
                    var e = this;
                    this.loadLazyObject()
                      .then(function (t) {
                        e.lazyObject &&
                          _get(
                            _getPrototypeOf(n.prototype),
                            "removeChild",
                            e
                          ).call(e, e.lazyObject),
                          (e.lazyObject = t),
                          _get(
                            _getPrototypeOf(n.prototype),
                            "addChild",
                            e
                          ).call(e, t),
                          e.rendererService.render();
                      })
                      .catch(function (e) {
                        console.error(e);
                      });
                  },
                },
                {
                  key: "ngOnDestroy",
                  value: function () {
                    this.lazyObject &&
                      _get(
                        _getPrototypeOf(n.prototype),
                        "removeChild",
                        this
                      ).call(this, this.lazyObject);
                  },
                },
                {
                  key: "newObject3DInstance",
                  value: function () {
                    return new h.Object3D();
                  },
                },
              ]),
              n
            );
          })(Y)).fac = function (e) {
            return Ie(e || J);
          }),
          (J.dir = o.Db({ type: J, features: [o.wb] })),
          J),
        Ie = o.Mb(De),
        Ne =
          (((ie = (function (e) {
            _inherits(n, e);
            var t = _createSuper(n);
            function n() {
              return _classCallCheck(this, n), t.apply(this, arguments);
            }
            return (
              _createClass(n, [
                {
                  key: "model",
                  set: function (e) {
                    this._model !== e &&
                      ((this._model = e),
                      _get(
                        _getPrototypeOf(n.prototype),
                        "startLoading",
                        this
                      ).call(this));
                  },
                  get: function () {
                    return this._model;
                  },
                },
              ]),
              n
            );
          })(De)).fac = function (e) {
            return Be(e || ie);
          }),
          (ie.dir = o.Db({
            type: ie,
            inputs: { model: "model" },
            features: [o.wb],
          })),
          ie),
        Be = o.Mb(Ne),
        ze =
          (((_e = (function (e) {
            _inherits(n, e);
            var t = _createSuper(n);
            function n(e) {
              var r;
              return (
                _classCallCheck(this, n),
                ((r = t.call(this, e)).rendererService = e),
                (r.loader = new m()),
                (r.mtlLoader = new v()),
                r
              );
            }
            return (
              _createClass(n, [
                {
                  key: "loadLazyObject",
                  value: function () {
                    return (
                      (e = this),
                      (n = regeneratorRuntime.mark(function e() {
                        var t = this;
                        return regeneratorRuntime.wrap(function (e) {
                          for (;;)
                            switch ((e.prev = e.next)) {
                              case 0:
                                return e.abrupt(
                                  "return",
                                  new Promise(function (e, n) {
                                    void 0 === t.material
                                      ? e()
                                      : (t.mtlLoader.setResourcePath(
                                          t.resourcePath
                                        ),
                                        t.mtlLoader.load(
                                          t.material,
                                          function (n) {
                                            n.preload(),
                                              t.loader.setMaterials(n),
                                              e();
                                          },
                                          void 0,
                                          n
                                        ));
                                  }).then(function () {
                                    return new Promise(function (e, n) {
                                      t.loader.load(
                                        t.model,
                                        function (t) {
                                          e(t);
                                        },
                                        void 0,
                                        n
                                      );
                                    });
                                  })
                                );
                              case 1:
                              case "end":
                                return e.stop();
                            }
                        }, e);
                      })),
                      new ((t = void 0) || (t = Promise))(function (r, i) {
                        function a(e) {
                          try {
                            s(n.next(e));
                          } catch (t) {
                            i(t);
                          }
                        }
                        function o(e) {
                          try {
                            s(n.throw(e));
                          } catch (t) {
                            i(t);
                          }
                        }
                        function s(e) {
                          var n;
                          e.done
                            ? r(e.value)
                            : ((n = e.value),
                              n instanceof t
                                ? n
                                : new t(function (e) {
                                    e(n);
                                  })).then(a, o);
                        }
                        s((n = n.apply(e, [])).next());
                      })
                    );
                    var e, t, n;
                  },
                },
                {
                  key: "texturePath",
                  set: function (e) {
                    this.resourcePath = e;
                  },
                },
              ]),
              n
            );
          })(Ne)).fac = function (e) {
            return new (e || _e)(o.Ib(W));
          }),
          (_e.cmp = o.Cb({
            type: _e,
            selectors: [["atft-obj-loader"]],
            inputs: {
              texturePath: "texturePath",
              resourcePath: "resourcePath",
              material: "material",
            },
            features: [
              o.yb([
                {
                  provide: Y,
                  useExisting: Object(o.S)(function () {
                    return _e;
                  }),
                },
              ]),
              o.wb,
            ],
            ngContentSelectors: H,
            decls: 1,
            vars: 0,
            template: function (e, t) {
              1 & e && (o.Yb(), o.Xb(0));
            },
            encapsulation: 2,
          })),
          _e),
        Fe =
          (((be = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: be })),
          (be.inj = o.Fb({
            factory: function (e) {
              return new (e || be)();
            },
            imports: [[i.c]],
          })),
          be),
        Ue =
          (((xe = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: xe })),
          (xe.inj = o.Fb({
            factory: function (e) {
              return new (e || xe)();
            },
            imports: [[i.c]],
          })),
          xe),
        Ge =
          (((ye = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: ye })),
          (ye.inj = o.Fb({
            factory: function (e) {
              return new (e || ye)();
            },
            imports: [[i.c]],
          })),
          ye),
        ke =
          (((ge = (function (e) {
            _inherits(n, e);
            var t = _createSuper(n);
            function n(e) {
              var r;
              return (
                _classCallCheck(this, n),
                ((r = t.call(this, e)).rendererService = e),
                (r.background = 16777215),
                (r.fog = !1),
                (r.fogColor = 10526880),
                (r.fogNear = 10),
                (r.fogFar = 500),
                e.setScene(_assertThisInitialized(r)),
                r
              );
            }
            return (
              _createClass(n, [
                {
                  key: "newObject3DInstance",
                  value: function () {
                    var e = new h.Scene();
                    return (
                      (e.background = new h.Color(Z(this.background))),
                      !0 === this.fog &&
                        (e.fog = new h.Fog(
                          Z(this.fogColor),
                          this.fogNear,
                          this.fogFar
                        )),
                      e
                    );
                  },
                },
              ]),
              n
            );
          })(Y)).fac = function (e) {
            return new (e || ge)(o.Ib(W));
          }),
          (ge.cmp = o.Cb({
            type: ge,
            selectors: [["atft-scene"]],
            inputs: {
              background: "background",
              fog: "fog",
              fogColor: "fogColor",
              fogNear: "fogNear",
              fogFar: "fogFar",
            },
            features: [
              o.yb([
                {
                  provide: Y,
                  useExisting: Object(o.S)(function () {
                    return ge;
                  }),
                },
              ]),
              o.wb,
            ],
            ngContentSelectors: H,
            decls: 1,
            vars: 0,
            template: function (e, t) {
              1 & e && (o.Yb(), o.Xb(0));
            },
            encapsulation: 2,
          })),
          ge),
        He =
          (((ve = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: ve })),
          (ve.inj = o.Fb({
            factory: function (e) {
              return new (e || ve)();
            },
            imports: [
              [i.c, Ae, Re, Oe, Fe, Ue, Ge],
              i.c,
              Ae,
              Re,
              Oe,
              Fe,
              Ue,
              Ge,
            ],
          })),
          ve),
        je =
          (((me = (function () {
            function e() {
              _classCallCheck(this, e),
                (this.raycaster = new h.Raycaster()),
                (this.enabled = !1),
                (this.groups = []),
                (this.paused = !1),
                (this.onMouseMove = this.onMouseMove.bind(this)),
                (this.onMouseDown = this.onMouseDown.bind(this)),
                (this.onTouchStart = this.onTouchStart.bind(this)),
                this.subscribe();
            }
            return (
              _createClass(e, [
                {
                  key: "ngOnDestroy",
                  value: function () {
                    this.disable(), this.unsubscribe();
                  },
                },
                {
                  key: "subscribe",
                  value: function () {
                    window.addEventListener("mousemove", this.onMouseMove),
                      window.addEventListener("mousedown", this.onMouseDown),
                      window.addEventListener("touchstart", this.onTouchStart);
                  },
                },
                {
                  key: "unsubscribe",
                  value: function () {
                    window.removeEventListener("mousemove", this.onMouseMove),
                      window.removeEventListener("mousedown", this.onMouseDown),
                      window.removeEventListener(
                        "touchstart",
                        this.onTouchStart
                      );
                  },
                },
                {
                  key: "enable",
                  value: function () {
                    this.enabled = !0;
                  },
                },
                {
                  key: "disable",
                  value: function () {
                    this.enabled = !1;
                  },
                },
                {
                  key: "pause",
                  value: function () {
                    this.paused = !0;
                  },
                },
                {
                  key: "resume",
                  value: function () {
                    this.paused = !1;
                  },
                },
                {
                  key: "setCamera",
                  value: function (e) {
                    this.camera = e;
                  },
                },
                {
                  key: "addGroup",
                  value: function (e) {
                    this.groups.push(e);
                  },
                },
                {
                  key: "onMouseMove",
                  value: function (e) {
                    if (this.isReady()) {
                      e.preventDefault();
                      var t = this.getFirstIntersectedGroup(e.layerX, e.layerY);
                      (this.selected && this.selected === t) ||
                        (this.selected &&
                          (this.selected.dispatchEvent({ type: "mouseExit" }),
                          (this.selected = null)),
                        t &&
                          ((this.selected = t),
                          this.selected.dispatchEvent({ type: "mouseEnter" })));
                    }
                  },
                },
                {
                  key: "onMouseDown",
                  value: function (e) {
                    if (this.isReady(!0)) {
                      e.preventDefault();
                      var t = this.getFirstIntersectedGroup(e.layerX, e.layerY);
                      t && t.dispatchEvent({ type: "mouseDown" });
                    }
                  },
                },
                {
                  key: "onTouchStart",
                  value: function (e) {
                    if (this.isReady()) {
                      e.preventDefault();
                      var t = this.getFirstIntersectedGroup(
                        e.touches[0].clientX,
                        e.touches[0].clientY
                      );
                      t && t.dispatchEvent({ type: "mouseDown" });
                    }
                  },
                },
                {
                  key: "isReady",
                  value: function (e) {
                    return (
                      this.enabled &&
                      (e || !this.paused) &&
                      this.camera &&
                      this.camera.camera &&
                      this.groups &&
                      this.groups.length > 0
                    );
                  },
                },
                {
                  key: "getFirstIntersectedGroup",
                  value: function (e, t) {
                    (e = (e / window.innerWidth) * 2 - 1),
                      (t = (-t / window.innerHeight) * 2 + 1);
                    var n,
                      r,
                      i = new h.Vector3(e, t, 0.5);
                    this.raycaster.setFromCamera(i, this.camera.camera);
                    for (var a = 0; a < this.groups.length; a++) {
                      var o = this.groups[a].getObject(),
                        s = this.raycaster.intersectObject(o, !0);
                      s.length > 0 &&
                        (!n || n.distance > s[0].distance) &&
                        ((n = s[0]), (r = o));
                    }
                    return r || void 0;
                  },
                },
                {
                  key: "isEnabled",
                  get: function () {
                    return this.enabled;
                  },
                },
              ]),
              e
            );
          })()).fac = function (e) {
            return new (e || me)();
          }),
          (me.prov = o.Eb({ token: me, factory: me.fac })),
          me),
        Ve =
          (((fe = (function () {
            function e(t) {
              _classCallCheck(this, e),
                (this.rendererService = t),
                (this.onResize = this.onResize.bind(this));
            }
            return (
              _createClass(e, [
                {
                  key: "ngAfterViewInit",
                  value: function () {
                    this.rendererService.initialize(this.canvas);
                  },
                },
                {
                  key: "onResize",
                  value: function (e) {
                    this.rendererService.resize(this.canvas, "100px"),
                      this.rendererService.resize(this.canvas, "100%");
                  },
                },
                {
                  key: "renderPane",
                  get: function () {
                    return this.canvasRef;
                  },
                },
                {
                  key: "canvas",
                  get: function () {
                    return this.canvasRef.nativeElement;
                  },
                },
              ]),
              e
            );
          })()).fac = function (e) {
            return new (e || fe)(o.Ib(W));
          }),
          (fe.cmp = o.Cb({
            type: fe,
            selectors: [["atft-renderer-canvas"]],
            viewQuery: function (e, t) {
              var n;
              1 & e && o.fc(j, !0),
                2 & e && o.bc((n = o.Tb())) && (t.canvasRef = n.first);
            },
            hostBindings: function (e, t) {
              1 & e &&
                o.Sb(
                  "resize",
                  function (e) {
                    return t.onResize(e);
                  },
                  !1,
                  o.cc
                );
            },
            ngContentSelectors: H,
            decls: 3,
            vars: 0,
            consts: [["canvas", ""]],
            template: function (e, t) {
              1 & e && (o.Yb(), o.Lb(0, "canvas", null, 0), o.Xb(2), o.Kb());
            },
            styles: [
              "[_nghost-%COMP%]{display:flex;flex:1}canvas[_ngcontent-%COMP%]{flex:1}",
            ],
          })),
          fe),
        We =
          (((pe = (function () {
            function e(t, n) {
              _classCallCheck(this, e),
                (this.rendererService = t),
                (this.raycasterService = n);
            }
            return (
              _createClass(e, [
                {
                  key: "ngOnChanges",
                  value: function (e) {
                    this.controls &&
                      e.listeningControlElement &&
                      (this.controls.dispose(), this.setUpControls());
                  },
                },
                {
                  key: "ngOnDestroy",
                  value: function () {
                    this.controls && this.controls.dispose();
                  },
                },
                {
                  key: "configureListeners",
                  value: function () {
                    var e = this;
                    this.controls.addEventListener("change", function () {
                      e.rendererService.render();
                    }),
                      this.raycasterService.isEnabled &&
                        (this.controls.addEventListener("start", function () {
                          e.raycasterService.pause();
                        }),
                        this.controls.addEventListener("end", function () {
                          e.raycasterService.resume();
                        }));
                  },
                },
                {
                  key: "ngAfterViewInit",
                  value: function () {
                    if (
                      void 0 === this.childCameras ||
                      void 0 === this.childCameras.first
                    )
                      throw new Error("Camera is not found");
                    if (!this.webGlRenderer)
                      throw new Error("webGlRenderer is not found");
                    (this.listeningControlElement = this.webGlRenderer.renderPane),
                      this.setUpControls(),
                      this.configureListeners(),
                      this.rendererService.render();
                  },
                },
              ]),
              e
            );
          })()).fac = function (e) {
            o.Rb();
          }),
          (pe.dir = o.Db({
            type: pe,
            contentQueries: function (e, t, n) {
              var r;
              1 & e && (o.Bb(n, Ve, !0), o.Bb(n, V, !0)),
                2 & e &&
                  (o.bc((r = o.Tb())) && (t.webGlRenderer = r.first),
                  o.bc((r = o.Tb())) && (t.childCameras = r));
            },
            features: [o.xb],
          })),
          pe),
        qe =
          (((de = (function (e) {
            _inherits(n, e);
            var t = _createSuper(n);
            function n(e, r) {
              var i;
              return (
                _classCallCheck(this, n),
                ((i = t.call(this, e, r)).rendererService = e),
                (i.raycasterService = r),
                (i.rotateSpeed = 1),
                (i.zoomSpeed = 1.2),
                i
              );
            }
            return (
              _createClass(n, [
                {
                  key: "setUpControls",
                  value: function () {
                    (this.controls = new N(
                      this.childCameras.first.camera,
                      this.listeningControlElement &&
                        this.listeningControlElement.nativeElement
                    )),
                      (this.controls.rotateSpeed = this.rotateSpeed),
                      (this.controls.zoomSpeed = this.zoomSpeed);
                  },
                },
                {
                  key: "ngOnChanges",
                  value: function (e) {
                    this.controls &&
                      (_get(
                        _getPrototypeOf(n.prototype),
                        "ngOnChanges",
                        this
                      ).call(this, e),
                      e.rotateSpeed &&
                        (this.controls.rotateSpeed = this.rotateSpeed),
                      e.zoomSpeed &&
                        (this.controls.zoomSpeed = this.zoomSpeed));
                  },
                },
              ]),
              n
            );
          })(We)).fac = function (e) {
            return new (e || de)(o.Ib(W), o.Ib(je));
          }),
          (de.cmp = o.Cb({
            type: de,
            selectors: [["atft-orbit-controls"]],
            inputs: { rotateSpeed: "rotateSpeed", zoomSpeed: "zoomSpeed" },
            features: [o.wb, o.xb],
            ngContentSelectors: H,
            decls: 1,
            vars: 0,
            template: function (e, t) {
              1 & e && (o.Yb(), o.Xb(0));
            },
            styles: ["[_nghost-%COMP%]{display:flex;flex:1}"],
          })),
          de),
        Xe =
          (((he = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: he })),
          (he.inj = o.Fb({
            factory: function (e) {
              return new (e || he)();
            },
            imports: [[i.c]],
          })),
          he),
        Ye =
          (((le = (function () {
            function e() {
              _classCallCheck(this, e);
            }
            return (
              _createClass(e, [
                {
                  key: "transform",
                  value: function (e) {
                    return (e / 180) * Math.PI;
                  },
                },
              ]),
              e
            );
          })()).fac = function (e) {
            return new (e || le)();
          }),
          (le.pipe = o.Hb({ name: "deg2rad", type: le, pure: !0 })),
          le),
        Ze =
          (((ue = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: ue })),
          (ue.inj = o.Fb({
            factory: function (e) {
              return new (e || ue)();
            },
            imports: [[i.c]],
          })),
          ue),
        Je =
          (((ce = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: ce })),
          (ce.inj = o.Fb({
            factory: function (e) {
              return new (e || ce)();
            },
            providers: [W],
            imports: [[i.c]],
          })),
          ce),
        Ke =
          (((se = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: se })),
          (se.inj = o.Fb({
            factory: function (e) {
              return new (e || se)();
            },
            providers: [Ee],
          })),
          se),
        Qe =
          (((oe = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: oe })),
          (oe.inj = o.Fb({
            factory: function (e) {
              return new (e || oe)();
            },
            providers: [je],
            imports: [[i.c]],
          })),
          oe),
        $e =
          (((ae = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: ae })),
          (ae.inj = o.Fb({
            factory: function (e) {
              return new (e || ae)();
            },
            imports: [[X, He, Xe, Ze, Je, Ke, Qe], X, He, Xe, Ze, Je, Ke, Qe],
          })),
          ae),
        et = [
          {
            path: "",
            component: l,
            children: [
              {
                path: "",
                pathMatch: "full",
                component:
                  ((Me = (function () {
                    function e() {
                      _classCallCheck(this, e);
                    }
                    return (
                      _createClass(e, [
                        { key: "ngOnInit", value: function () {} },
                      ]),
                      e
                    );
                  })()),
                  (Me.fac = function (e) {
                    return new (e || Me)();
                  }),
                  (Me.cmp = o.Cb({
                    type: Me,
                    selectors: [["app-mesh"]],
                    decls: 7,
                    vars: 5,
                    consts: [
                      [3, "rotateSpeed", "zoomSpeed"],
                      ["mainRenderer", ""],
                      [
                        "positionX",
                        "20",
                        "positionY",
                        "50",
                        "positionZ",
                        "50",
                        3,
                        "fov",
                        "near",
                        "far",
                      ],
                      ["size", "200"],
                      ["size", "100", "divisions", "10"],
                    ],
                    template: function (e, t) {
                      1 & e &&
                        (o.Lb(0, "atft-orbit-controls", 0),
                        o.Lb(1, "atft-renderer-canvas", null, 1),
                        o.Jb(3, "atft-perspective-camera", 2),
                        o.Lb(4, "atft-scene"),
                        o.Jb(5, "atft-axes-helper", 3),
                        o.Jb(6, "atft-grid-helper", 4),
                        o.Kb(),
                        o.Kb(),
                        o.Kb()),
                        2 & e &&
                          (o.Zb("rotateSpeed", 1)("zoomSpeed", 1.2),
                          o.zb(3),
                          o.Zb("fov", 60)("near", 1)("far", 1100));
                    },
                    directives: [qe, Ve, q, ke, Le, Ce],
                    styles: [""],
                  })),
                  Me),
              },
              {
                path: "object",
                component:
                  ((we = (function () {
                    function e() {
                      _classCallCheck(this, e);
                    }
                    return (
                      _createClass(e, [
                        { key: "ngOnInit", value: function () {} },
                      ]),
                      e
                    );
                  })()),
                  (we.fac = function (e) {
                    return new (e || we)();
                  }),
                  (we.cmp = o.Cb({
                    type: we,
                    selectors: [["app-object"]],
                    decls: 10,
                    vars: 9,
                    consts: [
                      [3, "rotateSpeed", "zoomSpeed"],
                      [
                        "positionX",
                        "50",
                        "positionY",
                        "-20",
                        "positionZ",
                        "50",
                        3,
                        "zAxisUp",
                        "fov",
                        "near",
                        "far",
                      ],
                      ["size", "200"],
                      ["size", "100", "divisions", "10", 3, "rotateX"],
                      [
                        "distance",
                        "1000",
                        "intensity",
                        "0.6",
                        "translateX",
                        "90",
                        "translateY",
                        "90",
                        "translateZ",
                        "90",
                      ],
                      ["distance", "1000", "intensity", "0.6"],
                      [
                        "model",
                        "assets/model/smiley/smiley.obj",
                        "material",
                        "assets/model/smiley/smiley.mtl",
                        "texturePath",
                        "assets/model/smiley/",
                        "translateX",
                        "-60",
                        "translateY",
                        "-40",
                      ],
                    ],
                    template: function (e, t) {
                      1 & e &&
                        (o.Lb(0, "atft-orbit-controls", 0),
                        o.Lb(1, "atft-renderer-canvas"),
                        o.Jb(2, "atft-perspective-camera", 1),
                        o.Lb(3, "atft-scene"),
                        o.Jb(4, "atft-axes-helper", 2),
                        o.Jb(5, "atft-grid-helper", 3),
                        o.Vb(6, "deg2rad"),
                        o.Jb(7, "atft-point-light", 4),
                        o.Jb(8, "atft-point-light", 5),
                        o.Jb(9, "atft-obj-loader", 6),
                        o.Kb(),
                        o.Kb(),
                        o.Kb()),
                        2 & e &&
                          (o.Zb("rotateSpeed", 1)("zoomSpeed", 1.2),
                          o.zb(2),
                          o.Zb("zAxisUp", !0)("fov", 60)("near", 1)(
                            "far",
                            1100
                          ),
                          o.zb(3),
                          o.Zb("rotateX", o.Wb(6, 7, 90)));
                    },
                    directives: [qe, Ve, q, ke, Le, Ce, Pe, ze],
                    pipes: [Ye],
                    styles: [""],
                  })),
                  we),
              },
            ],
          },
        ],
        tt =
          (((Te = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: Te })),
          (Te.inj = o.Fb({
            factory: function (e) {
              return new (e || Te)();
            },
            imports: [[a.c.forChild(et)], a.c],
          })),
          Te),
        nt =
          (((Se = function e() {
            _classCallCheck(this, e);
          }).mod = o.Gb({ type: Se })),
          (Se.inj = o.Fb({
            factory: function (e) {
              return new (e || Se)();
            },
            imports: [[i.c, tt, $e]],
          })),
          Se);
    },
  },
]);
